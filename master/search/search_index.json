{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Traefik is an open-source Edge Router that makes publishing your services a fun and easy experience. It receives requests on behalf of your system and finds out which components are responsible for handling them. What sets Traefik apart, besides its many features, is that it automatically discovers the right configuration for your services. The magic happens when Traefik inspects your infrastructure, where it finds relevant information and discovers which service serves which request. Traefik is natively compliant with every major cluster technology, such as Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon, and the list goes on ; and can handle many at the same time. (It even works for legacy software running on bare metal.) With Traefik, there is no need to maintain and synchronize a separate configuration file: everything happens automatically, in real time (no restarts, no connection interruptions). With Traefik, you spend time developing and deploying new features to your system, not on configuring and maintaining its working state. Developing Traefik, our main goal is to make it simple to use, and we're sure you'll enjoy it. -- The Traefik Maintainer Team Note If you're a businness running critical services behind Traefik, know that Containous , the company that sponsors Traefik's development, can provide commercial support and develops an Enterprise Edition of Traefik.","title":"Welcome"},{"location":"#welcome","text":"Traefik is an open-source Edge Router that makes publishing your services a fun and easy experience. It receives requests on behalf of your system and finds out which components are responsible for handling them. What sets Traefik apart, besides its many features, is that it automatically discovers the right configuration for your services. The magic happens when Traefik inspects your infrastructure, where it finds relevant information and discovers which service serves which request. Traefik is natively compliant with every major cluster technology, such as Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon, and the list goes on ; and can handle many at the same time. (It even works for legacy software running on bare metal.) With Traefik, there is no need to maintain and synchronize a separate configuration file: everything happens automatically, in real time (no restarts, no connection interruptions). With Traefik, you spend time developing and deploying new features to your system, not on configuring and maintaining its working state. Developing Traefik, our main goal is to make it simple to use, and we're sure you'll enjoy it. -- The Traefik Maintainer Team Note If you're a businness running critical services behind Traefik, know that Containous , the company that sponsors Traefik's development, can provide commercial support and develops an Enterprise Edition of Traefik.","title":"Welcome"},{"location":"glossary/","text":"TODO -- Glossary \u00b6 Where Every Technical Word finds its Definition` Provider Types of providers (KV, annotation based, label based, configuration based) Entrypoint Routers Middleware Service Static Configuration Dynamic Configuration ACME TraefikEE Tracing Metrics Orchestrator Key Value Store Logs Traefiker Traefik (How to pronounce)","title":"Glossary"},{"location":"glossary/#todo-glossary","text":"Where Every Technical Word finds its Definition` Provider Types of providers (KV, annotation based, label based, configuration based) Entrypoint Routers Middleware Service Static Configuration Dynamic Configuration ACME TraefikEE Tracing Metrics Orchestrator Key Value Store Logs Traefiker Traefik (How to pronounce)","title":"TODO -- Glossary"},{"location":"contributing/advocating/","text":"Advocating \u00b6 Spread the Love & Tell Us about It There are many ways to contribute to the project, and there is one that always spark joy: when we see/read about users talking about how Traefik helps them solve their problems. If you're talking about Traefik, let us know and we'll promote your enthusiasm! Also, if you've written about Traefik or shared useful information you'd like to promote, feel free to add links in the dedicated wiki page on Github .","title":"Advocating"},{"location":"contributing/advocating/#advocating","text":"Spread the Love & Tell Us about It There are many ways to contribute to the project, and there is one that always spark joy: when we see/read about users talking about how Traefik helps them solve their problems. If you're talking about Traefik, let us know and we'll promote your enthusiasm! Also, if you've written about Traefik or shared useful information you'd like to promote, feel free to add links in the dedicated wiki page on Github .","title":"Advocating"},{"location":"contributing/building-testing/","text":"Building and Testing \u00b6 Compile and Test Your Own Traefik! So you want to build your own Traefik binary from the sources? Let's see how. Building \u00b6 You need either Docker and make (Method 1), or go (Method 2) in order to build Traefik. For changes to its dependencies, the dep dependency management tool is required. Method 1: Using Docker and Makefile \u00b6 Run make with the binary target. This will create binaries for the Linux platform in the dist folder. $ make binary docker build -t traefik-webui -f webui/Dockerfile webui Sending build context to Docker daemon 2.686MB Step 1/11 : FROM node:8.15.0 ---> 1f6c34f7921c [...] Successfully built ce4ff439c06a Successfully tagged traefik-webui:latest [...] docker build -t \"traefik-dev:4475--feature-documentation\" -f build.Dockerfile . Sending build context to Docker daemon 279MB Step 1/10 : FROM golang:1.12-alpine ---> f4bfb3d22bda [...] Successfully built 5c3c1a911277 Successfully tagged traefik-dev:4475--feature-documentation docker run -e \"TEST_CONTAINER=1\" -v \"/var/run/docker.sock:/var/run/docker.sock\" -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -e VERBOSE -e VERSION -e CODENAME -e TESTDIRS -e CI -e CONTAINER=DOCKER -v \"/home/ldez/sources/go/src/github.com/containous/traefik/\"dist\":/go/src/github.com/containous/traefik/\"dist\"\" \"traefik-dev:4475--feature-documentation\" ./script/make.sh generate binary ---> Making bundle: generate (in .) removed 'autogen/genstatic/gen.go' ---> Making bundle: binary (in .) $ ls dist/ traefik* The following targets can be executed outside Docker (we don't recommend that): test-unit test-integration validate binary (the webUI is still generated by using Docker) ex: PRE_TARGET= make test-unit Method 2: Using go \u00b6 You need go v1.9+. Source Directory It is recommended that you clone Traefik into the ~/go/src/github.com/containous/traefik directory. This is the official golang workspace hierarchy that will allow dependencies to be properly resolved. Environment Set your GOPATH and PATH variable to be set to ~/go via: export GOPATH=~/go export PATH=$PATH:$GOPATH/bin For convenience, add GOPATH and PATH to your .bashrc or .bash_profile Verify your environment is setup properly by running $ go env . Depending on your OS and environment, you should see an output similar to: GOARCH=\"amd64\" GOBIN=\"\" GOEXE=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOOS=\"linux\" GOPATH=\"/home/<yourusername>/go\" GORACE=\"\" ## ... and the list goes on Build Traefik \u00b6 Once you've set up your go environment and cloned the source repository, you can build Traefik. Beforehand, you need to get go-bindata (the first time) in order to be able to use the go generate command (which is part of the build process). cd ~/go/src/github.com/containous/traefik # Get go-bindata. (Important: the ellipses are required.) go get github.com/containous/go-bindata/... # Let's build # generate # (required to merge non-code components into the final binary, such as the web dashboard and the provider's templates) go generate # Standard go build go build ./cmd/traefik You will find the Traefik executable ( traefik ) in the ~/go/src/github.com/containous/traefik directory. Updating the templates \u00b6 If you happen to update the provider's templates (located in /templates ), you must run go generate to update the autogen package. Setting up dependency management \u00b6 The dep command is not required for building; however, it is necessary if you need to update the dependencies (i.e., add, update, or remove third-party packages). You need dep >= 0.5.0. If you want to add a dependency, use dep ensure -add to have dep put it into the vendor folder and update the dep manifest/lock files ( Gopkg.toml and Gopkg.lock , respectively). A following make dep-prune run should be triggered to trim down the size of the vendor folder. The final result must be committed into VCS. Here's a full example using dep to add a new dependency: # install the new main dependency github.com/foo/bar and minimize vendor size $ dep ensure -add github.com/foo/bar # generate (Only required to integrate other components such as web dashboard) $ go generate # Standard go build $ go build ./cmd/traefik Testing \u00b6 Method 1: Docker and make \u00b6 Run unit tests using the test-unit target. Run integration tests using the test-integration target. Run all tests (unit and integration) using the test target. $ make test-unit docker build -t \"traefik-dev:your-feature-branch\" -f build.Dockerfile . # [\u2026] docker run --rm -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -v \"/home/user/go/src/github/containous/traefik/dist:/go/src/github.com/containous/traefik/dist\" \"traefik-dev:your-feature-branch\" ./script/make.sh generate test-unit ---> Making bundle: generate (in .) removed 'gen.go' ---> Making bundle: test-unit (in .) + go test -cover -coverprofile=cover.out . ok github.com/containous/traefik 0.005s coverage: 4.1% of statements Test success For development purposes, you can specify which tests to run by using (only works the test-integration target): # Run every tests in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More: https://labix.org/gocheck Method 2: go \u00b6 Unit tests can be run from the cloned directory using $ go test ./... which should return ok , similar to: ok _/home/user/go/src/github/containous/traefik 0.004s Integration tests must be run from the integration/ directory and require the -integration switch: $ cd integration && go test -integration ./... .","title":"Building and Testing"},{"location":"contributing/building-testing/#building-and-testing","text":"Compile and Test Your Own Traefik! So you want to build your own Traefik binary from the sources? Let's see how.","title":"Building and Testing"},{"location":"contributing/building-testing/#building","text":"You need either Docker and make (Method 1), or go (Method 2) in order to build Traefik. For changes to its dependencies, the dep dependency management tool is required.","title":"Building"},{"location":"contributing/building-testing/#method-1-using-docker-and-makefile","text":"Run make with the binary target. This will create binaries for the Linux platform in the dist folder. $ make binary docker build -t traefik-webui -f webui/Dockerfile webui Sending build context to Docker daemon 2.686MB Step 1/11 : FROM node:8.15.0 ---> 1f6c34f7921c [...] Successfully built ce4ff439c06a Successfully tagged traefik-webui:latest [...] docker build -t \"traefik-dev:4475--feature-documentation\" -f build.Dockerfile . Sending build context to Docker daemon 279MB Step 1/10 : FROM golang:1.12-alpine ---> f4bfb3d22bda [...] Successfully built 5c3c1a911277 Successfully tagged traefik-dev:4475--feature-documentation docker run -e \"TEST_CONTAINER=1\" -v \"/var/run/docker.sock:/var/run/docker.sock\" -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -e VERBOSE -e VERSION -e CODENAME -e TESTDIRS -e CI -e CONTAINER=DOCKER -v \"/home/ldez/sources/go/src/github.com/containous/traefik/\"dist\":/go/src/github.com/containous/traefik/\"dist\"\" \"traefik-dev:4475--feature-documentation\" ./script/make.sh generate binary ---> Making bundle: generate (in .) removed 'autogen/genstatic/gen.go' ---> Making bundle: binary (in .) $ ls dist/ traefik* The following targets can be executed outside Docker (we don't recommend that): test-unit test-integration validate binary (the webUI is still generated by using Docker) ex: PRE_TARGET= make test-unit","title":"Method 1: Using Docker and Makefile"},{"location":"contributing/building-testing/#method-2-using-go","text":"You need go v1.9+. Source Directory It is recommended that you clone Traefik into the ~/go/src/github.com/containous/traefik directory. This is the official golang workspace hierarchy that will allow dependencies to be properly resolved. Environment Set your GOPATH and PATH variable to be set to ~/go via: export GOPATH=~/go export PATH=$PATH:$GOPATH/bin For convenience, add GOPATH and PATH to your .bashrc or .bash_profile Verify your environment is setup properly by running $ go env . Depending on your OS and environment, you should see an output similar to: GOARCH=\"amd64\" GOBIN=\"\" GOEXE=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"linux\" GOOS=\"linux\" GOPATH=\"/home/<yourusername>/go\" GORACE=\"\" ## ... and the list goes on","title":"Method 2: Using go"},{"location":"contributing/building-testing/#build-traefik","text":"Once you've set up your go environment and cloned the source repository, you can build Traefik. Beforehand, you need to get go-bindata (the first time) in order to be able to use the go generate command (which is part of the build process). cd ~/go/src/github.com/containous/traefik # Get go-bindata. (Important: the ellipses are required.) go get github.com/containous/go-bindata/... # Let's build # generate # (required to merge non-code components into the final binary, such as the web dashboard and the provider's templates) go generate # Standard go build go build ./cmd/traefik You will find the Traefik executable ( traefik ) in the ~/go/src/github.com/containous/traefik directory.","title":"Build Traefik"},{"location":"contributing/building-testing/#updating-the-templates","text":"If you happen to update the provider's templates (located in /templates ), you must run go generate to update the autogen package.","title":"Updating the templates"},{"location":"contributing/building-testing/#setting-up-dependency-management","text":"The dep command is not required for building; however, it is necessary if you need to update the dependencies (i.e., add, update, or remove third-party packages). You need dep >= 0.5.0. If you want to add a dependency, use dep ensure -add to have dep put it into the vendor folder and update the dep manifest/lock files ( Gopkg.toml and Gopkg.lock , respectively). A following make dep-prune run should be triggered to trim down the size of the vendor folder. The final result must be committed into VCS. Here's a full example using dep to add a new dependency: # install the new main dependency github.com/foo/bar and minimize vendor size $ dep ensure -add github.com/foo/bar # generate (Only required to integrate other components such as web dashboard) $ go generate # Standard go build $ go build ./cmd/traefik","title":"Setting up dependency management"},{"location":"contributing/building-testing/#testing","text":"","title":"Testing"},{"location":"contributing/building-testing/#method-1-docker-and-make","text":"Run unit tests using the test-unit target. Run integration tests using the test-integration target. Run all tests (unit and integration) using the test target. $ make test-unit docker build -t \"traefik-dev:your-feature-branch\" -f build.Dockerfile . # [\u2026] docker run --rm -it -e OS_ARCH_ARG -e OS_PLATFORM_ARG -e TESTFLAGS -v \"/home/user/go/src/github/containous/traefik/dist:/go/src/github.com/containous/traefik/dist\" \"traefik-dev:your-feature-branch\" ./script/make.sh generate test-unit ---> Making bundle: generate (in .) removed 'gen.go' ---> Making bundle: test-unit (in .) + go test -cover -coverprofile=cover.out . ok github.com/containous/traefik 0.005s coverage: 4.1% of statements Test success For development purposes, you can specify which tests to run by using (only works the test-integration target): # Run every tests in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite\" make test-integration # Run the test \"MyTest\" in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.MyTest\" make test-integration # Run every tests starting with \"My\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.My\" make test-integration # Run every tests ending with \"Test\", in the MyTest suite TESTFLAGS=\"-check.f MyTestSuite.*Test\" make test-integration More: https://labix.org/gocheck","title":"Method 1: Docker and make"},{"location":"contributing/building-testing/#method-2-go","text":"Unit tests can be run from the cloned directory using $ go test ./... which should return ok , similar to: ok _/home/user/go/src/github/containous/traefik 0.004s Integration tests must be run from the integration/ directory and require the -integration switch: $ cd integration && go test -integration ./... .","title":"Method 2: go"},{"location":"contributing/data-collection/","text":"Data Collection \u00b6 Understanding How Traefik is Being Used Configuration Example \u00b6 Understanding how you use Traefik is very important to us: it helps us improve the solution in many different ways. For this very reason, the sendAnonymousUsage option is mandatory: we want you to take time to consider whether or not you wish to share anonymous data with us so we can benefit from your experience and use cases. Warning During the alpha stage only, leaving this option unset will not prevent Traefik from running but will generate an error log indicating that it enables data collection by default. Enabling Data Collection with TOML [Global] # Send anonymous usage data sendAnonymousUsage = true Enabling Data Collection with the CLI ./traefik --sendAnonymousUsage=true Collected Data \u00b6 This feature comes from the public proposal here . In order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances. Those data help us prioritize our developments and focus on what's important for our users (for example, which provider is popular, and which is not). What's collected / when ? \u00b6 Once a day (the first call begins 10 minutes after the start of Traefik), we collect: the Traefik version number a hash of the configuration an anonymized version of the static configuration (token, user name, password, URL, IP, domain, email, etc, are removed). Note We do not collect the dynamic configuration information (routers & services). We do not collect these data to run advertising programs. We do not sell these data to third-parties. Example of Collected Data \u00b6 Original configuration [entrypoints] [entrypoints.web] address = \":80\" [api] [Docker] endpoint = \"tcp://10.10.10.10:2375\" domain = \"foo.bir\" exposedByDefault = true swarmMode = true [Docker.TLS] ca = \"dockerCA\" cert = \"dockerCert\" key = \"dockerKey\" insecureSkipVerify = true [ECS] domain = \"foo.bar\" exposedByDefault = true clusters = [\"foo-bar\"] region = \"us-west-2\" accessKeyID = \"AccessKeyID\" secretAccessKey = \"SecretAccessKey\" Resulting Obfuscated Configuration [entrypoints] [entrypoints.web] address = \":80\" [api] [Docker] endpoint = \"xxxx\" domain = \"xxxx\" exposedByDefault = true swarmMode = true [Docker.TLS] ca = \"xxxx\" cert = \"xxxx\" key = \"xxxx\" insecureSkipVerify = false [ECS] domain = \"xxxx\" exposedByDefault = true clusters = [] region = \"us-west-2\" accessKeyID = \"xxxx\" secretAccessKey = \"xxxx\" The Code for Data Collection \u00b6 If you want to dig into more details, here is the source code of the collecting system: collector.go By default we anonymize all configuration fields, except fields tagged with export=true .","title":"Data Collection"},{"location":"contributing/data-collection/#data-collection","text":"Understanding How Traefik is Being Used","title":"Data Collection"},{"location":"contributing/data-collection/#configuration-example","text":"Understanding how you use Traefik is very important to us: it helps us improve the solution in many different ways. For this very reason, the sendAnonymousUsage option is mandatory: we want you to take time to consider whether or not you wish to share anonymous data with us so we can benefit from your experience and use cases. Warning During the alpha stage only, leaving this option unset will not prevent Traefik from running but will generate an error log indicating that it enables data collection by default. Enabling Data Collection with TOML [Global] # Send anonymous usage data sendAnonymousUsage = true Enabling Data Collection with the CLI ./traefik --sendAnonymousUsage=true","title":"Configuration Example"},{"location":"contributing/data-collection/#collected-data","text":"This feature comes from the public proposal here . In order to help us learn more about how Traefik is being used and improve it, we collect anonymous usage statistics from running instances. Those data help us prioritize our developments and focus on what's important for our users (for example, which provider is popular, and which is not).","title":"Collected Data"},{"location":"contributing/data-collection/#whats-collected-when","text":"Once a day (the first call begins 10 minutes after the start of Traefik), we collect: the Traefik version number a hash of the configuration an anonymized version of the static configuration (token, user name, password, URL, IP, domain, email, etc, are removed). Note We do not collect the dynamic configuration information (routers & services). We do not collect these data to run advertising programs. We do not sell these data to third-parties.","title":"What's collected / when ?"},{"location":"contributing/data-collection/#example-of-collected-data","text":"Original configuration [entrypoints] [entrypoints.web] address = \":80\" [api] [Docker] endpoint = \"tcp://10.10.10.10:2375\" domain = \"foo.bir\" exposedByDefault = true swarmMode = true [Docker.TLS] ca = \"dockerCA\" cert = \"dockerCert\" key = \"dockerKey\" insecureSkipVerify = true [ECS] domain = \"foo.bar\" exposedByDefault = true clusters = [\"foo-bar\"] region = \"us-west-2\" accessKeyID = \"AccessKeyID\" secretAccessKey = \"SecretAccessKey\" Resulting Obfuscated Configuration [entrypoints] [entrypoints.web] address = \":80\" [api] [Docker] endpoint = \"xxxx\" domain = \"xxxx\" exposedByDefault = true swarmMode = true [Docker.TLS] ca = \"xxxx\" cert = \"xxxx\" key = \"xxxx\" insecureSkipVerify = false [ECS] domain = \"xxxx\" exposedByDefault = true clusters = [] region = \"us-west-2\" accessKeyID = \"xxxx\" secretAccessKey = \"xxxx\"","title":"Example of Collected Data"},{"location":"contributing/data-collection/#the-code-for-data-collection","text":"If you want to dig into more details, here is the source code of the collecting system: collector.go By default we anonymize all configuration fields, except fields tagged with export=true .","title":"The Code for Data Collection"},{"location":"contributing/documentation/","text":"Documentation \u00b6 Features Are Better When You Know How to Use Them You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how. Building Documentation \u00b6 General \u00b6 This documentation is built with mkdocs . Method 1: Docker and make \u00b6 You can build the documentation and test it locally (with live reloading), using the docs target: $ make docs docker build -t traefik-docs -f docs.Dockerfile . # [\u2026] docker run --rm -v /home/user/go/github/containous/traefik:/mkdocs -p 8000:8000 traefik-docs mkdocs serve # [\u2026] [I 170828 20:47:48 server:283] Serving on http://0.0.0.0:8000 [I 170828 20:47:48 handlers:60] Start watching changes [I 170828 20:47:48 handlers:62] Start detecting changes Default URL Your local documentation server will run by default on http://127.0.0.1:8000 . If you only want to build the documentation without serving it locally, you can use the following command: $ make docs-build ... Method 2: mkdocs \u00b6 First, make sure you have python and pip installed. $ python --version Python 2.7.2 $ pip --version pip 1.5.2 Then, install mkdocs with pip . pip install --user -r requirements.txt To build the documentation locally and serve it locally, run mkdocs serve from the root directory. This will start a local server. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes Check the Documentation \u00b6 To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the docs-verify target. $ make docs-verify docker build -t traefik-docs-verify ./script/docs-verify-docker-image ## Build Validator image ... docker run --rm -v /home/travis/build/containous/traefik:/app traefik-docs-verify ## Check for dead links and w3c compliance === Checking HTML content... Running [\"HtmlCheck\", \"ImageCheck\", \"ScriptCheck\", \"LinkCheck\"] on /app/site/basics/index.html on *.html... Clean & Verify If you've made changes to the documentation, it's safter to clean it before verifying it. $ make docs-clean docs-verify ... Disabling Documentation Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : DOCS_VERIFY_SKIP=true make docs-verify ... DOCS_LINT_SKIP is true: no linting done.","title":"Documentation"},{"location":"contributing/documentation/#documentation","text":"Features Are Better When You Know How to Use Them You've found something unclear in the documentation and want to give a try at explaining it better? Let's see how.","title":"Documentation"},{"location":"contributing/documentation/#building-documentation","text":"","title":"Building Documentation"},{"location":"contributing/documentation/#general","text":"This documentation is built with mkdocs .","title":"General"},{"location":"contributing/documentation/#method-1-docker-and-make","text":"You can build the documentation and test it locally (with live reloading), using the docs target: $ make docs docker build -t traefik-docs -f docs.Dockerfile . # [\u2026] docker run --rm -v /home/user/go/github/containous/traefik:/mkdocs -p 8000:8000 traefik-docs mkdocs serve # [\u2026] [I 170828 20:47:48 server:283] Serving on http://0.0.0.0:8000 [I 170828 20:47:48 handlers:60] Start watching changes [I 170828 20:47:48 handlers:62] Start detecting changes Default URL Your local documentation server will run by default on http://127.0.0.1:8000 . If you only want to build the documentation without serving it locally, you can use the following command: $ make docs-build ...","title":"Method 1: Docker and make"},{"location":"contributing/documentation/#method-2-mkdocs","text":"First, make sure you have python and pip installed. $ python --version Python 2.7.2 $ pip --version pip 1.5.2 Then, install mkdocs with pip . pip install --user -r requirements.txt To build the documentation locally and serve it locally, run mkdocs serve from the root directory. This will start a local server. $ mkdocs serve INFO - Building documentation... INFO - Cleaning site directory [I 160505 22:31:24 server:281] Serving on http://127.0.0.1:8000 [I 160505 22:31:24 handlers:59] Start watching changes [I 160505 22:31:24 handlers:61] Start detecting changes","title":"Method 2: mkdocs"},{"location":"contributing/documentation/#check-the-documentation","text":"To check that the documentation meets standard expectations (no dead links, html markup validity, ...), use the docs-verify target. $ make docs-verify docker build -t traefik-docs-verify ./script/docs-verify-docker-image ## Build Validator image ... docker run --rm -v /home/travis/build/containous/traefik:/app traefik-docs-verify ## Check for dead links and w3c compliance === Checking HTML content... Running [\"HtmlCheck\", \"ImageCheck\", \"ScriptCheck\", \"LinkCheck\"] on /app/site/basics/index.html on *.html... Clean & Verify If you've made changes to the documentation, it's safter to clean it before verifying it. $ make docs-clean docs-verify ... Disabling Documentation Verification Verification can be disabled by setting the environment variable DOCS_VERIFY_SKIP to true : DOCS_VERIFY_SKIP=true make docs-verify ... DOCS_LINT_SKIP is true: no linting done.","title":"Check the Documentation"},{"location":"contributing/maintainers/","text":"Maintainers \u00b6 The team \u00b6 Emile Vauge @emilevauge Vincent Demeester @vdemeester Ed Robinson @errm Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Timo Reimann @timoreimann Ludovic Fernandez @ldez Julien Salleyron @juliens Nicolas Mengin @nmengin Marco Jantke @marco-jantke Micha\u00ebl Matur @mmatur G\u00e9rald Cro\u00ebs @geraldcroes Jean-Baptiste Doumenjou @jbdoumenjou Damien Duportal @dduportal Contributions Daily Meeting \u00b6 3 Maintainers should attend to a Contributions Daily Meeting where we sort and label new issues ( is:issue label:status/0-needs-triage ), and review every Pull Requests Every pull request should be checked during the Contributions Daily Meeting Even if it\u2019s already assigned Even PR labelled with contributor/waiting-for-corrections or contributor/waiting-for-feedback Issues labeled with priority/P0 and priority/P1 should be assigned. Modifying an issue or a pull request (labels, assignees, milestone) is only possible: During the Contributions Daily Meeting By an assigned maintainer In case of emergency, if a change proposal is approved by 2 other maintainers (on Slack, Discord, etc) PR review process: \u00b6 The status needs-design-review is only used in complex/heavy/tricky PRs. From 1 to 2 : 1 comment that says \u201cdesign LGTM\u201d (by a senior maintainer). From 2 to 3 : 3 LGTM approvals by any maintainer. If needed, a specific maintainer familiar with a particular domain can be requested for the review. If a PR has been implemented in pair programming, one peer's LGTM goes into the review for free Amending someone else's pull request is authorized only in emergency, if a rebase is needed, or if the initial contributor is silent We use PRM to manage locally pull requests. Bots \u00b6 Myrmica Lobicornis \u00b6 Update and Merge Pull Request. The maintainer giving the final LGTM must add the status/3-needs-merge label to trigger the merge bot. By default, a squash-rebase merge will be carried out. To preserve commits, add bot/merge-method-rebase before status/3-needs-merge . The status status/4-merge-in-progress is only used by the bot. If the bot is not able to perform the merge, the label bot/need-human-merge is added. In such a situation, solve the conflicts/CI/... and then remove the label bot/need-human-merge . To prevent the bot from automatically merging a PR, add the label bot/no-merge . The label bot/light-review decreases the number of required LGTM from 3 to 1. This label is used when: Updating the vendors from previously reviewed PRs Merging branches into the master Preparing the release Myrmica Bibikoffi \u00b6 closes stale issues [cron] use some criterion as number of days between creation, last update, labels, ... Myrmica Aloba \u00b6 Manage GitHub labels. Add labels on new PR [GitHub WebHook] Add milestone to a new PR based on a branch version (1.4, 1.3, ...) [GitHub WebHook] Add and remove contributor/waiting-for-corrections label when a review request changes [GitHub WebHook] Weekly report of PR status on Slack (CaptainPR) [cron] Labels \u00b6 A maintainer that looks at an issue/PR must define its kind/* , area/* , and status/* . Status - Workflow \u00b6 The status/* labels represent the desired state in the workflow. status/0-needs-triage : all the new issues and PRs have this status. [bot only] status/1-needs-design-review : needs a design review. (only for PR) status/2-needs-review : needs a code/documentation review. (only for PR) status/3-needs-merge : ready to merge. (only for PR) status/4-merge-in-progress : merge is in progress. [bot only] Contributor \u00b6 contributor/need-more-information : we need more information from the contributor in order to analyze a problem. contributor/waiting-for-feedback : we need the contributor to give us feedback. contributor/waiting-for-corrections : we need the contributor to take actions in order to move forward with a PR. (only for PR) [bot, humans] contributor/needs-resolve-conflicts : use it only when there is some conflicts (and an automatic rebase is not possible). (only for PR) [bot, humans] Kind \u00b6 kind/enhancement : a new or improved feature. kind/question : a question. (only for issue) kind/proposal : a proposal that needs to be discussed. Proposal issues are design proposals Proposal PRs are technical prototypes that need to be refined with multiple contributors. kind/bug/possible : a possible bug that needs analysis before it is confirmed or fixed. (only for issues) kind/bug/confirmed : a confirmed bug (reproducible). (only for issues) kind/bug/fix : a bug fix. (only for PR) Resolution \u00b6 resolution/duplicate : a duplicate issue/PR. resolution/declined : declined (Rule #1 of open-source: no is temporary, yes is forever). WIP : Work In Progress. (only for PR) Platform \u00b6 platform/windows : Windows related. Area \u00b6 area/acme : ACME related. area/api : Traefik API related. area/authentication : Authentication related. area/cluster : Traefik clustering related. area/documentation : Documentation related. area/infrastructure : CI or Traefik building scripts related. area/healthcheck : Health-check related. area/logs : Logs related. area/middleware : Middleware related. area/middleware/metrics : Metrics related. (Prometheus, StatsD, ...) area/middleware/tracing : Tracing related. (Jaeger, Zipkin, ...) area/oxy : Oxy related. area/provider : related to all providers. area/provider/boltdb : Boltd DB related. area/provider/consul : Consul related. area/provider/docker : Docker and Swarm related. area/provider/ecs : ECS related. area/provider/etcd : Etcd related. area/provider/eureka : Eureka related. area/provider/file : file provider related. area/provider/k8s : Kubernetes related. area/provider/kv : KV related. area/provider/marathon : Marathon related. area/provider/mesos : Mesos related. area/provider/rancher : Rancher related. area/provider/servicefabric : Azure service fabric related. area/provider/zk : Zoo Keeper related. area/rules : Rules related. area/server : Server related. area/sticky-session : Sticky session related. area/tls : TLS related. area/websocket : WebSocket related. area/webui : Web UI related. Issues Priority \u00b6 priority/P0 : needs hot fix. priority/P1 : need to be fixed in next release. priority/P2 : need to be fixed in the future. priority/P3 : maybe. PR size \u00b6 Automatically set by a bot. size/S : small PR. size/M : medium PR. size/L : Large PR.","title":"Maintainers"},{"location":"contributing/maintainers/#maintainers","text":"","title":"Maintainers"},{"location":"contributing/maintainers/#the-team","text":"Emile Vauge @emilevauge Vincent Demeester @vdemeester Ed Robinson @errm Daniel Tomcej @dtomcej Manuel Zapf @SantoDE Timo Reimann @timoreimann Ludovic Fernandez @ldez Julien Salleyron @juliens Nicolas Mengin @nmengin Marco Jantke @marco-jantke Micha\u00ebl Matur @mmatur G\u00e9rald Cro\u00ebs @geraldcroes Jean-Baptiste Doumenjou @jbdoumenjou Damien Duportal @dduportal","title":"The team"},{"location":"contributing/maintainers/#contributions-daily-meeting","text":"3 Maintainers should attend to a Contributions Daily Meeting where we sort and label new issues ( is:issue label:status/0-needs-triage ), and review every Pull Requests Every pull request should be checked during the Contributions Daily Meeting Even if it\u2019s already assigned Even PR labelled with contributor/waiting-for-corrections or contributor/waiting-for-feedback Issues labeled with priority/P0 and priority/P1 should be assigned. Modifying an issue or a pull request (labels, assignees, milestone) is only possible: During the Contributions Daily Meeting By an assigned maintainer In case of emergency, if a change proposal is approved by 2 other maintainers (on Slack, Discord, etc)","title":"Contributions Daily Meeting"},{"location":"contributing/maintainers/#pr-review-process","text":"The status needs-design-review is only used in complex/heavy/tricky PRs. From 1 to 2 : 1 comment that says \u201cdesign LGTM\u201d (by a senior maintainer). From 2 to 3 : 3 LGTM approvals by any maintainer. If needed, a specific maintainer familiar with a particular domain can be requested for the review. If a PR has been implemented in pair programming, one peer's LGTM goes into the review for free Amending someone else's pull request is authorized only in emergency, if a rebase is needed, or if the initial contributor is silent We use PRM to manage locally pull requests.","title":"PR review process:"},{"location":"contributing/maintainers/#bots","text":"","title":"Bots"},{"location":"contributing/maintainers/#myrmica-lobicornis","text":"Update and Merge Pull Request. The maintainer giving the final LGTM must add the status/3-needs-merge label to trigger the merge bot. By default, a squash-rebase merge will be carried out. To preserve commits, add bot/merge-method-rebase before status/3-needs-merge . The status status/4-merge-in-progress is only used by the bot. If the bot is not able to perform the merge, the label bot/need-human-merge is added. In such a situation, solve the conflicts/CI/... and then remove the label bot/need-human-merge . To prevent the bot from automatically merging a PR, add the label bot/no-merge . The label bot/light-review decreases the number of required LGTM from 3 to 1. This label is used when: Updating the vendors from previously reviewed PRs Merging branches into the master Preparing the release","title":"Myrmica Lobicornis"},{"location":"contributing/maintainers/#myrmica-bibikoffi","text":"closes stale issues [cron] use some criterion as number of days between creation, last update, labels, ...","title":"Myrmica Bibikoffi"},{"location":"contributing/maintainers/#myrmica-aloba","text":"Manage GitHub labels. Add labels on new PR [GitHub WebHook] Add milestone to a new PR based on a branch version (1.4, 1.3, ...) [GitHub WebHook] Add and remove contributor/waiting-for-corrections label when a review request changes [GitHub WebHook] Weekly report of PR status on Slack (CaptainPR) [cron]","title":"Myrmica Aloba"},{"location":"contributing/maintainers/#labels","text":"A maintainer that looks at an issue/PR must define its kind/* , area/* , and status/* .","title":"Labels"},{"location":"contributing/maintainers/#status-workflow","text":"The status/* labels represent the desired state in the workflow. status/0-needs-triage : all the new issues and PRs have this status. [bot only] status/1-needs-design-review : needs a design review. (only for PR) status/2-needs-review : needs a code/documentation review. (only for PR) status/3-needs-merge : ready to merge. (only for PR) status/4-merge-in-progress : merge is in progress. [bot only]","title":"Status - Workflow"},{"location":"contributing/maintainers/#contributor","text":"contributor/need-more-information : we need more information from the contributor in order to analyze a problem. contributor/waiting-for-feedback : we need the contributor to give us feedback. contributor/waiting-for-corrections : we need the contributor to take actions in order to move forward with a PR. (only for PR) [bot, humans] contributor/needs-resolve-conflicts : use it only when there is some conflicts (and an automatic rebase is not possible). (only for PR) [bot, humans]","title":"Contributor"},{"location":"contributing/maintainers/#kind","text":"kind/enhancement : a new or improved feature. kind/question : a question. (only for issue) kind/proposal : a proposal that needs to be discussed. Proposal issues are design proposals Proposal PRs are technical prototypes that need to be refined with multiple contributors. kind/bug/possible : a possible bug that needs analysis before it is confirmed or fixed. (only for issues) kind/bug/confirmed : a confirmed bug (reproducible). (only for issues) kind/bug/fix : a bug fix. (only for PR)","title":"Kind"},{"location":"contributing/maintainers/#resolution","text":"resolution/duplicate : a duplicate issue/PR. resolution/declined : declined (Rule #1 of open-source: no is temporary, yes is forever). WIP : Work In Progress. (only for PR)","title":"Resolution"},{"location":"contributing/maintainers/#platform","text":"platform/windows : Windows related.","title":"Platform"},{"location":"contributing/maintainers/#area","text":"area/acme : ACME related. area/api : Traefik API related. area/authentication : Authentication related. area/cluster : Traefik clustering related. area/documentation : Documentation related. area/infrastructure : CI or Traefik building scripts related. area/healthcheck : Health-check related. area/logs : Logs related. area/middleware : Middleware related. area/middleware/metrics : Metrics related. (Prometheus, StatsD, ...) area/middleware/tracing : Tracing related. (Jaeger, Zipkin, ...) area/oxy : Oxy related. area/provider : related to all providers. area/provider/boltdb : Boltd DB related. area/provider/consul : Consul related. area/provider/docker : Docker and Swarm related. area/provider/ecs : ECS related. area/provider/etcd : Etcd related. area/provider/eureka : Eureka related. area/provider/file : file provider related. area/provider/k8s : Kubernetes related. area/provider/kv : KV related. area/provider/marathon : Marathon related. area/provider/mesos : Mesos related. area/provider/rancher : Rancher related. area/provider/servicefabric : Azure service fabric related. area/provider/zk : Zoo Keeper related. area/rules : Rules related. area/server : Server related. area/sticky-session : Sticky session related. area/tls : TLS related. area/websocket : WebSocket related. area/webui : Web UI related.","title":"Area"},{"location":"contributing/maintainers/#issues-priority","text":"priority/P0 : needs hot fix. priority/P1 : need to be fixed in next release. priority/P2 : need to be fixed in the future. priority/P3 : maybe.","title":"Issues Priority"},{"location":"contributing/maintainers/#pr-size","text":"Automatically set by a bot. size/S : small PR. size/M : medium PR. size/L : Large PR.","title":"PR size"},{"location":"contributing/submitting-issues/","text":"Submitting Issues \u00b6 Help Us Help You! We use the GitHub issue tracker to keep track of issues in Traefik. The process of sorting and checking the issues is a daunting task, and requires a lot of work (more than an hour a day ... just for sorting). To save us some time and get quicker feedback, be sure to follow the guide lines below. Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the Traefik community Slack channel: Stack Overflow (using the traefik tag) Issue Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the issue template as much as possible. Explain us in which conditions you encountered the issue, what is your context. Remain as clear and concise as possible Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). Feature Request \u00b6 Traefik is an open-source project and aims to be the best edge router possible. Remember when asking for new features that these must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do you best to explain what you're looking for, and why it would improve Traefik for everyone. International English \u00b6 Every maintainer / Traefik user is not a native English speaker, so if you feel sometimes that some messages sound rude, remember that it probably is a language barrier problem from someone willing to help you.","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#submitting-issues","text":"Help Us Help You! We use the GitHub issue tracker to keep track of issues in Traefik. The process of sorting and checking the issues is a daunting task, and requires a lot of work (more than an hour a day ... just for sorting). To save us some time and get quicker feedback, be sure to follow the guide lines below. Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the Traefik community Slack channel: Stack Overflow (using the traefik tag)","title":"Submitting Issues"},{"location":"contributing/submitting-issues/#issue-title","text":"The title must be short and descriptive. (~60 characters)","title":"Issue Title"},{"location":"contributing/submitting-issues/#description","text":"Follow the issue template as much as possible. Explain us in which conditions you encountered the issue, what is your context. Remain as clear and concise as possible Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-issues/#feature-request","text":"Traefik is an open-source project and aims to be the best edge router possible. Remember when asking for new features that these must be useful to the majority (and not only useful in edge case scenarios, or hack-like setups). Do you best to explain what you're looking for, and why it would improve Traefik for everyone.","title":"Feature Request"},{"location":"contributing/submitting-issues/#international-english","text":"Every maintainer / Traefik user is not a native English speaker, so if you feel sometimes that some messages sound rude, remember that it probably is a language barrier problem from someone willing to help you.","title":"International English"},{"location":"contributing/submitting-pull-requests/","text":"Submitting Pull Requests \u00b6 A Quick Guide for Efficient Contributions So you've decide to improve Traefik? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go though the classic pitfalls to make sure everything is right. Title \u00b6 The title must be short and descriptive. (~60 characters) Description \u00b6 Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ). PR Content \u00b6 Make it small. One feature per Pull Request. Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (and don't amend/squash existing ones unless the PR is trivial). third-party dependencies If a PR involves changes to third-party dependencies, the commits pertaining to the vendor folder and the manifest/lock file(s) should be committed separated. 10 Tips for Better Pull Requests We enjoyed this article, maybe you will too! 10 tips for better pull requests .","title":"Submitting PRs"},{"location":"contributing/submitting-pull-requests/#submitting-pull-requests","text":"A Quick Guide for Efficient Contributions So you've decide to improve Traefik? Thank You! Now the last step is to submit your Pull Request in a way that makes sure it gets the attention it deserves. Let's go though the classic pitfalls to make sure everything is right.","title":"Submitting Pull Requests"},{"location":"contributing/submitting-pull-requests/#title","text":"The title must be short and descriptive. (~60 characters)","title":"Title"},{"location":"contributing/submitting-pull-requests/#description","text":"Follow the pull request template as much as possible. Explain the conditions which led you to write this PR: give us context. The context should lead to something, an idea or a problem that you\u2019re facing. Remain clear and concise. Take time to polish the format of your message so we'll enjoy reading it and working on it. Help the readers focus on what matters, and help them understand the structure of your message (see the Github Markdown Syntax ).","title":"Description"},{"location":"contributing/submitting-pull-requests/#pr-content","text":"Make it small. One feature per Pull Request. Write useful descriptions and titles. Avoid re-formatting code that is not on the path of your PR. Make sure the code builds . Make sure all tests pass . Add tests. Address review comments in terms of additional commits (and don't amend/squash existing ones unless the PR is trivial). third-party dependencies If a PR involves changes to third-party dependencies, the commits pertaining to the vendor folder and the manifest/lock file(s) should be committed separated. 10 Tips for Better Pull Requests We enjoyed this article, maybe you will too! 10 tips for better pull requests .","title":"PR Content"},{"location":"contributing/thank-you/","text":"Thank You! \u00b6 You Made It Traefik truly is an open-source project , and wouldn't have become what it is today without the help of our many contributors (at the time of writing this), not accounting for people having helped with issues, tests, comments, articles, ... or just enjoying it and letting others know. So once again, thank you for your invaluable help on making Traefik such a good product.","title":"Thank You!"},{"location":"contributing/thank-you/#thank-you","text":"You Made It Traefik truly is an open-source project , and wouldn't have become what it is today without the help of our many contributors (at the time of writing this), not accounting for people having helped with issues, tests, comments, articles, ... or just enjoying it and letting others know. So once again, thank you for your invaluable help on making Traefik such a good product.","title":"Thank You!"},{"location":"getting-started/concepts/","text":"Concepts \u00b6 Everything You Need to Know Edge Router \u00b6 Traefik is an Edge Router , it means that it's the door to your platform, and that it intercepts and routes every incoming request: it knows all the logic and every rule that determine which services handle which requests (based on the path , the host , headers , and so on ...). Auto Service Discovery \u00b6 Where traditionally edge routers (or reverse proxies) need a configuration file that contains every possible route to your services, Traefik gets them from the services themselves. Deploying your services, you attach information that tell Traefik the characteristics of the requests the services can handle. It means that when a service is deployed, Traefik detects it immediately and updates the routing rules in real time. The opposite is true: when you remove a service from your infrastructure, the route will disapear accordingly. You no longer need to create and synchronize configuration files cluttered with IP addresses or other rules. Many different rules In the example above, we used the request path to determine which service was in charge, but of course you can use many other different rules . Updating the requests In the middleware section, you can learn about how to update the requests before forwarding them to the services. How does Traefik discover the services? Traefik is able to use your cluster API to discover the services and read the attached information. In Traefik, these connectors are called providers because they provide the configuration to Traefik. To learn more about them, read the provider overview section.","title":"Concepts"},{"location":"getting-started/concepts/#concepts","text":"Everything You Need to Know","title":"Concepts"},{"location":"getting-started/concepts/#edge-router","text":"Traefik is an Edge Router , it means that it's the door to your platform, and that it intercepts and routes every incoming request: it knows all the logic and every rule that determine which services handle which requests (based on the path , the host , headers , and so on ...).","title":"Edge Router"},{"location":"getting-started/concepts/#auto-service-discovery","text":"Where traditionally edge routers (or reverse proxies) need a configuration file that contains every possible route to your services, Traefik gets them from the services themselves. Deploying your services, you attach information that tell Traefik the characteristics of the requests the services can handle. It means that when a service is deployed, Traefik detects it immediately and updates the routing rules in real time. The opposite is true: when you remove a service from your infrastructure, the route will disapear accordingly. You no longer need to create and synchronize configuration files cluttered with IP addresses or other rules. Many different rules In the example above, we used the request path to determine which service was in charge, but of course you can use many other different rules . Updating the requests In the middleware section, you can learn about how to update the requests before forwarding them to the services. How does Traefik discover the services? Traefik is able to use your cluster API to discover the services and read the attached information. In Traefik, these connectors are called providers because they provide the configuration to Traefik. To learn more about them, read the provider overview section.","title":"Auto Service Discovery"},{"location":"getting-started/configuration-overview/","text":"Configuration Introduction \u00b6 How the Magic Happens Configuration in Traefik can refer to two different things: The fully dynamic routing configuration (referred to as the dynamic configuration ) The startup configuration (referred to as the static configuration ) Elements in the static configuration set up connections to providers and define the entrypoints Traefik will listen to (these elements don't change often). The dynamic configuration contains everything that defines how the requests are handled by your system. This configuration can change and is seamlessly hot-reloaded, without any request interuption or connection loss. Incompatible Configuration Please be aware that the old configurations for Traefik v1.X are NOT compatible with the v2.X config as of now. If you're testing out v2, please ensure you are using a v2 configuration. The Dynamic Configuration \u00b6 Traefik gets its dynamic configuration from providers : wether an orchestrator, a service registry, or a plain old configuration file. Since this configuration is specific to your infrastructure choices, we invite you to refer to the dedicated section of this documentation . Note In the Quick Start example , the dynamic configuration comes from docker in the form of labels attached to your containers. Note HTTPS Certificates also belong to the dynamic configuration. You can add / update / remove them without restarting your Traefik instance. The Static Configuration \u00b6 There are three different locations where you can define static configuration options in Traefik: In a key-value store In the command-line arguments In a configuration file If you don't provide a value for a given option, default values apply. Precedence Order The following precedence order applies for configuration options: key-value > command-line > configuration file. It means that arguments override configuration file, and key-value store overrides arguments. Default Values Some root options are enablers: they set default values for all their children. For example, the --providers.docker option enables the docker provider. Once positioned, this option sets (and resets) all the default values under the root providers.docker . If you define child options using a lesser precedence configuration source, they will be overwritten by the default values. Configuration File \u00b6 At startup, Traefik searches for a file named traefik.toml in /etc/traefik/ , $HOME/.traefik/ , and . ( the working directory ). You can override this using the configFile argument. traefik --configFile=foo/bar/myconfigfile.toml Arguments \u00b6 Use traefik --help to get the list of the available arguments. Key-Value Stores \u00b6 Traefik supports several Key-value stores: Consul etcd ZooKeeper boltdb Available Configuration Options \u00b6 All the configuration options are documented in their related section. You can browse the available features in the menu, the providers , or the routing section to see them in action.","title":"Configuration Introduction"},{"location":"getting-started/configuration-overview/#configuration-introduction","text":"How the Magic Happens Configuration in Traefik can refer to two different things: The fully dynamic routing configuration (referred to as the dynamic configuration ) The startup configuration (referred to as the static configuration ) Elements in the static configuration set up connections to providers and define the entrypoints Traefik will listen to (these elements don't change often). The dynamic configuration contains everything that defines how the requests are handled by your system. This configuration can change and is seamlessly hot-reloaded, without any request interuption or connection loss. Incompatible Configuration Please be aware that the old configurations for Traefik v1.X are NOT compatible with the v2.X config as of now. If you're testing out v2, please ensure you are using a v2 configuration.","title":"Configuration Introduction"},{"location":"getting-started/configuration-overview/#the-dynamic-configuration","text":"Traefik gets its dynamic configuration from providers : wether an orchestrator, a service registry, or a plain old configuration file. Since this configuration is specific to your infrastructure choices, we invite you to refer to the dedicated section of this documentation . Note In the Quick Start example , the dynamic configuration comes from docker in the form of labels attached to your containers. Note HTTPS Certificates also belong to the dynamic configuration. You can add / update / remove them without restarting your Traefik instance.","title":"The Dynamic Configuration"},{"location":"getting-started/configuration-overview/#the-static-configuration","text":"There are three different locations where you can define static configuration options in Traefik: In a key-value store In the command-line arguments In a configuration file If you don't provide a value for a given option, default values apply. Precedence Order The following precedence order applies for configuration options: key-value > command-line > configuration file. It means that arguments override configuration file, and key-value store overrides arguments. Default Values Some root options are enablers: they set default values for all their children. For example, the --providers.docker option enables the docker provider. Once positioned, this option sets (and resets) all the default values under the root providers.docker . If you define child options using a lesser precedence configuration source, they will be overwritten by the default values.","title":"The Static Configuration"},{"location":"getting-started/configuration-overview/#configuration-file","text":"At startup, Traefik searches for a file named traefik.toml in /etc/traefik/ , $HOME/.traefik/ , and . ( the working directory ). You can override this using the configFile argument. traefik --configFile=foo/bar/myconfigfile.toml","title":"Configuration File"},{"location":"getting-started/configuration-overview/#arguments","text":"Use traefik --help to get the list of the available arguments.","title":"Arguments"},{"location":"getting-started/configuration-overview/#key-value-stores","text":"Traefik supports several Key-value stores: Consul etcd ZooKeeper boltdb","title":"Key-Value Stores"},{"location":"getting-started/configuration-overview/#available-configuration-options","text":"All the configuration options are documented in their related section. You can browse the available features in the menu, the providers , or the routing section to see them in action.","title":"Available Configuration Options"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 A Simple Use Case Using Docker Launch Traefik With the Docker Provider \u00b6 Create a docker-compose.yml file where you will define a reverse-proxy service that uses the official Traefik image: version: '3' services: reverse-proxy: image: traefik:v2.0 # The official v2.0 Traefik docker image command: --api --providers.docker # Enables the web UI and tells Traefik to listen to docker ports: - \"80:80\" # The HTTP port - \"8080:8080\" # The Web UI (enabled by --api) volumes: - /var/run/docker.sock:/var/run/docker.sock # So that Traefik can listen to the Docker events That's it. Now you can launch Traefik! Start your reverse-proxy with the following command: docker-compose up -d reverse-proxy You can open a browser and go to http://localhost:8080/api/rawdata to see Traefik's API rawdata (we'll go back there once we have launched a service in step 2). Traefik Detects New Services and Creates the Route for You \u00b6 Now that we have a Traefik instance up and running, we will deploy new services. Edit your docker-compose.yml file and add the following at the end of your file. # ... whoami: image: containous/whoami # A container that exposes an API to show its IP address labels: - \"traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)\" The above defines whoami : a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on). Start the whoami service with the following command: docker-compose up -d whoami Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new container and updated its own configuration. When Traefik detects new services, it creates the corresponding routes so you can call them ... let's see! (Here, we're using curl) curl -H Host:whoami.docker.localhost http://127.0.0.1 Shows the following output: Hostname: a656c8ddca6c IP: 172.27.0.3 #... More Instances? Traefik Load Balances Them \u00b6 Run more instances of your whoami service with the following command: docker-compose up -d --scale whoami=2 Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new instance of the container. Finally, see that Traefik load-balances between the two instances of your services by running twice the following command: curl -H Host:whoami.docker.localhost http://127.0.0.1 The output will show alternatively one of the followings: Hostname: a656c8ddca6c IP: 172.27.0.3 #... Hostname: s458f154e1f1 IP: 172.27.0.4 # ... Where to Go Next? Now that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it is time to dive into the documentation and let Traefik work for you!","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"A Simple Use Case Using Docker","title":"Quick Start"},{"location":"getting-started/quick-start/#launch-traefik-with-the-docker-provider","text":"Create a docker-compose.yml file where you will define a reverse-proxy service that uses the official Traefik image: version: '3' services: reverse-proxy: image: traefik:v2.0 # The official v2.0 Traefik docker image command: --api --providers.docker # Enables the web UI and tells Traefik to listen to docker ports: - \"80:80\" # The HTTP port - \"8080:8080\" # The Web UI (enabled by --api) volumes: - /var/run/docker.sock:/var/run/docker.sock # So that Traefik can listen to the Docker events That's it. Now you can launch Traefik! Start your reverse-proxy with the following command: docker-compose up -d reverse-proxy You can open a browser and go to http://localhost:8080/api/rawdata to see Traefik's API rawdata (we'll go back there once we have launched a service in step 2).","title":"Launch Traefik With the Docker Provider"},{"location":"getting-started/quick-start/#traefik-detects-new-services-and-creates-the-route-for-you","text":"Now that we have a Traefik instance up and running, we will deploy new services. Edit your docker-compose.yml file and add the following at the end of your file. # ... whoami: image: containous/whoami # A container that exposes an API to show its IP address labels: - \"traefik.http.routers.whoami.rule=Host(`whoami.docker.localhost`)\" The above defines whoami : a simple web service that outputs information about the machine it is deployed on (its IP address, host, and so on). Start the whoami service with the following command: docker-compose up -d whoami Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new container and updated its own configuration. When Traefik detects new services, it creates the corresponding routes so you can call them ... let's see! (Here, we're using curl) curl -H Host:whoami.docker.localhost http://127.0.0.1 Shows the following output: Hostname: a656c8ddca6c IP: 172.27.0.3 #...","title":"Traefik Detects New Services and Creates the Route for You"},{"location":"getting-started/quick-start/#more-instances-traefik-load-balances-them","text":"Run more instances of your whoami service with the following command: docker-compose up -d --scale whoami=2 Go back to your browser ( http://localhost:8080/api/rawdata ) and see that Traefik has automatically detected the new instance of the container. Finally, see that Traefik load-balances between the two instances of your services by running twice the following command: curl -H Host:whoami.docker.localhost http://127.0.0.1 The output will show alternatively one of the followings: Hostname: a656c8ddca6c IP: 172.27.0.3 #... Hostname: s458f154e1f1 IP: 172.27.0.4 # ... Where to Go Next? Now that you have a basic understanding of how Traefik can automatically create the routes to your services and load balance them, it is time to dive into the documentation and let Traefik work for you!","title":"More Instances? Traefik Load Balances Them"},{"location":"https-tls/acme/","text":"ACME \u00b6 Automatic HTTPS You can configure Traefik to use an ACME provider (like Let's Encrypt) for automatic certificate generation. Let's Encrypt and Rate Limiting Note that Let's Encrypt API has rate limiting . Configuration Examples \u00b6 Enabling ACME [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.http-tls] address = \":443\" [acme] # every router with TLS enabled will now be able to use ACME for its certificates email = \"your-email@your-domain.org\" storage = \"acme.json\" onHostRule = true # dynamic generation based on the Host() & HostSNI() matchers [acme.httpChallenge] entryPoint = \"web\" # used during the challenge Configuring Wildcard Certificates [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.http-tls] address = \":443\" [acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [acme.dnsChallenge] provider = \"xxx\" [[acme.domains]] main = \"*.mydomain.com\" sans = [\"mydomain.com\"] Configuration Reference There are many available options for ACME. For a quick glance at what's possible, browse the configuration reference . The Different ACME Challenges \u00b6 tlsChallenge \u00b6 Use the TLS-ALPN-01 challenge to generate and renew ACME certificates by provisioning a TLS certificate. As described on the Let's Encrypt community forum , when using the TLS-ALPN-01 challenge, Traefik must be reachable by Let's Encrypt through port 443. Configuring the tlsChallenge [acme] [acme.tlsChallenge] httpChallenge \u00b6 Use the HTTP-01 challenge to generate and renew ACME certificates by provisioning an HTTP resource under a well-known URI. As described on the Let's Encrypt community forum , when using the HTTP-01 challenge, acme.httpChallenge.entryPoint must be reachable by Let's Encrypt through port 80. Using an EntryPoint Called http for the httpChallenge [acme] # ... [acme.httpChallenge] entryPoint = \"http\" Note Redirection is fully compatible with the HTTP-01 challenge. dnsChallenge \u00b6 Use the DNS-01 challenge to generate and renew ACME certificates by provisioning a DNS record. Configuring a dnsChallenge with the DigitalOcean Provider [acme] # ... [acme.dnsChallenge] provider = \"digitalocean\" delayBeforeCheck = 0 # ... Important A provider is mandatory. providers \u00b6 Here is a list of supported providers , that can automate the DNS verification, along with the required environment variables and their wildcard & root domain support . Do not hesitate to complete it. Provider Name Provider Code Environment Variables Wildcard & Root Domain Support ACME DNS acme-dns ACME_DNS_API_BASE , ACME_DNS_STORAGE_PATH Not tested yet Alibaba Cloud alidns ALICLOUD_ACCESS_KEY , ALICLOUD_SECRET_KEY , ALICLOUD_REGION_ID Not tested yet Auroradns auroradns AURORA_USER_ID , AURORA_KEY , AURORA_ENDPOINT Not tested yet Azure azure AZURE_CLIENT_ID , AZURE_CLIENT_SECRET , AZURE_SUBSCRIPTION_ID , AZURE_TENANT_ID , AZURE_RESOURCE_GROUP , [AZURE_METADATA_ENDPOINT] Not tested yet Blue Cat bluecat BLUECAT_SERVER_URL , BLUECAT_USER_NAME , BLUECAT_PASSWORD , BLUECAT_CONFIG_NAME , BLUECAT_DNS_VIEW Not tested yet ClouDNS cloudns CLOUDNS_AUTH_ID , CLOUDNS_AUTH_PASSWORD YES Cloudflare cloudflare CF_API_EMAIL , CF_API_KEY - The Global API Key needs to be used, not the Origin CA Key YES CloudXNS cloudxns CLOUDXNS_API_KEY , CLOUDXNS_SECRET_KEY Not tested yet ConoHa conoha CONOHA_TENANT_ID , CONOHA_API_USERNAME , CONOHA_API_PASSWORD YES DigitalOcean digitalocean DO_AUTH_TOKEN YES DNSimple dnsimple DNSIMPLE_OAUTH_TOKEN , DNSIMPLE_BASE_URL YES DNS Made Easy dnsmadeeasy DNSMADEEASY_API_KEY , DNSMADEEASY_API_SECRET , DNSMADEEASY_SANDBOX Not tested yet DNSPod dnspod DNSPOD_API_KEY Not tested yet DreamHost dreamhost DREAMHOST_API_KEY YES Duck DNS duckdns DUCKDNS_TOKEN YES Dyn dyn DYN_CUSTOMER_NAME , DYN_USER_NAME , DYN_PASSWORD Not tested yet External Program exec EXEC_PATH YES Exoscale exoscale EXOSCALE_API_KEY , EXOSCALE_API_SECRET , EXOSCALE_ENDPOINT YES Fast DNS fastdns AKAMAI_CLIENT_TOKEN , AKAMAI_CLIENT_SECRET , AKAMAI_ACCESS_TOKEN YES Gandi gandi GANDI_API_KEY Not tested yet Gandi v5 gandiv5 GANDIV5_API_KEY YES Glesys glesys GLESYS_API_USER , GLESYS_API_KEY , GLESYS_DOMAIN Not tested yet GoDaddy godaddy GODADDY_API_KEY , GODADDY_API_SECRET Not tested yet Google Cloud DNS gcloud GCE_PROJECT , Application Default Credentials 2 3 , [ GCE_SERVICE_ACCOUNT_FILE ] YES hosting.de hostingde HOSTINGDE_API_KEY , HOSTINGDE_ZONE_NAME Not tested yet HTTP request httpreq HTTPREQ_ENDPOINT , HTTPREQ_MODE , HTTPREQ_USERNAME , HTTPREQ_PASSWORD 1 YES IIJ iij IIJ_API_ACCESS_KEY , IIJ_API_SECRET_KEY , IIJ_DO_SERVICE_CODE Not tested yet INWX inwx INWX_USERNAME , INWX_PASSWORD YES Lightsail lightsail AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , DNS_ZONE Not tested yet Linode linode LINODE_API_KEY Not tested yet Linode v4 linodev4 LINODE_TOKEN Not tested yet manual - none, but you need to run Traefik interactively 4 , turn on acmeLogging to see instructions and press Enter . YES MyDNS.jp mydnsjp MYDNSJP_MASTER_ID , MYDNSJP_PASSWORD YES Namecheap namecheap NAMECHEAP_API_USER , NAMECHEAP_API_KEY YES name.com namedotcom NAMECOM_USERNAME , NAMECOM_API_TOKEN , NAMECOM_SERVER Not tested yet Netcup netcup NETCUP_CUSTOMER_NUMBER , NETCUP_API_KEY , NETCUP_API_PASSWORD Not tested yet NIFCloud nifcloud NIFCLOUD_ACCESS_KEY_ID , NIFCLOUD_SECRET_ACCESS_KEY Not tested yet Ns1 ns1 NS1_API_KEY Not tested yet Open Telekom Cloud otc OTC_DOMAIN_NAME , OTC_USER_NAME , OTC_PASSWORD , OTC_PROJECT_NAME , OTC_IDENTITY_ENDPOINT Not tested yet OVH ovh OVH_ENDPOINT , OVH_APPLICATION_KEY , OVH_APPLICATION_SECRET , OVH_CONSUMER_KEY YES Openstack Designate designate OS_AUTH_URL , OS_USERNAME , OS_PASSWORD , OS_TENANT_NAME , OS_REGION_NAME YES Oracle Cloud oraclecloud OCI_COMPARTMENT_OCID , OCI_PRIVKEY_FILE , OCI_PRIVKEY_PASS , OCI_PUBKEY_FINGERPRINT , OCI_REGION , OCI_TENANCY_OCID , OCI_USER_OCID YES PowerDNS pdns PDNS_API_KEY , PDNS_API_URL Not tested yet Rackspace rackspace RACKSPACE_USER , RACKSPACE_API_KEY Not tested yet RFC2136 rfc2136 RFC2136_TSIG_KEY , RFC2136_TSIG_SECRET , RFC2136_TSIG_ALGORITHM , RFC2136_NAMESERVER Not tested yet Route 53 route53 AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , [AWS_REGION] , [AWS_HOSTED_ZONE_ID] or a configured user/instance IAM profile. YES Sakura Cloud sakuracloud SAKURACLOUD_ACCESS_TOKEN , SAKURACLOUD_ACCESS_TOKEN_SECRET Not tested yet Selectel selectel SELECTEL_API_TOKEN YES Stackpath stackpath STACKPATH_CLIENT_ID , STACKPATH_CLIENT_SECRET , STACKPATH_STACK_ID Not tested yet TransIP transip TRANSIP_ACCOUNT_NAME , TRANSIP_PRIVATE_KEY_PATH YES VegaDNS vegadns SECRET_VEGADNS_KEY , SECRET_VEGADNS_SECRET , VEGADNS_URL Not tested yet Vscale vscale VSCALE_API_TOKEN YES VULTR vultr VULTR_API_KEY Not tested yet Zone.ee zoneee ZONEEE_API_USER , ZONEEE_API_KEY YES delayBeforeCheck By default, the provider verifies the TXT record before letting ACME verify. You can delay this operation by specifying a delay (in seconds) with delayBeforeCheck (value must be greater than zero). This option is useful when internal networks block external DNS queries. resolvers \u00b6 Use custom DNS servers to resolve the FQDN authority. [acme] # ... [acme.dnsChallenge] # ... resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] Wildcard Domains \u00b6 ACME V2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge . [acme] # ... [[acme.domains]] main = \"*.local1.com\" sans = [\"local1.com\"] # ... Double Wildcard Certificates It is not possible to request a double wildcard certificate for a domain (for example *.*.local.com ). Due to an ACME limitation it is not possible to define wildcards in SANs (alternative domains). Thus, the wildcard domain has to be defined as a main domain. Most likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2 DNS-01 challenges are executed. In this case the generated DNS TXT record for both domains is the same. Even though this behavior is DNS RFC compliant, it can lead to problems as all DNS providers keep DNS records cached for a given time (TTL) and this TTL can be greater than the challenge timeout making the DNS-01 challenge fail. The Traefik ACME client library LEGO supports some but not all DNS providers to work around this issue. The Supported provider table indicates if they allow generating certificates for a wildcard domain and its root domain. Known Domains, SANs \u00b6 You can set SANs (alternative domains) for each main domain. Every domain must have A/AAAA records pointing to Traefik. Each domain & SAN will lead to a certificate request. [acme] # ... [[acme.domains]] main = \"local1.com\" sans = [\"test1.local1.com\", \"test2.local1.com\"] [[acme.domains]] main = \"local2.com\" [[acme.domains]] main = \"*.local3.com\" sans = [\"local3.com\", \"test1.test1.local3.com\"] # ... Important The certificates for the domains listed in acme.domains are negotiated at Traefik startup only. Note Wildcard certificates can only be verified through a DNS-01 challenge. caServer \u00b6 Using the Let's Encrypt staging server [acme] # ... caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # ... onHostRule \u00b6 Enable certificate generation on routers Host & HostSNI rules. This will request a certificate from Let's Encrypt for each router with a Host rule. [acme] # ... onHostRule = true # ... Multiple Hosts in a Rule The rule Host(test1.traefik.io,test2.traefik.io) will request a certificate with the main domain test1.traefik.io and SAN test2.traefik.io . Warning onHostRule option can not be used to generate wildcard certificates. Refer to wildcard generation for further information. storage \u00b6 The storage option sets the location where your ACME certificates are saved to. [acme] # ... storage = \"acme.json\" # ... The value can refer to two kinds of storage: a JSON file a KV store entry In a File \u00b6 ACME certificates can be stored in a JSON file that needs to have a 600 file mode . In Docker you can mount either the JSON file, or the folder containing it: docker run -v \"/my/host/acme.json:acme.json\" traefik docker run -v \"/my/host/acme:/etc/traefik/acme\" traefik Warning For concurrency reason, this file cannot be shared across multiple instances of Traefik. Use a key value store entry instead. In a a Key Value Store Entry \u00b6 ACME certificates can be stored in a key-value store entry. storage = \"traefik/acme/account\" Storage Size Because key-value stores have limited entry size, the certificates list is compressed before it is saved. For example, it is possible to store up to approximately 100 ACME certificates in Consul. Fallbacks \u00b6 If Let's Encrypt is not reachable, the following certificates will apply: Previously generated ACME certificates (before downtime) Expired ACME certificates Provided certificates Note For new (sub)domains which need Let's Encrypt authentication, the default Traefik certificate will be used until Traefik is restarted. more information about the HTTP message format can be found here \u21a9 providing_credentials_to_your_application \u21a9 google/default.go \u21a9 docker stack remark: there is no way to support terminal attached to container when deploying with docker stack , so you might need to run container with docker run -it to generate certificates using manual provider. \u21a9","title":"ACME"},{"location":"https-tls/acme/#acme","text":"Automatic HTTPS You can configure Traefik to use an ACME provider (like Let's Encrypt) for automatic certificate generation. Let's Encrypt and Rate Limiting Note that Let's Encrypt API has rate limiting .","title":"ACME"},{"location":"https-tls/acme/#configuration-examples","text":"Enabling ACME [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.http-tls] address = \":443\" [acme] # every router with TLS enabled will now be able to use ACME for its certificates email = \"your-email@your-domain.org\" storage = \"acme.json\" onHostRule = true # dynamic generation based on the Host() & HostSNI() matchers [acme.httpChallenge] entryPoint = \"web\" # used during the challenge Configuring Wildcard Certificates [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.http-tls] address = \":443\" [acme] email = \"your-email@your-domain.org\" storage = \"acme.json\" [acme.dnsChallenge] provider = \"xxx\" [[acme.domains]] main = \"*.mydomain.com\" sans = [\"mydomain.com\"] Configuration Reference There are many available options for ACME. For a quick glance at what's possible, browse the configuration reference .","title":"Configuration Examples"},{"location":"https-tls/acme/#the-different-acme-challenges","text":"","title":"The Different ACME Challenges"},{"location":"https-tls/acme/#tlschallenge","text":"Use the TLS-ALPN-01 challenge to generate and renew ACME certificates by provisioning a TLS certificate. As described on the Let's Encrypt community forum , when using the TLS-ALPN-01 challenge, Traefik must be reachable by Let's Encrypt through port 443. Configuring the tlsChallenge [acme] [acme.tlsChallenge]","title":"tlsChallenge"},{"location":"https-tls/acme/#httpchallenge","text":"Use the HTTP-01 challenge to generate and renew ACME certificates by provisioning an HTTP resource under a well-known URI. As described on the Let's Encrypt community forum , when using the HTTP-01 challenge, acme.httpChallenge.entryPoint must be reachable by Let's Encrypt through port 80. Using an EntryPoint Called http for the httpChallenge [acme] # ... [acme.httpChallenge] entryPoint = \"http\" Note Redirection is fully compatible with the HTTP-01 challenge.","title":"httpChallenge"},{"location":"https-tls/acme/#dnschallenge","text":"Use the DNS-01 challenge to generate and renew ACME certificates by provisioning a DNS record. Configuring a dnsChallenge with the DigitalOcean Provider [acme] # ... [acme.dnsChallenge] provider = \"digitalocean\" delayBeforeCheck = 0 # ... Important A provider is mandatory.","title":"dnsChallenge"},{"location":"https-tls/acme/#providers","text":"Here is a list of supported providers , that can automate the DNS verification, along with the required environment variables and their wildcard & root domain support . Do not hesitate to complete it. Provider Name Provider Code Environment Variables Wildcard & Root Domain Support ACME DNS acme-dns ACME_DNS_API_BASE , ACME_DNS_STORAGE_PATH Not tested yet Alibaba Cloud alidns ALICLOUD_ACCESS_KEY , ALICLOUD_SECRET_KEY , ALICLOUD_REGION_ID Not tested yet Auroradns auroradns AURORA_USER_ID , AURORA_KEY , AURORA_ENDPOINT Not tested yet Azure azure AZURE_CLIENT_ID , AZURE_CLIENT_SECRET , AZURE_SUBSCRIPTION_ID , AZURE_TENANT_ID , AZURE_RESOURCE_GROUP , [AZURE_METADATA_ENDPOINT] Not tested yet Blue Cat bluecat BLUECAT_SERVER_URL , BLUECAT_USER_NAME , BLUECAT_PASSWORD , BLUECAT_CONFIG_NAME , BLUECAT_DNS_VIEW Not tested yet ClouDNS cloudns CLOUDNS_AUTH_ID , CLOUDNS_AUTH_PASSWORD YES Cloudflare cloudflare CF_API_EMAIL , CF_API_KEY - The Global API Key needs to be used, not the Origin CA Key YES CloudXNS cloudxns CLOUDXNS_API_KEY , CLOUDXNS_SECRET_KEY Not tested yet ConoHa conoha CONOHA_TENANT_ID , CONOHA_API_USERNAME , CONOHA_API_PASSWORD YES DigitalOcean digitalocean DO_AUTH_TOKEN YES DNSimple dnsimple DNSIMPLE_OAUTH_TOKEN , DNSIMPLE_BASE_URL YES DNS Made Easy dnsmadeeasy DNSMADEEASY_API_KEY , DNSMADEEASY_API_SECRET , DNSMADEEASY_SANDBOX Not tested yet DNSPod dnspod DNSPOD_API_KEY Not tested yet DreamHost dreamhost DREAMHOST_API_KEY YES Duck DNS duckdns DUCKDNS_TOKEN YES Dyn dyn DYN_CUSTOMER_NAME , DYN_USER_NAME , DYN_PASSWORD Not tested yet External Program exec EXEC_PATH YES Exoscale exoscale EXOSCALE_API_KEY , EXOSCALE_API_SECRET , EXOSCALE_ENDPOINT YES Fast DNS fastdns AKAMAI_CLIENT_TOKEN , AKAMAI_CLIENT_SECRET , AKAMAI_ACCESS_TOKEN YES Gandi gandi GANDI_API_KEY Not tested yet Gandi v5 gandiv5 GANDIV5_API_KEY YES Glesys glesys GLESYS_API_USER , GLESYS_API_KEY , GLESYS_DOMAIN Not tested yet GoDaddy godaddy GODADDY_API_KEY , GODADDY_API_SECRET Not tested yet Google Cloud DNS gcloud GCE_PROJECT , Application Default Credentials 2 3 , [ GCE_SERVICE_ACCOUNT_FILE ] YES hosting.de hostingde HOSTINGDE_API_KEY , HOSTINGDE_ZONE_NAME Not tested yet HTTP request httpreq HTTPREQ_ENDPOINT , HTTPREQ_MODE , HTTPREQ_USERNAME , HTTPREQ_PASSWORD 1 YES IIJ iij IIJ_API_ACCESS_KEY , IIJ_API_SECRET_KEY , IIJ_DO_SERVICE_CODE Not tested yet INWX inwx INWX_USERNAME , INWX_PASSWORD YES Lightsail lightsail AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , DNS_ZONE Not tested yet Linode linode LINODE_API_KEY Not tested yet Linode v4 linodev4 LINODE_TOKEN Not tested yet manual - none, but you need to run Traefik interactively 4 , turn on acmeLogging to see instructions and press Enter . YES MyDNS.jp mydnsjp MYDNSJP_MASTER_ID , MYDNSJP_PASSWORD YES Namecheap namecheap NAMECHEAP_API_USER , NAMECHEAP_API_KEY YES name.com namedotcom NAMECOM_USERNAME , NAMECOM_API_TOKEN , NAMECOM_SERVER Not tested yet Netcup netcup NETCUP_CUSTOMER_NUMBER , NETCUP_API_KEY , NETCUP_API_PASSWORD Not tested yet NIFCloud nifcloud NIFCLOUD_ACCESS_KEY_ID , NIFCLOUD_SECRET_ACCESS_KEY Not tested yet Ns1 ns1 NS1_API_KEY Not tested yet Open Telekom Cloud otc OTC_DOMAIN_NAME , OTC_USER_NAME , OTC_PASSWORD , OTC_PROJECT_NAME , OTC_IDENTITY_ENDPOINT Not tested yet OVH ovh OVH_ENDPOINT , OVH_APPLICATION_KEY , OVH_APPLICATION_SECRET , OVH_CONSUMER_KEY YES Openstack Designate designate OS_AUTH_URL , OS_USERNAME , OS_PASSWORD , OS_TENANT_NAME , OS_REGION_NAME YES Oracle Cloud oraclecloud OCI_COMPARTMENT_OCID , OCI_PRIVKEY_FILE , OCI_PRIVKEY_PASS , OCI_PUBKEY_FINGERPRINT , OCI_REGION , OCI_TENANCY_OCID , OCI_USER_OCID YES PowerDNS pdns PDNS_API_KEY , PDNS_API_URL Not tested yet Rackspace rackspace RACKSPACE_USER , RACKSPACE_API_KEY Not tested yet RFC2136 rfc2136 RFC2136_TSIG_KEY , RFC2136_TSIG_SECRET , RFC2136_TSIG_ALGORITHM , RFC2136_NAMESERVER Not tested yet Route 53 route53 AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , [AWS_REGION] , [AWS_HOSTED_ZONE_ID] or a configured user/instance IAM profile. YES Sakura Cloud sakuracloud SAKURACLOUD_ACCESS_TOKEN , SAKURACLOUD_ACCESS_TOKEN_SECRET Not tested yet Selectel selectel SELECTEL_API_TOKEN YES Stackpath stackpath STACKPATH_CLIENT_ID , STACKPATH_CLIENT_SECRET , STACKPATH_STACK_ID Not tested yet TransIP transip TRANSIP_ACCOUNT_NAME , TRANSIP_PRIVATE_KEY_PATH YES VegaDNS vegadns SECRET_VEGADNS_KEY , SECRET_VEGADNS_SECRET , VEGADNS_URL Not tested yet Vscale vscale VSCALE_API_TOKEN YES VULTR vultr VULTR_API_KEY Not tested yet Zone.ee zoneee ZONEEE_API_USER , ZONEEE_API_KEY YES delayBeforeCheck By default, the provider verifies the TXT record before letting ACME verify. You can delay this operation by specifying a delay (in seconds) with delayBeforeCheck (value must be greater than zero). This option is useful when internal networks block external DNS queries.","title":"providers"},{"location":"https-tls/acme/#resolvers","text":"Use custom DNS servers to resolve the FQDN authority. [acme] # ... [acme.dnsChallenge] # ... resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"]","title":"resolvers"},{"location":"https-tls/acme/#wildcard-domains","text":"ACME V2 supports wildcard certificates. As described in Let's Encrypt's post wildcard certificates can only be generated through a DNS-01 challenge . [acme] # ... [[acme.domains]] main = \"*.local1.com\" sans = [\"local1.com\"] # ... Double Wildcard Certificates It is not possible to request a double wildcard certificate for a domain (for example *.*.local.com ). Due to an ACME limitation it is not possible to define wildcards in SANs (alternative domains). Thus, the wildcard domain has to be defined as a main domain. Most likely the root domain should receive a certificate too, so it needs to be specified as SAN and 2 DNS-01 challenges are executed. In this case the generated DNS TXT record for both domains is the same. Even though this behavior is DNS RFC compliant, it can lead to problems as all DNS providers keep DNS records cached for a given time (TTL) and this TTL can be greater than the challenge timeout making the DNS-01 challenge fail. The Traefik ACME client library LEGO supports some but not all DNS providers to work around this issue. The Supported provider table indicates if they allow generating certificates for a wildcard domain and its root domain.","title":"Wildcard Domains"},{"location":"https-tls/acme/#known-domains-sans","text":"You can set SANs (alternative domains) for each main domain. Every domain must have A/AAAA records pointing to Traefik. Each domain & SAN will lead to a certificate request. [acme] # ... [[acme.domains]] main = \"local1.com\" sans = [\"test1.local1.com\", \"test2.local1.com\"] [[acme.domains]] main = \"local2.com\" [[acme.domains]] main = \"*.local3.com\" sans = [\"local3.com\", \"test1.test1.local3.com\"] # ... Important The certificates for the domains listed in acme.domains are negotiated at Traefik startup only. Note Wildcard certificates can only be verified through a DNS-01 challenge.","title":"Known Domains, SANs"},{"location":"https-tls/acme/#caserver","text":"Using the Let's Encrypt staging server [acme] # ... caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # ...","title":"caServer"},{"location":"https-tls/acme/#onhostrule","text":"Enable certificate generation on routers Host & HostSNI rules. This will request a certificate from Let's Encrypt for each router with a Host rule. [acme] # ... onHostRule = true # ... Multiple Hosts in a Rule The rule Host(test1.traefik.io,test2.traefik.io) will request a certificate with the main domain test1.traefik.io and SAN test2.traefik.io . Warning onHostRule option can not be used to generate wildcard certificates. Refer to wildcard generation for further information.","title":"onHostRule"},{"location":"https-tls/acme/#storage","text":"The storage option sets the location where your ACME certificates are saved to. [acme] # ... storage = \"acme.json\" # ... The value can refer to two kinds of storage: a JSON file a KV store entry","title":"storage"},{"location":"https-tls/acme/#in-a-file","text":"ACME certificates can be stored in a JSON file that needs to have a 600 file mode . In Docker you can mount either the JSON file, or the folder containing it: docker run -v \"/my/host/acme.json:acme.json\" traefik docker run -v \"/my/host/acme:/etc/traefik/acme\" traefik Warning For concurrency reason, this file cannot be shared across multiple instances of Traefik. Use a key value store entry instead.","title":"In a File"},{"location":"https-tls/acme/#in-a-a-key-value-store-entry","text":"ACME certificates can be stored in a key-value store entry. storage = \"traefik/acme/account\" Storage Size Because key-value stores have limited entry size, the certificates list is compressed before it is saved. For example, it is possible to store up to approximately 100 ACME certificates in Consul.","title":"In a a Key Value Store Entry"},{"location":"https-tls/acme/#fallbacks","text":"If Let's Encrypt is not reachable, the following certificates will apply: Previously generated ACME certificates (before downtime) Expired ACME certificates Provided certificates Note For new (sub)domains which need Let's Encrypt authentication, the default Traefik certificate will be used until Traefik is restarted. more information about the HTTP message format can be found here \u21a9 providing_credentials_to_your_application \u21a9 google/default.go \u21a9 docker stack remark: there is no way to support terminal attached to container when deploying with docker stack , so you might need to run container with docker run -it to generate certificates using manual provider. \u21a9","title":"Fallbacks"},{"location":"https-tls/overview/","text":"HTTPS & TLS \u00b6 Traefik supports HTTPS & TLS, and is able to accept new certificates / updates over time (without being restarted). TLS is enabled at the router level, but some options are configured in dedicated sections ( tlsOptions & tlsStores ) described in this section. Configuration Example \u00b6 Configuring a Default Certificate [tlsStores] [tlsStores.default] [tlsStores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" Configuring a Minimum TLS Version [tlsOptions] [tlsOptions.default] minVersion = \"VersionTLS12\" Defining Certificates [[tls]] [tls.certificate] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls]] [tls.certificate] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File Provider Only In the above example, we've used the file provider to handle the TLS configuration (tlsStores, tlsOptions, and TLS certificates). In its current alpha version, it is the only available method to configure these elements. Of course, these options are hot reloaded and can be updated at runtime (they belong to the dynamic configuration ). Configuration Options \u00b6 Dynamic Certificates \u00b6 To add / remove TLS certificates while Traefik is running, the file provider supports Dynamic TLS certificates in its [[tls]] section. Defining Certificates [[tls]] stores = [\"default\"] [tls.certificate] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls]] stores = [\"default\"] [tls.certificate] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" Stores During the alpha version, the stores option will be ignored and be automatically set to [\"default\"]. Mutual Authentication \u00b6 Traefik supports both optional and non optional (defaut value) mutual authentication. When optional = false , Traefik accepts connections only from client presenting a certificate signed by a CA listed in ClientCA.files . When optional = true , Traefik authorizes connections from client presenting a certificate signed by an unknown CA. Non Optional Mutual Authentication In the following example, both snitest.com and snitest.org will require client certificates. [tlsOptions] [tlsOptions.default] [tlsOptions.default.ClientCA] files = [\"tests/clientca1.crt\", \"tests/clientca2.crt\"] optional = false ClientCA.files You can use a file per CA:s , or a single file containing multiple CA:s (in PEM format). ClientCA.files is not optional: every client will have to present a valid certificate. (This requirement will apply to every server certificate declared in the entrypoint.) Minimum TLS Version \u00b6 Min TLS version & cipherSuites [tlsOptions] [tlsOptions.default] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\" ] Strict SNI Checking \u00b6 With strict SNI checking, Traefik won't allow connections without a matching certificate. Strict SNI [tlsOptions] [tlsOptions.default] sniStrict = true Default Certificate \u00b6 Traefik can use a default certificate for connections without a SNI, or without a matching domain. If no default certificate is provided, Traefik generates and uses a self-signed certificate. Setting a Default Certificate [tlsStores] [tlsStores.default] [tlsStores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" Only One Default Certificate There can only be one defaultCertificate per tlsOptions. Default TLS Store During the alpha version, there is only one globally available TLS Store ( default ).","title":"Overview"},{"location":"https-tls/overview/#https-tls","text":"Traefik supports HTTPS & TLS, and is able to accept new certificates / updates over time (without being restarted). TLS is enabled at the router level, but some options are configured in dedicated sections ( tlsOptions & tlsStores ) described in this section.","title":"HTTPS &amp; TLS"},{"location":"https-tls/overview/#configuration-example","text":"Configuring a Default Certificate [tlsStores] [tlsStores.default] [tlsStores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" Configuring a Minimum TLS Version [tlsOptions] [tlsOptions.default] minVersion = \"VersionTLS12\" Defining Certificates [[tls]] [tls.certificate] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls]] [tls.certificate] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" File Provider Only In the above example, we've used the file provider to handle the TLS configuration (tlsStores, tlsOptions, and TLS certificates). In its current alpha version, it is the only available method to configure these elements. Of course, these options are hot reloaded and can be updated at runtime (they belong to the dynamic configuration ).","title":"Configuration Example"},{"location":"https-tls/overview/#configuration-options","text":"","title":"Configuration Options"},{"location":"https-tls/overview/#dynamic-certificates","text":"To add / remove TLS certificates while Traefik is running, the file provider supports Dynamic TLS certificates in its [[tls]] section. Defining Certificates [[tls]] stores = [\"default\"] [tls.certificate] certFile = \"/path/to/domain.cert\" keyFile = \"/path/to/domain.key\" [[tls]] stores = [\"default\"] [tls.certificate] certFile = \"/path/to/other-domain.cert\" keyFile = \"/path/to/other-domain.key\" Stores During the alpha version, the stores option will be ignored and be automatically set to [\"default\"].","title":"Dynamic Certificates"},{"location":"https-tls/overview/#mutual-authentication","text":"Traefik supports both optional and non optional (defaut value) mutual authentication. When optional = false , Traefik accepts connections only from client presenting a certificate signed by a CA listed in ClientCA.files . When optional = true , Traefik authorizes connections from client presenting a certificate signed by an unknown CA. Non Optional Mutual Authentication In the following example, both snitest.com and snitest.org will require client certificates. [tlsOptions] [tlsOptions.default] [tlsOptions.default.ClientCA] files = [\"tests/clientca1.crt\", \"tests/clientca2.crt\"] optional = false ClientCA.files You can use a file per CA:s , or a single file containing multiple CA:s (in PEM format). ClientCA.files is not optional: every client will have to present a valid certificate. (This requirement will apply to every server certificate declared in the entrypoint.)","title":"Mutual Authentication"},{"location":"https-tls/overview/#minimum-tls-version","text":"Min TLS version & cipherSuites [tlsOptions] [tlsOptions.default] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\" ]","title":"Minimum TLS Version"},{"location":"https-tls/overview/#strict-sni-checking","text":"With strict SNI checking, Traefik won't allow connections without a matching certificate. Strict SNI [tlsOptions] [tlsOptions.default] sniStrict = true","title":"Strict SNI Checking"},{"location":"https-tls/overview/#default-certificate","text":"Traefik can use a default certificate for connections without a SNI, or without a matching domain. If no default certificate is provided, Traefik generates and uses a self-signed certificate. Setting a Default Certificate [tlsStores] [tlsStores.default] [tlsStores.default.defaultCertificate] certFile = \"path/to/cert.crt\" keyFile = \"path/to/cert.key\" Only One Default Certificate There can only be one defaultCertificate per tlsOptions. Default TLS Store During the alpha version, there is only one globally available TLS Store ( default ).","title":"Default Certificate"},{"location":"includes/more-on-command-line/","text":"To learn more about configuration options in the command line, refer to the configuration overview","title":"More on command line"},{"location":"includes/more-on-configuration-file/","text":"To learn more about the configuration file, refer to configuration overview","title":"More on configuration file"},{"location":"includes/more-on-entrypoints/","text":"More On Entrypoints Learn more about entrypoints and their configuration options in the dedicated section.","title":"More on entrypoints"},{"location":"includes/more-on-key-value-store/","text":"To learn more about configuration in key-value stores, refer to the configuration overview","title":"More on key value store"},{"location":"includes/more-on-routers/","text":"More On Routers Learn more about routers and their configuration options in the dedicated section .","title":"More on routers"},{"location":"middlewares/addprefix/","text":"Add Prefix \u00b6 Prefixing the Path The AddPrefix middleware updates the URL Path of the request before forwarding it. Configuration Examples \u00b6 Docker # Prefixing with /foo labels: - \"traefik.http.middlewares.add-bar.addprefix.prefix=/foo\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: addprefix spec: addprefix: prefix: /bar File # Prefixing with /foo [http.middlewares] [http.middlewares.add-foo.AddPrefix] prefix = \"/foo\" Configuration Options \u00b6 prefix \u00b6 prefix is the string to add before the current path in the requested URL. It should include the leading slash ( / ).","title":"AddPrefix"},{"location":"middlewares/addprefix/#add-prefix","text":"Prefixing the Path The AddPrefix middleware updates the URL Path of the request before forwarding it.","title":"Add Prefix"},{"location":"middlewares/addprefix/#configuration-examples","text":"Docker # Prefixing with /foo labels: - \"traefik.http.middlewares.add-bar.addprefix.prefix=/foo\" Kubernetes apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: addprefix spec: addprefix: prefix: /bar File # Prefixing with /foo [http.middlewares] [http.middlewares.add-foo.AddPrefix] prefix = \"/foo\"","title":"Configuration Examples"},{"location":"middlewares/addprefix/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/addprefix/#prefix","text":"prefix is the string to add before the current path in the requested URL. It should include the leading slash ( / ).","title":"prefix"},{"location":"middlewares/basicauth/","text":"BasicAuth \u00b6 Adding Basic Authentication The BasicAuth middleware is a quick way to restrict access to your services to known users. Configuration Examples \u00b6 Docker # Declaring the user list labels: - \"traefik.http.middlewares.declared-users-only.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", File # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicauth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] Configuration Options \u00b6 General \u00b6 Passwords must be encoded using MD5, SHA1, or BCrypt. Tip Use htpasswd to generate the passwords. users \u00b6 The users option is an array of authorized users. Each user will be declared using the name:encoded-password format. Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users . usersFile \u00b6 The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:encoded-password . A file containing test/test and test2/test2 test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users . realm \u00b6 You can customize the realm for the authentication with the realm option. The default value is traefik . headerField \u00b6 You can customize the header field for the authenticated user using the headerField option. File -- Passing Authenticated Users to Services Via Headers [http.middlewares.my-auth.basicauth] usersFile = \"path-to-file.ext\" headerField = \"X-WebAuth-User\" # header for the authenticated user removeHeader \u00b6 Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .)","title":"BasicAuth"},{"location":"middlewares/basicauth/#basicauth","text":"Adding Basic Authentication The BasicAuth middleware is a quick way to restrict access to your services to known users.","title":"BasicAuth"},{"location":"middlewares/basicauth/#configuration-examples","text":"Docker # Declaring the user list labels: - \"traefik.http.middlewares.declared-users-only.basicauth.users=test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/,test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\", File # Declaring the user list [http.middlewares] [http.middlewares.test-auth.basicauth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"]","title":"Configuration Examples"},{"location":"middlewares/basicauth/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/basicauth/#general","text":"Passwords must be encoded using MD5, SHA1, or BCrypt. Tip Use htpasswd to generate the passwords.","title":"General"},{"location":"middlewares/basicauth/#users","text":"The users option is an array of authorized users. Each user will be declared using the name:encoded-password format. Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users .","title":"users"},{"location":"middlewares/basicauth/#usersfile","text":"The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:encoded-password . A file containing test/test and test2/test2 test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/ test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0 Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users .","title":"usersFile"},{"location":"middlewares/basicauth/#realm","text":"You can customize the realm for the authentication with the realm option. The default value is traefik .","title":"realm"},{"location":"middlewares/basicauth/#headerfield","text":"You can customize the header field for the authenticated user using the headerField option. File -- Passing Authenticated Users to Services Via Headers [http.middlewares.my-auth.basicauth] usersFile = \"path-to-file.ext\" headerField = \"X-WebAuth-User\" # header for the authenticated user","title":"headerField"},{"location":"middlewares/basicauth/#removeheader","text":"Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .)","title":"removeHeader"},{"location":"middlewares/buffering/","text":"Buffering \u00b6 How to Read the Request before Forwarding It The Buffering middleware gives you control on how you want to read the requests before sending them to services. With Buffering, Traefik reads the entire request into memory (possibly buffering large requests into disk), and rejects requests that are over a specified limit. This can help services deal with large data (multipart/form-data for example), and can minimize time spent sending data to a service. Configuration Examples \u00b6 Docker # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.2Mb-memory.buffering.maxRequestBodyBytes=250000\", File # Sets the maximum request body to 2Mb [http.middlewares] [http.middlewares.2Mb-limit.buffering] maxRequestBodyBytes = 250000 Configuration Options \u00b6 maxRequestBodyBytes \u00b6 With the maxRequestBodyBytes option, you can configure the maximum allowed body size for the request (in Bytes). If the request exceeds the allowed size, the request is not forwarded to the service and the client gets a `413 (Request Entity Too Large) response. memRequestBodyBytes \u00b6 You can configure a thresold (in Bytes) from which the request will be buffered on disk instead of in memory with the memRequestBodyBytes option. maxResponseBodyBytes \u00b6 With the maxReesponseBodyBytes option, you can configure the maximum allowed response size from the service (in Bytes). If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 413 (Request Entity Too Large) response instead. memResponseBodyBytes \u00b6 You can configure a thresold (in Bytes) from which the response will be buffered on disk instead of in memory with the memResponseBodyBytes option. retryExpression \u00b6 You can have the Buffering middleware replay the request with the help of the retryExpression option. Retries once in case of a network error retryExpression = \"IsNetworkError() && Attempts() < 2\" Available functions for the retry expression are: Attempts() number of attempts (the first one counts) ResponseCode() response code of the service IsNetworkError() - if the response code is related to networking error","title":"Buffering"},{"location":"middlewares/buffering/#buffering","text":"How to Read the Request before Forwarding It The Buffering middleware gives you control on how you want to read the requests before sending them to services. With Buffering, Traefik reads the entire request into memory (possibly buffering large requests into disk), and rejects requests that are over a specified limit. This can help services deal with large data (multipart/form-data for example), and can minimize time spent sending data to a service.","title":"Buffering"},{"location":"middlewares/buffering/#configuration-examples","text":"Docker # Sets the maximum request body to 2Mb labels: - \"traefik.http.middlewares.2Mb-memory.buffering.maxRequestBodyBytes=250000\", File # Sets the maximum request body to 2Mb [http.middlewares] [http.middlewares.2Mb-limit.buffering] maxRequestBodyBytes = 250000","title":"Configuration Examples"},{"location":"middlewares/buffering/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/buffering/#maxrequestbodybytes","text":"With the maxRequestBodyBytes option, you can configure the maximum allowed body size for the request (in Bytes). If the request exceeds the allowed size, the request is not forwarded to the service and the client gets a `413 (Request Entity Too Large) response.","title":"maxRequestBodyBytes"},{"location":"middlewares/buffering/#memrequestbodybytes","text":"You can configure a thresold (in Bytes) from which the request will be buffered on disk instead of in memory with the memRequestBodyBytes option.","title":"memRequestBodyBytes"},{"location":"middlewares/buffering/#maxresponsebodybytes","text":"With the maxReesponseBodyBytes option, you can configure the maximum allowed response size from the service (in Bytes). If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 413 (Request Entity Too Large) response instead.","title":"maxResponseBodyBytes"},{"location":"middlewares/buffering/#memresponsebodybytes","text":"You can configure a thresold (in Bytes) from which the response will be buffered on disk instead of in memory with the memResponseBodyBytes option.","title":"memResponseBodyBytes"},{"location":"middlewares/buffering/#retryexpression","text":"You can have the Buffering middleware replay the request with the help of the retryExpression option. Retries once in case of a network error retryExpression = \"IsNetworkError() && Attempts() < 2\" Available functions for the retry expression are: Attempts() number of attempts (the first one counts) ResponseCode() response code of the service IsNetworkError() - if the response code is related to networking error","title":"retryExpression"},{"location":"middlewares/chain/","text":"Chain \u00b6 When One Isn't Enougth The Chain middleware enables you to define reusable combinations of other pieces of middleware. It makes reusing the same groups easier. Configuration Example \u00b6 A Chain for WhiteList, BasicAuth, and HTTPS # ... [http.routers] [http.routers.router1] service = \"service1\" middlewares = [\"secured\"] rule = \"Host: mydomain\" [http.middlewares] [http.middlewares.secured.Chain] middlewares = [\"https-only\", \"known-ips\", \"auth-users\"] [http.middlewares.auth-users.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.middlewares.https-only.SchemeRedirect] scheme = \"https\" [http.middlewares.known-ips.ipWhiteList] sourceRange = [\"192.168.1.7\", \"x.x.x.x\", \"x.x.x.x\"] [http.services] [http.services.service1] [http.services.service1.LoadBalancer] [[http.services.service1.LoadBalancer.Servers]] URL = \"http://127.0.0.1:80\" Weight = 1","title":"Chain"},{"location":"middlewares/chain/#chain","text":"When One Isn't Enougth The Chain middleware enables you to define reusable combinations of other pieces of middleware. It makes reusing the same groups easier.","title":"Chain"},{"location":"middlewares/chain/#configuration-example","text":"A Chain for WhiteList, BasicAuth, and HTTPS # ... [http.routers] [http.routers.router1] service = \"service1\" middlewares = [\"secured\"] rule = \"Host: mydomain\" [http.middlewares] [http.middlewares.secured.Chain] middlewares = [\"https-only\", \"known-ips\", \"auth-users\"] [http.middlewares.auth-users.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.middlewares.https-only.SchemeRedirect] scheme = \"https\" [http.middlewares.known-ips.ipWhiteList] sourceRange = [\"192.168.1.7\", \"x.x.x.x\", \"x.x.x.x\"] [http.services] [http.services.service1] [http.services.service1.LoadBalancer] [[http.services.service1.LoadBalancer.Servers]] URL = \"http://127.0.0.1:80\" Weight = 1","title":"Configuration Example"},{"location":"middlewares/circuitbreaker/","text":"CircuitBreaker \u00b6 Don't Waste Time Calling Unhealthy Services The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is close (normal operations). When your system becomes unhealthy, the circuit becomes open and the requests are no longer forwarded (but handled by a fallback mechanism). To assess if your system is healthy, the circuit breaker constantly monitors the services. Note The CircuitBreaker only analyses what happens after it is positioned in the middleware chain. What happens before has no impact on its state. The CircuitBreaker only affects the routers that use it. Routers that don't use the CircuitBreaker won't be affected by its state. Important Each router will eventually gets its own instance of a given circuit breaker. If two different routers refer to the same circuit breaker definition, they will get one instance each. It means that one circuit breaker can be open while the other stays close: their state is not shared. This is the expected behavior, we want you to be able to define what makes a service healthy without having to declare a circuit breaker for each route. Configuration Examples \u00b6 Docker # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" File # Latency Check [http.middlewares] [http.middlewares.latency-check.circuitbreaker] expression = \"LatencyAtQuantileMS(50.0) > 100\" Possible States \u00b6 There are three possible states for your circuit breaker: Close (your service operates normally) Open (the fallback mechanism takes over your service) Recovering (the circuit breaker tries to resume normal operations by progressively sending requests to your service) Close \u00b6 While close, the circuit breaker only collects metrics to analyze the behavior of the requests. At specified intervals ( checkPeriod ), it will evaluate expression to decide if its state must change. Open \u00b6 While open, the fallback mechanism takes over the normal service calls for a duration of FallbackDuration . After this duration, it will enter the recovering state. Recovering \u00b6 While recovering, the circuit breaker will progressively send requests to your service again (in a linear way, for RecoveryDuration ). If your service fails during recovery, the circuit breaker becomes open again. If the service operates normally during the whole recovering duration, then the circuit breaker returns to close. Configuration Options \u00b6 Configuring the Trigger \u00b6 You can specify an expression that, once matched, will trigger the circuit breaker (and apply the fallback mechanism instead of calling your services). The expression can check three different metrics: The network error ratio ( NetworkErrorRatio ) The status code ratio ( ResponseCodeRatio ) The latency at quantile, in milliseconds ( LatencyAtQuantileMS ) NetworkErrorRatio \u00b6 If you want the circuit breaker to trigger at a 30% ratio of network errors, the expression will be NetworkErrorRatio() > 0.30 ResponseCodeRatio \u00b6 You can trigger the circuit breaker based on the ratio of a given range of status codes. The ResponseCodeRatio accepts four parameters, from , to , dividedByFrom , dividedByTo . The operation that will be computed is sum( to -> from ) / sum ( dividedByFrom -> dividedByTo ). Note If sum ( dividedByFrom -> dividedByTo ) equals 0, then ResponseCodeRatio returns 0. from is inclusive, to is exclusive. For example, the expression ResponseCodeRatio(500, 600, 0, 600) > 0.25 will trigger the circuit breaker if 25% of the requests returned a 5XX status (amongst the request that returned a status code from 0 to 5XX). LatencyAtQuantileMS \u00b6 You can trigger the circuit breaker when a given proportion of your requests become too slow. For example, the expression LatencyAtQuantileMS(50.0) > 100 will trigger the circuit breaker when the median lantency (quantile 50) reaches 100MS. Note You must provide a float number (with the leading .0) for the quantile value Using multiple metrics \u00b6 You can combine multiple metrics using operators in your expression. Supported operators are: AND ( && ) OR (`||) For example, ResponseCodeRatio(500, 600, 0, 600) > 0.30 || NetworkErrorRatio() > 0.10 triggers the circuit breaker when 30% of the requests return a 5XX status code, or when the ratio of network errors reaches 10%. Operators \u00b6 Here is the list of supported operators: Greater than ( > ) Greater or equal than ( >= ) Lesser than ( < ) Lesser or equal than ( <= ) Not ( ! ) Equal ( == ) Not Equal ( != ) Fallback mechanism \u00b6 The fallback mechanism returns a HTTP 503 Service Unavailable to the client (instead of calling the target service). This behavior cannot be configured. CheckPeriod \u00b6 The interval used to evaluate expression and decide if the state of the circuit breaker must change. By default, CheckPeriod is 100Ms. This value cannot be configured. FallbackDuration \u00b6 By default, FallbackDuration is 10 seconds. This value cannot be configured. RecoveringDuration \u00b6 The duration of the recovering mode (recovering state). By default, RecoveringDuration is 10 seconds. This value cannot be configured.","title":"CircuitBreaker"},{"location":"middlewares/circuitbreaker/#circuitbreaker","text":"Don't Waste Time Calling Unhealthy Services The circuit breaker protects your system from stacking requests to unhealthy services (resulting in cascading failures). When your system is healthy, the circuit is close (normal operations). When your system becomes unhealthy, the circuit becomes open and the requests are no longer forwarded (but handled by a fallback mechanism). To assess if your system is healthy, the circuit breaker constantly monitors the services. Note The CircuitBreaker only analyses what happens after it is positioned in the middleware chain. What happens before has no impact on its state. The CircuitBreaker only affects the routers that use it. Routers that don't use the CircuitBreaker won't be affected by its state. Important Each router will eventually gets its own instance of a given circuit breaker. If two different routers refer to the same circuit breaker definition, they will get one instance each. It means that one circuit breaker can be open while the other stays close: their state is not shared. This is the expected behavior, we want you to be able to define what makes a service healthy without having to declare a circuit breaker for each route.","title":"CircuitBreaker"},{"location":"middlewares/circuitbreaker/#configuration-examples","text":"Docker # Latency Check labels: - \"traefik.http.middlewares.latency-check.circuitbreaker.expression=LatencyAtQuantileMS(50.0) > 100\" File # Latency Check [http.middlewares] [http.middlewares.latency-check.circuitbreaker] expression = \"LatencyAtQuantileMS(50.0) > 100\"","title":"Configuration Examples"},{"location":"middlewares/circuitbreaker/#possible-states","text":"There are three possible states for your circuit breaker: Close (your service operates normally) Open (the fallback mechanism takes over your service) Recovering (the circuit breaker tries to resume normal operations by progressively sending requests to your service)","title":"Possible States"},{"location":"middlewares/circuitbreaker/#close","text":"While close, the circuit breaker only collects metrics to analyze the behavior of the requests. At specified intervals ( checkPeriod ), it will evaluate expression to decide if its state must change.","title":"Close"},{"location":"middlewares/circuitbreaker/#open","text":"While open, the fallback mechanism takes over the normal service calls for a duration of FallbackDuration . After this duration, it will enter the recovering state.","title":"Open"},{"location":"middlewares/circuitbreaker/#recovering","text":"While recovering, the circuit breaker will progressively send requests to your service again (in a linear way, for RecoveryDuration ). If your service fails during recovery, the circuit breaker becomes open again. If the service operates normally during the whole recovering duration, then the circuit breaker returns to close.","title":"Recovering"},{"location":"middlewares/circuitbreaker/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/circuitbreaker/#configuring-the-trigger","text":"You can specify an expression that, once matched, will trigger the circuit breaker (and apply the fallback mechanism instead of calling your services). The expression can check three different metrics: The network error ratio ( NetworkErrorRatio ) The status code ratio ( ResponseCodeRatio ) The latency at quantile, in milliseconds ( LatencyAtQuantileMS )","title":"Configuring the Trigger"},{"location":"middlewares/circuitbreaker/#networkerrorratio","text":"If you want the circuit breaker to trigger at a 30% ratio of network errors, the expression will be NetworkErrorRatio() > 0.30","title":"NetworkErrorRatio"},{"location":"middlewares/circuitbreaker/#responsecoderatio","text":"You can trigger the circuit breaker based on the ratio of a given range of status codes. The ResponseCodeRatio accepts four parameters, from , to , dividedByFrom , dividedByTo . The operation that will be computed is sum( to -> from ) / sum ( dividedByFrom -> dividedByTo ). Note If sum ( dividedByFrom -> dividedByTo ) equals 0, then ResponseCodeRatio returns 0. from is inclusive, to is exclusive. For example, the expression ResponseCodeRatio(500, 600, 0, 600) > 0.25 will trigger the circuit breaker if 25% of the requests returned a 5XX status (amongst the request that returned a status code from 0 to 5XX).","title":"ResponseCodeRatio"},{"location":"middlewares/circuitbreaker/#latencyatquantilems","text":"You can trigger the circuit breaker when a given proportion of your requests become too slow. For example, the expression LatencyAtQuantileMS(50.0) > 100 will trigger the circuit breaker when the median lantency (quantile 50) reaches 100MS. Note You must provide a float number (with the leading .0) for the quantile value","title":"LatencyAtQuantileMS"},{"location":"middlewares/circuitbreaker/#using-multiple-metrics","text":"You can combine multiple metrics using operators in your expression. Supported operators are: AND ( && ) OR (`||) For example, ResponseCodeRatio(500, 600, 0, 600) > 0.30 || NetworkErrorRatio() > 0.10 triggers the circuit breaker when 30% of the requests return a 5XX status code, or when the ratio of network errors reaches 10%.","title":"Using multiple metrics"},{"location":"middlewares/circuitbreaker/#operators","text":"Here is the list of supported operators: Greater than ( > ) Greater or equal than ( >= ) Lesser than ( < ) Lesser or equal than ( <= ) Not ( ! ) Equal ( == ) Not Equal ( != )","title":"Operators"},{"location":"middlewares/circuitbreaker/#fallback-mechanism","text":"The fallback mechanism returns a HTTP 503 Service Unavailable to the client (instead of calling the target service). This behavior cannot be configured.","title":"Fallback mechanism"},{"location":"middlewares/circuitbreaker/#checkperiod","text":"The interval used to evaluate expression and decide if the state of the circuit breaker must change. By default, CheckPeriod is 100Ms. This value cannot be configured.","title":"CheckPeriod"},{"location":"middlewares/circuitbreaker/#fallbackduration","text":"By default, FallbackDuration is 10 seconds. This value cannot be configured.","title":"FallbackDuration"},{"location":"middlewares/circuitbreaker/#recoveringduration","text":"The duration of the recovering mode (recovering state). By default, RecoveringDuration is 10 seconds. This value cannot be configured.","title":"RecoveringDuration"},{"location":"middlewares/compress/","text":"Compress \u00b6 Compressing the Response before Sending it to the Client The Compress middleware enables the gzip compression. Configuration Examples \u00b6 Docker # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\", File # Enable gzip compression [http.middlewares] [http.middlewares.test-compress.Compress] Notes \u00b6 Responses are compressed when: The response body is larger than 512 bytes. The Accept-Encoding request header contains gzip . The response is not already compressed, i.e. the Content-Encoding response header is not already set.","title":"Compress"},{"location":"middlewares/compress/#compress","text":"Compressing the Response before Sending it to the Client The Compress middleware enables the gzip compression.","title":"Compress"},{"location":"middlewares/compress/#configuration-examples","text":"Docker # Enable gzip compression labels: - \"traefik.http.middlewares.test-compress.compress=true\", File # Enable gzip compression [http.middlewares] [http.middlewares.test-compress.Compress]","title":"Configuration Examples"},{"location":"middlewares/compress/#notes","text":"Responses are compressed when: The response body is larger than 512 bytes. The Accept-Encoding request header contains gzip . The response is not already compressed, i.e. the Content-Encoding response header is not already set.","title":"Notes"},{"location":"middlewares/digestauth/","text":"DigestAuth \u00b6 Adding Digest Authentication The DigestAuth middleware is a quick way to restrict access to your services to known users. Configuration Examples \u00b6 Docker labels: - \"traefik.http.middlewares.declared-users-only.digestauth.usersFile=path-to-file.ext\", File [http.middlewares] [http.middlewares.test-auth.digestauth] users = [\"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"] Tip Use htdigest to generate passwords. Configuration Options \u00b6 Users \u00b6 The users option is an array of authorized users. Each user will be declared using the name:realm:encoded-password format. Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users . UsersFile \u00b6 The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:realm:encoded-password . A file containing test/test and test2/test2 test:traefik:a2688e031edb4be6a3797f3882655c05 test2:traefik:518845800f9e2bfb1f1f740ec24f074e Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users . Realm \u00b6 You can customize the realm for the authentication with the realm option. The default value is traefik . HeaderField \u00b6 You can customize the header field for the authenticated user using the headerField option. File -- Passing Authenticated Users to Services Via Headers [http.middlewares.my-auth.digestauth] usersFile = \"path-to-file.ext\" headerField = \"X-WebAuth-User\" # header for the authenticated user RemoveHeader \u00b6 Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .)","title":"DigestAuth"},{"location":"middlewares/digestauth/#digestauth","text":"Adding Digest Authentication The DigestAuth middleware is a quick way to restrict access to your services to known users.","title":"DigestAuth"},{"location":"middlewares/digestauth/#configuration-examples","text":"Docker labels: - \"traefik.http.middlewares.declared-users-only.digestauth.usersFile=path-to-file.ext\", File [http.middlewares] [http.middlewares.test-auth.digestauth] users = [\"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"] Tip Use htdigest to generate passwords.","title":"Configuration Examples"},{"location":"middlewares/digestauth/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/digestauth/#users","text":"The users option is an array of authorized users. Each user will be declared using the name:realm:encoded-password format. Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users .","title":"Users"},{"location":"middlewares/digestauth/#usersfile","text":"The usersFile option is the path to an external file that contains the authorized users for the middleware. The file content is a list of name:realm:encoded-password . A file containing test/test and test2/test2 test:traefik:a2688e031edb4be6a3797f3882655c05 test2:traefik:518845800f9e2bfb1f1f740ec24f074e Note If both users and usersFile are provided, the two are merged. The content of usersFile has precedence over users .","title":"UsersFile"},{"location":"middlewares/digestauth/#realm","text":"You can customize the realm for the authentication with the realm option. The default value is traefik .","title":"Realm"},{"location":"middlewares/digestauth/#headerfield","text":"You can customize the header field for the authenticated user using the headerField option. File -- Passing Authenticated Users to Services Via Headers [http.middlewares.my-auth.digestauth] usersFile = \"path-to-file.ext\" headerField = \"X-WebAuth-User\" # header for the authenticated user","title":"HeaderField"},{"location":"middlewares/digestauth/#removeheader","text":"Set the removeHeader option to true to remove the authorization header before forwarding the request to your service. (Default value is false .)","title":"RemoveHeader"},{"location":"middlewares/errorpages/","text":"ErrorPage \u00b6 It Has Never Been Easier to Say That Something Went Wrong The ErrorPage middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes. Important The error page itself is not hosted by Traefik. Configuration Examples \u00b6 Docker # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\", - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\", - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\", File # Custom Error Page for 5XX [http.routers] [http.routers.router1] Service = \"my-service\" Rule = Host(`my-domain`) [http.middlewares] [http.middlewares.5XX-errors.Errors] status = [\"500-599\"] service = \"error-handler-service\" query = \"/error.html\" [http.services] # ... definition of error-handler-service and my-service Note In this example, the error page URL is based on the status code ( query=/{status}.html) . Configuration Options \u00b6 status \u00b6 The status that will trigger the error page. The status code ranges are inclusive ( 500-599 will trigger with every code between 500 and 599 , 500 and 599 included). Note You can define either a status code like 500 or ranges with a syntax like 500-599 . service \u00b6 The service that will serve the new requested error page. query \u00b6 The URL for the error page (hosted by service ). You can use {status} in the query, that will be replaced by the received status code.","title":"Errors"},{"location":"middlewares/errorpages/#errorpage","text":"It Has Never Been Easier to Say That Something Went Wrong The ErrorPage middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes. Important The error page itself is not hosted by Traefik.","title":"ErrorPage"},{"location":"middlewares/errorpages/#configuration-examples","text":"Docker # Dynamic Custom Error Page for 5XX Status Code labels: - \"traefik.http.middlewares.test-errorpage.errors.status=500-599\", - \"traefik.http.middlewares.test-errorpage.errors.service=serviceError\", - \"traefik.http.middlewares.test-errorpage.errors.query=/{status}.html\", File # Custom Error Page for 5XX [http.routers] [http.routers.router1] Service = \"my-service\" Rule = Host(`my-domain`) [http.middlewares] [http.middlewares.5XX-errors.Errors] status = [\"500-599\"] service = \"error-handler-service\" query = \"/error.html\" [http.services] # ... definition of error-handler-service and my-service Note In this example, the error page URL is based on the status code ( query=/{status}.html) .","title":"Configuration Examples"},{"location":"middlewares/errorpages/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/errorpages/#status","text":"The status that will trigger the error page. The status code ranges are inclusive ( 500-599 will trigger with every code between 500 and 599 , 500 and 599 included). Note You can define either a status code like 500 or ranges with a syntax like 500-599 .","title":"status"},{"location":"middlewares/errorpages/#service","text":"The service that will serve the new requested error page.","title":"service"},{"location":"middlewares/errorpages/#query","text":"The URL for the error page (hosted by service ). You can use {status} in the query, that will be replaced by the received status code.","title":"query"},{"location":"middlewares/forwardauth/","text":"ForwardAuth \u00b6 Using an External Service to Check for Credentials The ForwardAuth middleware delegate the authentication to an external service. If the service response code is 2XX, access is granted and the original request is performed. Otherwise, the response from the authentication server is returned. Configuration Examples \u00b6 File # Forward authentication to authserver.com [http.middlewares] [http.middlewares.test-auth.forwardauth] address = \"https://authserver.com/auth\" trustForwardHeader = true authResponseHeaders = [\"X-Auth-User\", \"X-Secret\"] [http.middlewares.test-auth.forwardauth.tls] ca = \"path/to/local.crt\" caOptional = true cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" Docker # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.ForwardAuth.Address=https://authserver.com/auth\" - \"traefik.http.middlewares.test-auth.ForwardAuth.AuthResponseHeaders=X-Auth-User, X-Secret\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.CA=path/to/local.crt\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.CAOptional=true\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.Cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.InsecureSkipVerify=true\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.Key=path/to/foo.key\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TrustForwardHeader=true\" Configuration Options \u00b6 address \u00b6 The address option defines the authentication server address. trustForwardHeader \u00b6 Set the trustForwardHeader option to true to trust all the existing X-Forwarded-* headers. authResponseHeaders \u00b6 The authResponseHeaders option is the list of the headers to copy from the authentication server to the request. tls \u00b6 The tls option is the tls configuration from Traefik to the authentication server.","title":"ForwardAuth"},{"location":"middlewares/forwardauth/#forwardauth","text":"Using an External Service to Check for Credentials The ForwardAuth middleware delegate the authentication to an external service. If the service response code is 2XX, access is granted and the original request is performed. Otherwise, the response from the authentication server is returned.","title":"ForwardAuth"},{"location":"middlewares/forwardauth/#configuration-examples","text":"File # Forward authentication to authserver.com [http.middlewares] [http.middlewares.test-auth.forwardauth] address = \"https://authserver.com/auth\" trustForwardHeader = true authResponseHeaders = [\"X-Auth-User\", \"X-Secret\"] [http.middlewares.test-auth.forwardauth.tls] ca = \"path/to/local.crt\" caOptional = true cert = \"path/to/foo.cert\" key = \"path/to/foo.key\" Docker # Forward authentication to authserver.com labels: - \"traefik.http.middlewares.test-auth.ForwardAuth.Address=https://authserver.com/auth\" - \"traefik.http.middlewares.test-auth.ForwardAuth.AuthResponseHeaders=X-Auth-User, X-Secret\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.CA=path/to/local.crt\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.CAOptional=true\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.Cert=path/to/foo.cert\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.InsecureSkipVerify=true\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TLS.Key=path/to/foo.key\" - \"traefik.http.middlewares.test-auth.ForwardAuth.TrustForwardHeader=true\"","title":"Configuration Examples"},{"location":"middlewares/forwardauth/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/forwardauth/#address","text":"The address option defines the authentication server address.","title":"address"},{"location":"middlewares/forwardauth/#trustforwardheader","text":"Set the trustForwardHeader option to true to trust all the existing X-Forwarded-* headers.","title":"trustForwardHeader"},{"location":"middlewares/forwardauth/#authresponseheaders","text":"The authResponseHeaders option is the list of the headers to copy from the authentication server to the request.","title":"authResponseHeaders"},{"location":"middlewares/forwardauth/#tls","text":"The tls option is the tls configuration from Traefik to the authentication server.","title":"tls"},{"location":"middlewares/headers/","text":"Headers \u00b6 Adding Headers to the Request / Response The Headers middleware can manage the requests/responses headers. Configuration Examples \u00b6 Adding Headers to the Request and the Response \u00b6 Add the X-Script-Name header to the proxied request and the X-Custom-Response-Header to the response Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.CustomRequestHeaders.X-Script-Name=test\", - \"traefik.http.middlewares.testHeader.Headers.CustomResponseHeaders.X-Custom-Response-Header=True\", File [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.CustomRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\" Adding and Removing Headers \u00b6 X-Script-Name header added to the proxied request, the X-Custom-Request-Header header removed from the request, and the X-Custom-Response-Header header removed from the response. File [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.CustomRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\" Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.CustomRequestHeaders.X-Script-Name=test\", - \"traefik.http.middlewares.testHeader.Headers.CustomResponseHeaders.X-Custom-Response-Header=True\", Using Security Headers \u00b6 Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above. This functionality allows for some easy security features to quickly be set. File [http.middlewares] [http.middlewares.testHeader.headers] FrameDeny = true SSLRedirect = true Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.FrameDeny=true\", - \"traefik.http.middlewares.testHeader.Headers.SSLRedirect=true\", Configuration Options \u00b6 General \u00b6 Warning If the custom header name is the same as one header name of the request or response, it will be replaced. Note The detailed documentation for the security headers can be found in unrolled/secure . customRequestHeaders \u00b6 The customRequestHeaders option lists the Header names and values to apply to the request. allowedHosts \u00b6 The allowedHosts option lists fully qualified domain names that are allowed. hostsProxyHeaders \u00b6 The hostsProxyHeaders option is a set of header keys that may hold a proxied hostname value for the request. sslRedirect \u00b6 The sslRedirect is set to true, then only allow https requests. sslTemporaryRedirect \u00b6 Set the sslTemporaryRedirect to true to force an SSL redirection using a 302 (instead of a 301). sslHost \u00b6 The SSLHost option is the host name that is used to redirect http requests to https. sslProxyHeaders \u00b6 The sslProxyHeaders option is set of header keys with associated values that would indicate a valid https request. Useful when using other proxies with header like: \"X-Forwarded-Proto\": \"https\" . sslForceHost \u00b6 Set sslForceHost to true and set SSLHost to forced requests to use SSLHost even the ones that are already using SSL. stsSeconds \u00b6 The stsSeconds is the max-age of the Strict-Transport-Security header. If set to 0, would NOT include the header. stsIncludeSubdomains \u00b6 The stsIncludeSubdomains is set to true, the includeSubdomains will be appended to the Strict-Transport-Security header. stsPreload \u00b6 Set STSPreload to true to have the preload flag appended to the Strict-Transport-Security header. forceSTSHeader \u00b6 Set ForceSTSHeader to true, to add the STS header even when the connection is HTTP. frameDeny \u00b6 Set frameDeny to true to add the X-Frame-Options header with the value of DENY . customFrameOptionsValue \u00b6 The customFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option. contentTypeNosniff \u00b6 Set contentTypeNosniff to true to add the X-Content-Type-Options header with the value nosniff . browserXssFilter \u00b6 Set BrowserXssFilter to true to add the X-XSS-Protection header with the value 1; mode=block . customBrowserXSSValue \u00b6 The customBrowserXssValue option allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option. contentSecurityPolicy \u00b6 The contentSecurityPolicy option allows the Content-Security-Policy header value to be set with a custom value. publicKey \u00b6 The publicKey implements HPKP to prevent MITM attacks with forged certificates. referrerPolicy \u00b6 The referrerPolicy allows sites to control when browsers will pass the Referer header to other sites. isDevelopment \u00b6 Set isDevelopment to true when developing. The AllowedHosts, SSL, and STS options can cause some unwanted effects. Usually testing happens on http, not https, and on localhost, not your production domain. If you would like your development environment to mimic production with complete Host blocking, SSL redirects, and STS headers, leave this as false.","title":"Headers"},{"location":"middlewares/headers/#headers","text":"Adding Headers to the Request / Response The Headers middleware can manage the requests/responses headers.","title":"Headers"},{"location":"middlewares/headers/#configuration-examples","text":"","title":"Configuration Examples"},{"location":"middlewares/headers/#adding-headers-to-the-request-and-the-response","text":"Add the X-Script-Name header to the proxied request and the X-Custom-Response-Header to the response Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.CustomRequestHeaders.X-Script-Name=test\", - \"traefik.http.middlewares.testHeader.Headers.CustomResponseHeaders.X-Custom-Response-Header=True\", File [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.CustomRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\"","title":"Adding Headers to the Request and the Response"},{"location":"middlewares/headers/#adding-and-removing-headers","text":"X-Script-Name header added to the proxied request, the X-Custom-Request-Header header removed from the request, and the X-Custom-Response-Header header removed from the response. File [http.middlewares] [http.middlewares.testHeader.headers] [http.middlewares.testHeader.headers.CustomRequestHeaders] X-Script-Name = \"test\" [http.middlewares.testHeader.headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\" Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.CustomRequestHeaders.X-Script-Name=test\", - \"traefik.http.middlewares.testHeader.Headers.CustomResponseHeaders.X-Custom-Response-Header=True\",","title":"Adding and Removing Headers"},{"location":"middlewares/headers/#using-security-headers","text":"Security related headers (HSTS headers, SSL redirection, Browser XSS filter, etc) can be added and configured per frontend in a similar manner to the custom headers above. This functionality allows for some easy security features to quickly be set. File [http.middlewares] [http.middlewares.testHeader.headers] FrameDeny = true SSLRedirect = true Docker a-container: image: a-container-image labels: - \"traefik.http.middlewares.testHeader.Headers.FrameDeny=true\", - \"traefik.http.middlewares.testHeader.Headers.SSLRedirect=true\",","title":"Using Security Headers"},{"location":"middlewares/headers/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/headers/#general","text":"Warning If the custom header name is the same as one header name of the request or response, it will be replaced. Note The detailed documentation for the security headers can be found in unrolled/secure .","title":"General"},{"location":"middlewares/headers/#customrequestheaders","text":"The customRequestHeaders option lists the Header names and values to apply to the request.","title":"customRequestHeaders"},{"location":"middlewares/headers/#allowedhosts","text":"The allowedHosts option lists fully qualified domain names that are allowed.","title":"allowedHosts"},{"location":"middlewares/headers/#hostsproxyheaders","text":"The hostsProxyHeaders option is a set of header keys that may hold a proxied hostname value for the request.","title":"hostsProxyHeaders"},{"location":"middlewares/headers/#sslredirect","text":"The sslRedirect is set to true, then only allow https requests.","title":"sslRedirect"},{"location":"middlewares/headers/#ssltemporaryredirect","text":"Set the sslTemporaryRedirect to true to force an SSL redirection using a 302 (instead of a 301).","title":"sslTemporaryRedirect"},{"location":"middlewares/headers/#sslhost","text":"The SSLHost option is the host name that is used to redirect http requests to https.","title":"sslHost"},{"location":"middlewares/headers/#sslproxyheaders","text":"The sslProxyHeaders option is set of header keys with associated values that would indicate a valid https request. Useful when using other proxies with header like: \"X-Forwarded-Proto\": \"https\" .","title":"sslProxyHeaders"},{"location":"middlewares/headers/#sslforcehost","text":"Set sslForceHost to true and set SSLHost to forced requests to use SSLHost even the ones that are already using SSL.","title":"sslForceHost"},{"location":"middlewares/headers/#stsseconds","text":"The stsSeconds is the max-age of the Strict-Transport-Security header. If set to 0, would NOT include the header.","title":"stsSeconds"},{"location":"middlewares/headers/#stsincludesubdomains","text":"The stsIncludeSubdomains is set to true, the includeSubdomains will be appended to the Strict-Transport-Security header.","title":"stsIncludeSubdomains"},{"location":"middlewares/headers/#stspreload","text":"Set STSPreload to true to have the preload flag appended to the Strict-Transport-Security header.","title":"stsPreload"},{"location":"middlewares/headers/#forcestsheader","text":"Set ForceSTSHeader to true, to add the STS header even when the connection is HTTP.","title":"forceSTSHeader"},{"location":"middlewares/headers/#framedeny","text":"Set frameDeny to true to add the X-Frame-Options header with the value of DENY .","title":"frameDeny"},{"location":"middlewares/headers/#customframeoptionsvalue","text":"The customFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This overrides the FrameDeny option.","title":"customFrameOptionsValue"},{"location":"middlewares/headers/#contenttypenosniff","text":"Set contentTypeNosniff to true to add the X-Content-Type-Options header with the value nosniff .","title":"contentTypeNosniff"},{"location":"middlewares/headers/#browserxssfilter","text":"Set BrowserXssFilter to true to add the X-XSS-Protection header with the value 1; mode=block .","title":"browserXssFilter"},{"location":"middlewares/headers/#custombrowserxssvalue","text":"The customBrowserXssValue option allows the X-XSS-Protection header value to be set with a custom value. This overrides the BrowserXssFilter option.","title":"customBrowserXSSValue"},{"location":"middlewares/headers/#contentsecuritypolicy","text":"The contentSecurityPolicy option allows the Content-Security-Policy header value to be set with a custom value.","title":"contentSecurityPolicy"},{"location":"middlewares/headers/#publickey","text":"The publicKey implements HPKP to prevent MITM attacks with forged certificates.","title":"publicKey"},{"location":"middlewares/headers/#referrerpolicy","text":"The referrerPolicy allows sites to control when browsers will pass the Referer header to other sites.","title":"referrerPolicy"},{"location":"middlewares/headers/#isdevelopment","text":"Set isDevelopment to true when developing. The AllowedHosts, SSL, and STS options can cause some unwanted effects. Usually testing happens on http, not https, and on localhost, not your production domain. If you would like your development environment to mimic production with complete Host blocking, SSL redirects, and STS headers, leave this as false.","title":"isDevelopment"},{"location":"middlewares/ipwhitelist/","text":"IPWhiteList \u00b6 Limiting Clients to Specific IPs IPWhitelist accepts / refuses requests based on the client IP. Configuration Examples \u00b6 Docker # Accepts request from defined IP labels: - \"traefik.http.middlewares.Middleware9.IPWhiteList.SourceRange=127.0.0.1/32, 192.168.1.7\" File # Accepts request from defined IP [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] Configuration Options \u00b6 sourceRange \u00b6 The sourceRange option sets the allowed IPs (or ranges of allowed IPs). ipStrategy \u00b6 The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs . ipStrategy.depth \u00b6 The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). Examples of Depth & X-Forwaded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used for the whitelisting would be \"12.0.0.1\" ( depth=2 ). More examples X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" File -- Whitelisting Based on X-Forwarded-For with depth=2 [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] depth = 2 Docker -- Whitelisting Based on X-Forwarded-For with depth=2 a-container: image: a-container-image labels: - \"traefik.http.middlewares.testIPwhitelist.ipWhiteList.SourceRange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Note If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is is lesser than or equal to 0. ipStrategy.excludedIPs \u00b6 excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. Examples of ExcludedIPs & X-Forwaded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\" Important If depth is specified, excludedIPs is ignored. File -- Exclude from X-Forwarded-For [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] Docker -- Exclude from X-Forwarded-For a-container: image: a-container-image labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.excludedIPs=127.0.0.1/32, 192.168.1.7\"","title":"IpWhitelist"},{"location":"middlewares/ipwhitelist/#ipwhitelist","text":"Limiting Clients to Specific IPs IPWhitelist accepts / refuses requests based on the client IP.","title":"IPWhiteList"},{"location":"middlewares/ipwhitelist/#configuration-examples","text":"Docker # Accepts request from defined IP labels: - \"traefik.http.middlewares.Middleware9.IPWhiteList.SourceRange=127.0.0.1/32, 192.168.1.7\" File # Accepts request from defined IP [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"]","title":"Configuration Examples"},{"location":"middlewares/ipwhitelist/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/ipwhitelist/#sourcerange","text":"The sourceRange option sets the allowed IPs (or ranges of allowed IPs).","title":"sourceRange"},{"location":"middlewares/ipwhitelist/#ipstrategy","text":"The ipStrategy option defines two parameters that sets how Traefik will determine the client IP: depth , and excludedIPs .","title":"ipStrategy"},{"location":"middlewares/ipwhitelist/#ipstrategydepth","text":"The depth option tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right). Examples of Depth & X-Forwaded-For If depth was equal to 2, and the request X-Forwarded-For header was \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" then the \"real\" client IP would be \"10.0.0.1\" (at depth 4) but the IP used for the whitelisting would be \"12.0.0.1\" ( depth=2 ). More examples X-Forwarded-For depth clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 1 \"13.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 3 \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" 5 \"\" File -- Whitelisting Based on X-Forwarded-For with depth=2 [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] depth = 2 Docker -- Whitelisting Based on X-Forwarded-For with depth=2 a-container: image: a-container-image labels: - \"traefik.http.middlewares.testIPwhitelist.ipWhiteList.SourceRange=127.0.0.1/32, 192.168.1.7\" - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.depth=2\" Note If depth is greater than the total number of IPs in X-Forwarded-For , then the client IP will be empty. depth is ignored if its value is is lesser than or equal to 0.","title":"ipStrategy.depth"},{"location":"middlewares/ipwhitelist/#ipstrategyexcludedips","text":"excludedIPs tells Traefik to scan the X-Forwarded-For header and pick the first IP not in the list. Examples of ExcludedIPs & X-Forwaded-For X-Forwarded-For excludedIPs clientIP \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"12.0.0.1,13.0.0.1\" \"11.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"10.0.0.1,13.0.0.1\" \"12.0.0.1\" \"10.0.0.1,11.0.0.1,12.0.0.1,13.0.0.1\" \"15.0.0.1,16.0.0.1\" \"13.0.0.1\" \"10.0.0.1,11.0.0.1\" \"10.0.0.1,11.0.0.1\" \"\" Important If depth is specified, excludedIPs is ignored. File -- Exclude from X-Forwarded-For [http.middlewares] [http.middlewares.test-ipwhitelist.ipWhiteList] [http.middlewares.test-ipwhitelist.ipWhiteList.ipStrategy] excludedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] Docker -- Exclude from X-Forwarded-For a-container: image: a-container-image labels: - \"traefik.http.middlewares.testIPwhitelist.ipwhitelist.ipstrategy.excludedIPs=127.0.0.1/32, 192.168.1.7\"","title":"ipStrategy.excludedIPs"},{"location":"middlewares/maxconnection/","text":"MaxConnection \u00b6 Limiting the Number of Simultaneous Clients To proactively prevent services from being overwhelmed with high load, a maximum connection limit can be applied. Configuration Examples \u00b6 Docker # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-maxconn.maxconn.amount=10\" File # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-maxconn.maxconn] amount = 10 Configuration Options \u00b6 amount \u00b6 The amount option defines the maximum amount of allowed simultaneous connections. The middleware will return an HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same extractorfunc strategy). extractorfunc \u00b6 The extractorfunc defines the strategy used to categorize requests. The possible values are: request.host categorizes requests based on the request host. client.ip categorizes requests based on the client ip. request.header.ANY_HEADER categorizes requests based on the provided ANY_HEADER value.","title":"Maxconn"},{"location":"middlewares/maxconnection/#maxconnection","text":"Limiting the Number of Simultaneous Clients To proactively prevent services from being overwhelmed with high load, a maximum connection limit can be applied.","title":"MaxConnection"},{"location":"middlewares/maxconnection/#configuration-examples","text":"Docker # Limiting to 10 simultaneous connections labels: - \"traefik.http.middlewares.test-maxconn.maxconn.amount=10\" File # Limiting to 10 simultaneous connections [http.middlewares] [http.middlewares.test-maxconn.maxconn] amount = 10","title":"Configuration Examples"},{"location":"middlewares/maxconnection/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/maxconnection/#amount","text":"The amount option defines the maximum amount of allowed simultaneous connections. The middleware will return an HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same extractorfunc strategy).","title":"amount"},{"location":"middlewares/maxconnection/#extractorfunc","text":"The extractorfunc defines the strategy used to categorize requests. The possible values are: request.host categorizes requests based on the request host. client.ip categorizes requests based on the client ip. request.header.ANY_HEADER categorizes requests based on the provided ANY_HEADER value.","title":"extractorfunc"},{"location":"middlewares/overview/","text":"Middlewares \u00b6 Tweaking the Request Attached to the routers, pieces of middleware are a mean of tweaking the requests before they are sent to your service (or before the answer from the services are sent to the clients). There are many different available middlewares in Traefik, some can modify the request, the headers, some are in charge of redirections, some add authentication, and so on. Pieces of middleware can be combined in chains to fit every scenario. Configuration Example \u00b6 Docker # As a Docker Label whoami: image: containous/whoami # A container that exposes an API to show its IP address labels: - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\", Kubernetes # As a Kubernetes Traefik IngressRoute apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripprefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute.crd spec: # more fields... routes: # more fields... middleware: - name: stripprefix File # As Toml Configuration File [providers] [providers.file] [http.routers] [http.routers.router1] Service = \"myService\" Middlewares = [\"foo-add-prefix\"] Rule = \"Host(`example.com`)\" [http.middlewares] [http.middlewares.foo-add-prefix.AddPrefix] prefix = \"/foo\" [http.services] [http.services.service1] [http.services.service1.LoadBalancer] [[http.services.service1.LoadBalancer.Servers]] URL = \"http://127.0.0.1:80\" Weight = 1 Advanced Configuration \u00b6 When you declare a middleware, it lives in its provider namespace. For example, if you declare a middleware using a Docker label, under the hoods, it will reside in the docker provider namespace. If you use multiple providers and wish to reference a middleware declared in another provider , then you'll have to prefix the middleware name with the provider name. Referencing a Middleware from Another Provider Declaring the add-foo-prefix in the file provider. [providers] [providers.file] [http.middlewares] [http.middlewares.add-foo-prefix.AddPrefix] prefix = \"/foo\" Using the add-foo-prefix middleware from docker. your-container: # image: your-docker-image labels: # Attach file.add-foo-prefix middleware (declared in file) - \"traefik.http.routers.middlewares=file.add-foo-prefix\", Available Middlewares \u00b6 Middleware Purpose Area AddPrefix Add a Path Prefix Path Modifier BasicAuth Basic auth mechanism Security, Authentication Buffering Buffers the request/response Request Lifecycle Chain Combine multiple pieces of middleware Middleware tool CircuitBreaker Stop calling unhealthy services Request Lifecycle Compress Compress the response Content Modifier DigestAuth Adds Digest Authentication Security, Authentication Errors Define custom error pages Request Lifecycle ForwardAuth Authentication delegation Security, Authentication Headers Add / Update headers Security IPWhiteList Limit the allowed client IPs Security, Request lifecycle MaxConnection Limit the number of simultaneous connections Security, Request lifecycle PassTLSClientCert TODO Security RateLimit Limit the call frequency Security, Request lifecycle RedirectScheme Redirect easily the client elsewhere Request lifecycle RedirectRegex Redirect the client elsewhere Request lifecycle ReplacePath Change the path of the request Path Modifier ReplacePathRegex Change the path of the request Path Modifier Retry Automatically retry the request in case of errors Request lifecycle StripPrefix Change the path of the request Path Modifier StripPrefixRegex Change the path of the request Path Modifier","title":"Overview"},{"location":"middlewares/overview/#middlewares","text":"Tweaking the Request Attached to the routers, pieces of middleware are a mean of tweaking the requests before they are sent to your service (or before the answer from the services are sent to the clients). There are many different available middlewares in Traefik, some can modify the request, the headers, some are in charge of redirections, some add authentication, and so on. Pieces of middleware can be combined in chains to fit every scenario.","title":"Middlewares"},{"location":"middlewares/overview/#configuration-example","text":"Docker # As a Docker Label whoami: image: containous/whoami # A container that exposes an API to show its IP address labels: - \"traefik.http.middlewares.foo-add-prefix.addprefix.prefix=/foo\", Kubernetes # As a Kubernetes Traefik IngressRoute apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripprefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute.crd spec: # more fields... routes: # more fields... middleware: - name: stripprefix File # As Toml Configuration File [providers] [providers.file] [http.routers] [http.routers.router1] Service = \"myService\" Middlewares = [\"foo-add-prefix\"] Rule = \"Host(`example.com`)\" [http.middlewares] [http.middlewares.foo-add-prefix.AddPrefix] prefix = \"/foo\" [http.services] [http.services.service1] [http.services.service1.LoadBalancer] [[http.services.service1.LoadBalancer.Servers]] URL = \"http://127.0.0.1:80\" Weight = 1","title":"Configuration Example"},{"location":"middlewares/overview/#advanced-configuration","text":"When you declare a middleware, it lives in its provider namespace. For example, if you declare a middleware using a Docker label, under the hoods, it will reside in the docker provider namespace. If you use multiple providers and wish to reference a middleware declared in another provider , then you'll have to prefix the middleware name with the provider name. Referencing a Middleware from Another Provider Declaring the add-foo-prefix in the file provider. [providers] [providers.file] [http.middlewares] [http.middlewares.add-foo-prefix.AddPrefix] prefix = \"/foo\" Using the add-foo-prefix middleware from docker. your-container: # image: your-docker-image labels: # Attach file.add-foo-prefix middleware (declared in file) - \"traefik.http.routers.middlewares=file.add-foo-prefix\",","title":"Advanced Configuration"},{"location":"middlewares/overview/#available-middlewares","text":"Middleware Purpose Area AddPrefix Add a Path Prefix Path Modifier BasicAuth Basic auth mechanism Security, Authentication Buffering Buffers the request/response Request Lifecycle Chain Combine multiple pieces of middleware Middleware tool CircuitBreaker Stop calling unhealthy services Request Lifecycle Compress Compress the response Content Modifier DigestAuth Adds Digest Authentication Security, Authentication Errors Define custom error pages Request Lifecycle ForwardAuth Authentication delegation Security, Authentication Headers Add / Update headers Security IPWhiteList Limit the allowed client IPs Security, Request lifecycle MaxConnection Limit the number of simultaneous connections Security, Request lifecycle PassTLSClientCert TODO Security RateLimit Limit the call frequency Security, Request lifecycle RedirectScheme Redirect easily the client elsewhere Request lifecycle RedirectRegex Redirect the client elsewhere Request lifecycle ReplacePath Change the path of the request Path Modifier ReplacePathRegex Change the path of the request Path Modifier Retry Automatically retry the request in case of errors Request lifecycle StripPrefix Change the path of the request Path Modifier StripPrefixRegex Change the path of the request Path Modifier","title":"Available Middlewares"},{"location":"middlewares/passtlsclientcert/","text":"TODO - PassTLSClientCert \u00b6 Adding Client Certificates in a Header TODO add schema PassTLSClientCert adds in header the selected data from the passed client tls certificate. Configuration Examples \u00b6 Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header. Docker # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.Middleware11.passtlsclientcert.pem=true\" File # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. [http.middlewares] [http.middlewares.test-passtlsclientcert.passtlsclientcert] pem = true Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header Docker # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" File # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header [http.middlewares] [http.middlewares.test-passtlsclientcert.passtlsclientcert] [http.middlewares.test-passtlsclientcert.passtlsclientcert.info] notAfter = true notBefore = true sans = true [http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true Configuration Options \u00b6 General \u00b6 PassTLSClientCert can add two headers to the request: X-Forwarded-Tls-Client-Cert that contains the escaped pem. X-Forwarded-Tls-Client-Cert-Info that contains all the selected certificate information in an escaped string. Note The headers are filled with escaped string so it can be safely placed inside a URL query. In the following example, you can see a complete certificate. We will use each part of it to explains the middleware options. A complete client tls certificate Certificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: sha1WithRSAEncryption Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com Validity Not Before: Dec 6 11:10:16 2018 GMT Not After : Dec 5 11:10:16 2020 GMT Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:de:77:fa:8d:03:70:30:39:dd:51:1b:cc:60:db: a9:5a:13:b1:af:fe:2c:c6:38:9b:88:0a:0f:8e:d9: 1b:a1:1d:af:0d:66:e4:13:5b:bc:5d:36:92:d7:5e: d0:fa:88:29:d3:78:e1:81:de:98:b2:a9:22:3f:bf: 8a:af:12:92:63:d4:a9:c3:f2:e4:7e:d2:dc:a2:c5: 39:1c:7a:eb:d7:12:70:63:2e:41:47:e0:f0:08:e8: dc:be:09:01:ec:28:09:af:35:d7:79:9c:50:35:d1: 6b:e5:87:7b:34:f6:d2:31:65:1d:18:42:69:6c:04: 11:83:fe:44:ae:90:92:2d:0b:75:39:57:62:e6:17: 2f:47:2b:c7:53:dd:10:2d:c9:e3:06:13:d2:b9:ba: 63:2e:3c:7d:83:6b:d6:89:c9:cc:9d:4d:bf:9f:e8: a3:7b:da:c8:99:2b:ba:66:d6:8e:f8:41:41:a0:c9: d0:5e:c8:11:a4:55:4a:93:83:87:63:04:63:41:9c: fb:68:04:67:c2:71:2f:f2:65:1d:02:5d:15:db:2c: d9:04:69:85:c2:7d:0d:ea:3b:ac:85:f8:d4:8f:0f: c5:70:b2:45:e1:ec:b2:54:0b:e9:f7:82:b4:9b:1b: 2d:b9:25:d4:ab:ca:8f:5b:44:3e:15:dd:b8:7f:b7: ee:f9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Basic Constraints: CA:FALSE X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 Subject Key Identifier: 94:BA:73:78:A2:87:FB:58:28:28:CF:98:3B:C2:45:70:16:6E:29:2F X509v3 Authority Key Identifier: keyid:1E:52:A2:E8:54:D5:37:EB:D5:A8:1D:E4:C2:04:1D:37:E2:F7:70:03 X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net Signature Algorithm: sha1WithRSAEncryption 76:6b:05:b0:0e:34:11:b1:83:99:91:dc:ae:1b:e2:08:15:8b: 16:b2:9b:27:1c:02:ac:b5:df:1b:d0:d0:75:a4:2b:2c:5c:65: ed:99:ab:f7:cd:fe:38:3f:c3:9a:22:31:1b:ac:8c:1c:c2:f9: 5d:d4:75:7a:2e:72:c7:85:a9:04:af:9f:2a:cc:d3:96:75:f0: 8e:c7:c6:76:48:ac:45:a4:b9:02:1e:2f:c0:15:c4:07:08:92: cb:27:50:67:a1:c8:05:c5:3a:b3:a6:48:be:eb:d5:59:ab:a2: 1b:95:30:71:13:5b:0a:9a:73:3b:60:cc:10:d0:6a:c7:e5:d7: 8b:2f:f9:2e:98:f2:ff:81:14:24:09:e3:4b:55:57:09:1a:22: 74:f1:f6:40:13:31:43:89:71:0a:96:1a:05:82:1f:83:3a:87: 9b:17:25:ef:5a:55:f2:2d:cd:0d:4d:e4:81:58:b6:e3:8d:09: 62:9a:0c:bd:e4:e5:5c:f0:95:da:cb:c7:34:2c:34:5f:6d:fc: 60:7b:12:5b:86:fd:df:21:89:3b:48:08:30:bf:67:ff:8c:e6: 9b:53:cc:87:36:47:70:40:3b:d9:90:2a:d2:d2:82:c6:9c:f5: d1:d8:e0:e6:fd:aa:2f:95:7e:39:ac:fc:4e:d4:ce:65:b3:ec: c6:98:8a:31 -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- pem \u00b6 The pem option sets the X-Forwarded-Tls-Client-Cert header with the escape certificate. In the example, it is the part between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- delimiters : The data used by the pem option -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- Extracted data The delimiters and \\n will be removed. If there are more than one certificate, they are separated by a \" ; \". info \u00b6 The info option select the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The value of the header will be an escaped concatenation of all the selected certificate details. The following example shows an unescaped result that uses all the available fields: Subject=\"DC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com\",Issuer=\"DC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2\",NB=1544094616,NA=1607166616,SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2 Multiple certificates If there are more than one certificate, they are separated by a ; . info.notafter \u00b6 Set the info.notafter option to true to add the Not After information from the Validity part. The data are taken from the following certificate part: Validity Not After : Dec 5 11:10:16 2020 GMT The escape notafter info part will be like: NA=1607166616 info.notbefore \u00b6 Set the info.notafter option to true to add the Not Before information from the Validity part. The data are taken from the following certificate part: Validity Not Before: Dec 6 11:10:16 2018 GMT The escape notafter info part will be like: NB=1544094616 info.sans \u00b6 Set the info.sans option to true to add the Subject Alternative Name information from the Subject Alternative Name part. The data are taken from the following certificate part: X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net The escape SANs info part will be like: SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2 multiple values All the SANs data are separated by a , . info.subject \u00b6 The info.subject select the specific client certificate subject details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com info.subject.country \u00b6 Set the info.subject.country option to true to add the country information into the subject. The data are taken from the subject part with the C key. The escape country info in the subject part will be like : C=FR,C=US info.subject.province \u00b6 Set the info.subject.province option to true to add the province information into the subject. The data are taken from the subject part with the ST key. The escape province info in the subject part will be like : ST=Cheese org state,ST=Cheese com state info.subject.locality \u00b6 Set the info.subject.locality option to true to add the locality information into the subject. The data are taken from the subject part with the L key. The escape locality info in the subject part will be like : L=TOULOUSE,L=LYON info.subject.organization \u00b6 Set the info.subject.organization option to true to add the organization information into the subject. The data are taken from the subject part with the O key. The escape organization info in the subject part will be like : O=Cheese,O=Cheese 2 info.subject.commonname \u00b6 Set the info.subject.commonname option to true to add the commonname information into the subject. The data are taken from the subject part with the CN key. The escape commonname info in the subject part will be like : CN=*.cheese.com info.subject.serialnumber \u00b6 Set the info.subject.serialnumber option to true to add the serialnumber information into the subject. The data are taken from the subject part with the SN key. The escape serialnumber info in the subject part will be like : SN=1234567890 info.subject.domaincomponent \u00b6 Set the info.subject.domaincomponent option to true to add the domaincomponent information into the subject. The data are taken from the subject part with the DC key. The escape domaincomponent info in the subject part will be like : DC=org,DC=cheese info.issuer \u00b6 The info.issuer select the specific client certificate issuer details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com info.issuer.country \u00b6 Set the info.issuer.country option to true to add the country information into the issuer. The data are taken from the issuer part with the C key. The escape country info in the issuer part will be like : C=FR,C=US info.issuer.province \u00b6 Set the info.issuer.province option to true to add the province information into the issuer. The data are taken from the issuer part with the ST key. The escape province info in the issuer part will be like : ST=Signing State,ST=Signing State 2 info.issuer.locality \u00b6 Set the info.issuer.locality option to true to add the locality information into the issuer. The data are taken from the issuer part with the L key. The escape locality info in the issuer part will be like : L=TOULOUSE,L=LYON info.issuer.organization \u00b6 Set the info.issuer.organization option to true to add the organization information into the issuer. The data are taken from the issuer part with the O key. The escape organization info in the issuer part will be like : O=Cheese,O=Cheese 2 info.issuer.commonname \u00b6 Set the info.issuer.commonname option to true to add the commonname information into the issuer. The data are taken from the issuer part with the CN key. The escape commonname info in the issuer part will be like : CN=Simple Signing CA 2 info.issuer.serialnumber \u00b6 Set the info.issuer.serialnumber option to true to add the serialnumber information into the issuer. The data are taken from the issuer part with the SN key. The escape serialnumber info in the issuer part will be like : SN=1234567890 info.issuer.domaincomponent \u00b6 Set the info.issuer.domaincomponent option to true to add the domaincomponent information into the issuer. The data are taken from the issuer part with the DC key. The escape domaincomponent info in the issuer part will be like : DC=org,DC=cheese","title":"PassTLSClientCert"},{"location":"middlewares/passtlsclientcert/#todo-passtlsclientcert","text":"Adding Client Certificates in a Header TODO add schema PassTLSClientCert adds in header the selected data from the passed client tls certificate.","title":"TODO - PassTLSClientCert"},{"location":"middlewares/passtlsclientcert/#configuration-examples","text":"Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header. Docker # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. labels: - \"traefik.http.middlewares.Middleware11.passtlsclientcert.pem=true\" File # Pass the escaped pem in the `X-Forwarded-Tls-Client-Cert` header. [http.middlewares] [http.middlewares.test-passtlsclientcert.passtlsclientcert] pem = true Pass the escaped pem in the X-Forwarded-Tls-Client-Cert header Docker # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header labels: - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notafter=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.notbefore=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.sans=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject.serialnumber=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.commonname=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.country=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.domaincomponent=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.locality=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.organization=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.province=true\" - \"traefik.http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer.serialnumber=true\" File # Pass all the available info in the `X-Forwarded-Tls-Client-Cert-Info` header [http.middlewares] [http.middlewares.test-passtlsclientcert.passtlsclientcert] [http.middlewares.test-passtlsclientcert.passtlsclientcert.info] notAfter = true notBefore = true sans = true [http.middlewares.test-passtlsclientcert.passtlsclientcert.info.subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.test-passtlsclientcert.passtlsclientcert.info.issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true","title":"Configuration Examples"},{"location":"middlewares/passtlsclientcert/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/passtlsclientcert/#general","text":"PassTLSClientCert can add two headers to the request: X-Forwarded-Tls-Client-Cert that contains the escaped pem. X-Forwarded-Tls-Client-Cert-Info that contains all the selected certificate information in an escaped string. Note The headers are filled with escaped string so it can be safely placed inside a URL query. In the following example, you can see a complete certificate. We will use each part of it to explains the middleware options. A complete client tls certificate Certificate: Data: Version: 3 (0x2) Serial Number: 1 (0x1) Signature Algorithm: sha1WithRSAEncryption Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com Validity Not Before: Dec 6 11:10:16 2018 GMT Not After : Dec 5 11:10:16 2020 GMT Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:de:77:fa:8d:03:70:30:39:dd:51:1b:cc:60:db: a9:5a:13:b1:af:fe:2c:c6:38:9b:88:0a:0f:8e:d9: 1b:a1:1d:af:0d:66:e4:13:5b:bc:5d:36:92:d7:5e: d0:fa:88:29:d3:78:e1:81:de:98:b2:a9:22:3f:bf: 8a:af:12:92:63:d4:a9:c3:f2:e4:7e:d2:dc:a2:c5: 39:1c:7a:eb:d7:12:70:63:2e:41:47:e0:f0:08:e8: dc:be:09:01:ec:28:09:af:35:d7:79:9c:50:35:d1: 6b:e5:87:7b:34:f6:d2:31:65:1d:18:42:69:6c:04: 11:83:fe:44:ae:90:92:2d:0b:75:39:57:62:e6:17: 2f:47:2b:c7:53:dd:10:2d:c9:e3:06:13:d2:b9:ba: 63:2e:3c:7d:83:6b:d6:89:c9:cc:9d:4d:bf:9f:e8: a3:7b:da:c8:99:2b:ba:66:d6:8e:f8:41:41:a0:c9: d0:5e:c8:11:a4:55:4a:93:83:87:63:04:63:41:9c: fb:68:04:67:c2:71:2f:f2:65:1d:02:5d:15:db:2c: d9:04:69:85:c2:7d:0d:ea:3b:ac:85:f8:d4:8f:0f: c5:70:b2:45:e1:ec:b2:54:0b:e9:f7:82:b4:9b:1b: 2d:b9:25:d4:ab:ca:8f:5b:44:3e:15:dd:b8:7f:b7: ee:f9 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Basic Constraints: CA:FALSE X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 Subject Key Identifier: 94:BA:73:78:A2:87:FB:58:28:28:CF:98:3B:C2:45:70:16:6E:29:2F X509v3 Authority Key Identifier: keyid:1E:52:A2:E8:54:D5:37:EB:D5:A8:1D:E4:C2:04:1D:37:E2:F7:70:03 X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net Signature Algorithm: sha1WithRSAEncryption 76:6b:05:b0:0e:34:11:b1:83:99:91:dc:ae:1b:e2:08:15:8b: 16:b2:9b:27:1c:02:ac:b5:df:1b:d0:d0:75:a4:2b:2c:5c:65: ed:99:ab:f7:cd:fe:38:3f:c3:9a:22:31:1b:ac:8c:1c:c2:f9: 5d:d4:75:7a:2e:72:c7:85:a9:04:af:9f:2a:cc:d3:96:75:f0: 8e:c7:c6:76:48:ac:45:a4:b9:02:1e:2f:c0:15:c4:07:08:92: cb:27:50:67:a1:c8:05:c5:3a:b3:a6:48:be:eb:d5:59:ab:a2: 1b:95:30:71:13:5b:0a:9a:73:3b:60:cc:10:d0:6a:c7:e5:d7: 8b:2f:f9:2e:98:f2:ff:81:14:24:09:e3:4b:55:57:09:1a:22: 74:f1:f6:40:13:31:43:89:71:0a:96:1a:05:82:1f:83:3a:87: 9b:17:25:ef:5a:55:f2:2d:cd:0d:4d:e4:81:58:b6:e3:8d:09: 62:9a:0c:bd:e4:e5:5c:f0:95:da:cb:c7:34:2c:34:5f:6d:fc: 60:7b:12:5b:86:fd:df:21:89:3b:48:08:30:bf:67:ff:8c:e6: 9b:53:cc:87:36:47:70:40:3b:d9:90:2a:d2:d2:82:c6:9c:f5: d1:d8:e0:e6:fd:aa:2f:95:7e:39:ac:fc:4e:d4:ce:65:b3:ec: c6:98:8a:31 -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE-----","title":"General"},{"location":"middlewares/passtlsclientcert/#pem","text":"The pem option sets the X-Forwarded-Tls-Client-Cert header with the escape certificate. In the example, it is the part between -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- delimiters : The data used by the pem option -----BEGIN CERTIFICATE----- MIIGWjCCBUKgAwIBAgIBATANBgkqhkiG9w0BAQUFADCCAYQxEzARBgoJkiaJk/Is ZAEZFgNvcmcxFjAUBgoJkiaJk/IsZAEZFgZjaGVlc2UxDzANBgNVBAoMBkNoZWVz ZTERMA8GA1UECgwIQ2hlZXNlIDIxHzAdBgNVBAsMFlNpbXBsZSBTaWduaW5nIFNl Y3Rpb24xITAfBgNVBAsMGFNpbXBsZSBTaWduaW5nIFNlY3Rpb24gMjEaMBgGA1UE AwwRU2ltcGxlIFNpZ25pbmcgQ0ExHDAaBgNVBAMME1NpbXBsZSBTaWduaW5nIENB IDIxCzAJBgNVBAYTAkZSMQswCQYDVQQGEwJVUzERMA8GA1UEBwwIVE9VTE9VU0Ux DTALBgNVBAcMBExZT04xFjAUBgNVBAgMDVNpZ25pbmcgU3RhdGUxGDAWBgNVBAgM D1NpZ25pbmcgU3RhdGUgMjEhMB8GCSqGSIb3DQEJARYSc2ltcGxlQHNpZ25pbmcu Y29tMSIwIAYJKoZIhvcNAQkBFhNzaW1wbGUyQHNpZ25pbmcuY29tMB4XDTE4MTIw NjExMTAxNloXDTIwMTIwNTExMTAxNlowggF2MRMwEQYKCZImiZPyLGQBGRYDb3Jn MRYwFAYKCZImiZPyLGQBGRYGY2hlZXNlMQ8wDQYDVQQKDAZDaGVlc2UxETAPBgNV BAoMCENoZWVzZSAyMR8wHQYDVQQLDBZTaW1wbGUgU2lnbmluZyBTZWN0aW9uMSEw HwYDVQQLDBhTaW1wbGUgU2lnbmluZyBTZWN0aW9uIDIxFTATBgNVBAMMDCouY2hl ZXNlLm9yZzEVMBMGA1UEAwwMKi5jaGVlc2UuY29tMQswCQYDVQQGEwJGUjELMAkG A1UEBhMCVVMxETAPBgNVBAcMCFRPVUxPVVNFMQ0wCwYDVQQHDARMWU9OMRkwFwYD VQQIDBBDaGVlc2Ugb3JnIHN0YXRlMRkwFwYDVQQIDBBDaGVlc2UgY29tIHN0YXRl MR4wHAYJKoZIhvcNAQkBFg9jZXJ0QGNoZWVzZS5vcmcxHzAdBgkqhkiG9w0BCQEW EGNlcnRAc2NoZWVzZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB AQDed/qNA3AwOd1RG8xg26laE7Gv/izGOJuICg+O2RuhHa8NZuQTW7xdNpLXXtD6 iCnTeOGB3piyqSI/v4qvEpJj1KnD8uR+0tyixTkceuvXEnBjLkFH4PAI6Ny+CQHs KAmvNdd5nFA10Wvlh3s09tIxZR0YQmlsBBGD/kSukJItC3U5V2LmFy9HK8dT3RAt yeMGE9K5umMuPH2Da9aJycydTb+f6KN72siZK7pm1o74QUGgydBeyBGkVUqTg4dj BGNBnPtoBGfCcS/yZR0CXRXbLNkEaYXCfQ3qO6yF+NSPD8VwskXh7LJUC+n3grSb Gy25JdSryo9bRD4V3bh/t+75AgMBAAGjgeAwgd0wDgYDVR0PAQH/BAQDAgWgMAkG A1UdEwQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQW BBSUunN4oof7WCgoz5g7wkVwFm4pLzAfBgNVHSMEGDAWgBQeUqLoVNU369WoHeTC BB034vdwAzBhBgNVHREEWjBYggwqLmNoZWVzZS5vcmeCDCouY2hlZXNlLm5ldIIM Ki5jaGVlc2UuY29thwQKAAEAhwQKAAECgQ90ZXN0QGNoZWVzZS5vcmeBD3Rlc3RA Y2hlZXNlLm5ldDANBgkqhkiG9w0BAQUFAAOCAQEAdmsFsA40EbGDmZHcrhviCBWL FrKbJxwCrLXfG9DQdaQrLFxl7Zmr983+OD/DmiIxG6yMHML5XdR1ei5yx4WpBK+f KszTlnXwjsfGdkisRaS5Ah4vwBXEBwiSyydQZ6HIBcU6s6ZIvuvVWauiG5UwcRNb CppzO2DMENBqx+XXiy/5Lpjy/4EUJAnjS1VXCRoidPH2QBMxQ4lxCpYaBYIfgzqH mxcl71pV8i3NDU3kgVi2440JYpoMveTlXPCV2svHNCw0X238YHsSW4b93yGJO0gI ML9n/4zmm1PMhzZHcEA72ZAq0tKCxpz10djg5v2qL5V+Oaz8TtTOZbPsxpiKMQ== -----END CERTIFICATE----- Extracted data The delimiters and \\n will be removed. If there are more than one certificate, they are separated by a \" ; \".","title":"pem"},{"location":"middlewares/passtlsclientcert/#info","text":"The info option select the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The value of the header will be an escaped concatenation of all the selected certificate details. The following example shows an unescaped result that uses all the available fields: Subject=\"DC=org,DC=cheese,C=FR,C=US,ST=Cheese org state,ST=Cheese com state,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=*.cheese.com\",Issuer=\"DC=org,DC=cheese,C=FR,C=US,ST=Signing State,ST=Signing State 2,L=TOULOUSE,L=LYON,O=Cheese,O=Cheese 2,CN=Simple Signing CA 2\",NB=1544094616,NA=1607166616,SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2 Multiple certificates If there are more than one certificate, they are separated by a ; .","title":"info"},{"location":"middlewares/passtlsclientcert/#infonotafter","text":"Set the info.notafter option to true to add the Not After information from the Validity part. The data are taken from the following certificate part: Validity Not After : Dec 5 11:10:16 2020 GMT The escape notafter info part will be like: NA=1607166616","title":"info.notafter"},{"location":"middlewares/passtlsclientcert/#infonotbefore","text":"Set the info.notafter option to true to add the Not Before information from the Validity part. The data are taken from the following certificate part: Validity Not Before: Dec 6 11:10:16 2018 GMT The escape notafter info part will be like: NB=1544094616","title":"info.notbefore"},{"location":"middlewares/passtlsclientcert/#infosans","text":"Set the info.sans option to true to add the Subject Alternative Name information from the Subject Alternative Name part. The data are taken from the following certificate part: X509v3 Subject Alternative Name: DNS:*.cheese.org, DNS:*.cheese.net, DNS:*.cheese.com, IP Address:10.0.1.0, IP Address:10.0.1.2, email:test@cheese.org, email:test@cheese.net The escape SANs info part will be like: SAN=*.cheese.org,*.cheese.net,*.cheese.com,test@cheese.org,test@cheese.net,10.0.1.0,10.0.1.2 multiple values All the SANs data are separated by a , .","title":"info.sans"},{"location":"middlewares/passtlsclientcert/#infosubject","text":"The info.subject select the specific client certificate subject details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Subject: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=*.cheese.org, CN=*.cheese.com, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Cheese org state, ST=Cheese com state/emailAddress=cert@cheese.org/emailAddress=cert@scheese.com","title":"info.subject"},{"location":"middlewares/passtlsclientcert/#infosubjectcountry","text":"Set the info.subject.country option to true to add the country information into the subject. The data are taken from the subject part with the C key. The escape country info in the subject part will be like : C=FR,C=US","title":"info.subject.country"},{"location":"middlewares/passtlsclientcert/#infosubjectprovince","text":"Set the info.subject.province option to true to add the province information into the subject. The data are taken from the subject part with the ST key. The escape province info in the subject part will be like : ST=Cheese org state,ST=Cheese com state","title":"info.subject.province"},{"location":"middlewares/passtlsclientcert/#infosubjectlocality","text":"Set the info.subject.locality option to true to add the locality information into the subject. The data are taken from the subject part with the L key. The escape locality info in the subject part will be like : L=TOULOUSE,L=LYON","title":"info.subject.locality"},{"location":"middlewares/passtlsclientcert/#infosubjectorganization","text":"Set the info.subject.organization option to true to add the organization information into the subject. The data are taken from the subject part with the O key. The escape organization info in the subject part will be like : O=Cheese,O=Cheese 2","title":"info.subject.organization"},{"location":"middlewares/passtlsclientcert/#infosubjectcommonname","text":"Set the info.subject.commonname option to true to add the commonname information into the subject. The data are taken from the subject part with the CN key. The escape commonname info in the subject part will be like : CN=*.cheese.com","title":"info.subject.commonname"},{"location":"middlewares/passtlsclientcert/#infosubjectserialnumber","text":"Set the info.subject.serialnumber option to true to add the serialnumber information into the subject. The data are taken from the subject part with the SN key. The escape serialnumber info in the subject part will be like : SN=1234567890","title":"info.subject.serialnumber"},{"location":"middlewares/passtlsclientcert/#infosubjectdomaincomponent","text":"Set the info.subject.domaincomponent option to true to add the domaincomponent information into the subject. The data are taken from the subject part with the DC key. The escape domaincomponent info in the subject part will be like : DC=org,DC=cheese","title":"info.subject.domaincomponent"},{"location":"middlewares/passtlsclientcert/#infoissuer","text":"The info.issuer select the specific client certificate issuer details you want to add to the X-Forwarded-Tls-Client-Cert-Info header. The data are taken from the following certificate part : Issuer: DC=org, DC=cheese, O=Cheese, O=Cheese 2, OU=Simple Signing Section, OU=Simple Signing Section 2, CN=Simple Signing CA, CN=Simple Signing CA 2, C=FR, C=US, L=TOULOUSE, L=LYON, ST=Signing State, ST=Signing State 2/emailAddress=simple@signing.com/emailAddress=simple2@signing.com","title":"info.issuer"},{"location":"middlewares/passtlsclientcert/#infoissuercountry","text":"Set the info.issuer.country option to true to add the country information into the issuer. The data are taken from the issuer part with the C key. The escape country info in the issuer part will be like : C=FR,C=US","title":"info.issuer.country"},{"location":"middlewares/passtlsclientcert/#infoissuerprovince","text":"Set the info.issuer.province option to true to add the province information into the issuer. The data are taken from the issuer part with the ST key. The escape province info in the issuer part will be like : ST=Signing State,ST=Signing State 2","title":"info.issuer.province"},{"location":"middlewares/passtlsclientcert/#infoissuerlocality","text":"Set the info.issuer.locality option to true to add the locality information into the issuer. The data are taken from the issuer part with the L key. The escape locality info in the issuer part will be like : L=TOULOUSE,L=LYON","title":"info.issuer.locality"},{"location":"middlewares/passtlsclientcert/#infoissuerorganization","text":"Set the info.issuer.organization option to true to add the organization information into the issuer. The data are taken from the issuer part with the O key. The escape organization info in the issuer part will be like : O=Cheese,O=Cheese 2","title":"info.issuer.organization"},{"location":"middlewares/passtlsclientcert/#infoissuercommonname","text":"Set the info.issuer.commonname option to true to add the commonname information into the issuer. The data are taken from the issuer part with the CN key. The escape commonname info in the issuer part will be like : CN=Simple Signing CA 2","title":"info.issuer.commonname"},{"location":"middlewares/passtlsclientcert/#infoissuerserialnumber","text":"Set the info.issuer.serialnumber option to true to add the serialnumber information into the issuer. The data are taken from the issuer part with the SN key. The escape serialnumber info in the issuer part will be like : SN=1234567890","title":"info.issuer.serialnumber"},{"location":"middlewares/passtlsclientcert/#infoissuerdomaincomponent","text":"Set the info.issuer.domaincomponent option to true to add the domaincomponent information into the issuer. The data are taken from the issuer part with the DC key. The escape domaincomponent info in the issuer part will be like : DC=org,DC=cheese","title":"info.issuer.domaincomponent"},{"location":"middlewares/ratelimit/","text":"TODO -- RateLimit \u00b6 Protection from Too Many Calls The RateLimit middleware ensures that services will receive a fair number of requests, and allows you define what is fair. Configuration Example \u00b6 Limit to 100 requests every 10 seconds (with a possible burst of 200) [http.middlewares] [http.middlewares.fair-ratelimit.ratelimit] extractorfunc = \"client.ip\" [http.middlewares.fair-ratelimit.ratelimit.rateset1] period = \"10s\" average = 100 burst = 200 Combine multiple limits [http.middlewares] [http.middlewares.fair-ratelimit.ratelimit] extractorfunc = \"client.ip\" [http.middlewares.fair-ratelimit.ratelimit.rateset1] period = \"10s\" average = 100 burst = 200 [http.middlewares.fair-ratelimit.ratelimit.rateset2] period = \"3s\" average = 5 burst = 10 Here, an average of 5 requests every 3 seconds is allowed and an average of 100 requests every 10 seconds. These can \"burst\" up to 10 and 200 in each period, respectively. Configuration Options \u00b6 extractorfunc \u00b6 The extractorfunc option defines the strategy used to categorize requests. The possible values are: request.host categorizes requests based on the request host. client.ip categorizes requests based on the client ip. request.header.ANY_HEADER categorizes requests based on the provided ANY_HEADER value. ratelimit (multiple values) \u00b6 You can combine multiple ratelimit. The ratelimit will trigger with the first reached limit. Each ratelimit has 3 options, period , average , and burst . The rate limit will allow an average of average requests every period , with a maximum of burst request on that period. Period Format Period is to be given in a format understood by time.ParseDuration .","title":"RateLimit"},{"location":"middlewares/ratelimit/#todo-ratelimit","text":"Protection from Too Many Calls The RateLimit middleware ensures that services will receive a fair number of requests, and allows you define what is fair.","title":"TODO -- RateLimit"},{"location":"middlewares/ratelimit/#configuration-example","text":"Limit to 100 requests every 10 seconds (with a possible burst of 200) [http.middlewares] [http.middlewares.fair-ratelimit.ratelimit] extractorfunc = \"client.ip\" [http.middlewares.fair-ratelimit.ratelimit.rateset1] period = \"10s\" average = 100 burst = 200 Combine multiple limits [http.middlewares] [http.middlewares.fair-ratelimit.ratelimit] extractorfunc = \"client.ip\" [http.middlewares.fair-ratelimit.ratelimit.rateset1] period = \"10s\" average = 100 burst = 200 [http.middlewares.fair-ratelimit.ratelimit.rateset2] period = \"3s\" average = 5 burst = 10 Here, an average of 5 requests every 3 seconds is allowed and an average of 100 requests every 10 seconds. These can \"burst\" up to 10 and 200 in each period, respectively.","title":"Configuration Example"},{"location":"middlewares/ratelimit/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/ratelimit/#extractorfunc","text":"The extractorfunc option defines the strategy used to categorize requests. The possible values are: request.host categorizes requests based on the request host. client.ip categorizes requests based on the client ip. request.header.ANY_HEADER categorizes requests based on the provided ANY_HEADER value.","title":"extractorfunc"},{"location":"middlewares/ratelimit/#ratelimit-multiple-values","text":"You can combine multiple ratelimit. The ratelimit will trigger with the first reached limit. Each ratelimit has 3 options, period , average , and burst . The rate limit will allow an average of average requests every period , with a maximum of burst request on that period. Period Format Period is to be given in a format understood by time.ParseDuration .","title":"ratelimit (multiple values)"},{"location":"middlewares/redirectregex/","text":"TODO - RedirectRegex \u00b6 Redirecting the Client to a Different Location TODO: add schema RegexRedirect redirect a request from an url to another with regex matching and replacement. Configuration Examples \u00b6 File -- Redirect with domain replacement [http.middlewares] [http.middlewares.test-redirectregex.redirectregex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/$1\" Docker -- Redirect with domain replacement a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$1\" Configuration Options \u00b6 permanent \u00b6 Set the permanent option to true to apply a permanent redirection. regex \u00b6 The Regex option is the regular expression to match and capture elements form the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 . replacement \u00b6 The replacement option defines how to modify the URl to have the new target URL.","title":"RedirectRegex"},{"location":"middlewares/redirectregex/#todo-redirectregex","text":"Redirecting the Client to a Different Location TODO: add schema RegexRedirect redirect a request from an url to another with regex matching and replacement.","title":"TODO - RedirectRegex"},{"location":"middlewares/redirectregex/#configuration-examples","text":"File -- Redirect with domain replacement [http.middlewares] [http.middlewares.test-redirectregex.redirectregex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/$1\" Docker -- Redirect with domain replacement a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-redirectregex.redirectregex.regex=^http://localhost/(.*)\" - \"traefik.http.middlewares.test-redirectregex.redirectregex.replacement=http://mydomain/$1\"","title":"Configuration Examples"},{"location":"middlewares/redirectregex/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/redirectregex/#permanent","text":"Set the permanent option to true to apply a permanent redirection.","title":"permanent"},{"location":"middlewares/redirectregex/#regex","text":"The Regex option is the regular expression to match and capture elements form the request URL. Warning Care should be taken when defining replacement expand variables: $1x is equivalent to ${1x} , not ${1}x (see Regexp.Expand ), so use ${1} syntax. Tip Regular expressions and replacements can be tested using online tools such as Go Playground or the Regex101 .","title":"regex"},{"location":"middlewares/redirectregex/#replacement","text":"The replacement option defines how to modify the URl to have the new target URL.","title":"replacement"},{"location":"middlewares/redirectscheme/","text":"TODO - RedirectScheme \u00b6 Redirecting the Client to a Different Scheme/Port TODO: add schema RegexRedirect redirect request from a scheme to another. Configuration Examples \u00b6 File -- Redirect to https [http.middlewares] [http.middlewares.test-redirectscheme.redirectscheme] scheme = \"https\" Docker -- Redirect to https a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\" Configuration Options \u00b6 permanent \u00b6 Set the permanent option to true to apply a permanent redirection. scheme \u00b6 The scheme option defines the scheme of the new url. port \u00b6 The port option defines the port of the new url.","title":"RedirectScheme"},{"location":"middlewares/redirectscheme/#todo-redirectscheme","text":"Redirecting the Client to a Different Scheme/Port TODO: add schema RegexRedirect redirect request from a scheme to another.","title":"TODO - RedirectScheme"},{"location":"middlewares/redirectscheme/#configuration-examples","text":"File -- Redirect to https [http.middlewares] [http.middlewares.test-redirectscheme.redirectscheme] scheme = \"https\" Docker -- Redirect to https a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-redirectscheme.redirectscheme.scheme=https\"","title":"Configuration Examples"},{"location":"middlewares/redirectscheme/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/redirectscheme/#permanent","text":"Set the permanent option to true to apply a permanent redirection.","title":"permanent"},{"location":"middlewares/redirectscheme/#scheme","text":"The scheme option defines the scheme of the new url.","title":"scheme"},{"location":"middlewares/redirectscheme/#port","text":"The port option defines the port of the new url.","title":"port"},{"location":"middlewares/replacepath/","text":"TODO -- ReplacePath \u00b6 Updating the Path Before Forwarding the Request TODO: add schema Replace the path of the request url. Configuration Examples \u00b6 File -- Replace the path by /foo [http.middlewares] [http.middlewares.test-replacepath.ReplacePath] path = \"/foo\" Docker --Replace the path by /foo a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\" Configuration Options \u00b6 General \u00b6 The ReplacePath middleware will: replace the actual path by the specified one. store the original path in a X-Replaced-Path header. path \u00b6 The path option defines the path to use as replacement in the request url.","title":"ReplacePath"},{"location":"middlewares/replacepath/#todo-replacepath","text":"Updating the Path Before Forwarding the Request TODO: add schema Replace the path of the request url.","title":"TODO -- ReplacePath"},{"location":"middlewares/replacepath/#configuration-examples","text":"File -- Replace the path by /foo [http.middlewares] [http.middlewares.test-replacepath.ReplacePath] path = \"/foo\" Docker --Replace the path by /foo a-container: image: a-container-image labels: - \"traefik.http.middlewares.test-replacepath.replacepath.path=/foo\"","title":"Configuration Examples"},{"location":"middlewares/replacepath/#configuration-options","text":"","title":"Configuration Options"},{"location":"middlewares/replacepath/#general","text":"The ReplacePath middleware will: replace the actual path by the specified one. store the original path in a X-Replaced-Path header.","title":"General"},{"location":"middlewares/replacepath/#path","text":"The path option defines the path to use as replacement in the request url.","title":"path"},{"location":"middlewares/replacepathregex/","text":"TODO -- ReplacePathRegex \u00b6 Updating the Path Before Forwarding the Request (Using a Regex)","title":"ReplacePathRegex"},{"location":"middlewares/replacepathregex/#todo-replacepathregex","text":"Updating the Path Before Forwarding the Request (Using a Regex)","title":"TODO -- ReplacePathRegex"},{"location":"middlewares/retry/","text":"TODO -- Retry \u00b6 Retrying until it Succeeds Old Content \u00b6 Retry Configuration \u00b6 # Enable retry sending request if network error [retry] # Number of attempts # # Optional # Default: (number servers in backend) -1 # # attempts = 3","title":"Retry"},{"location":"middlewares/retry/#todo-retry","text":"Retrying until it Succeeds","title":"TODO -- Retry"},{"location":"middlewares/retry/#old-content","text":"","title":"Old Content"},{"location":"middlewares/retry/#retry-configuration","text":"# Enable retry sending request if network error [retry] # Number of attempts # # Optional # Default: (number servers in backend) -1 # # attempts = 3","title":"Retry Configuration"},{"location":"middlewares/stripprefix/","text":"TODO -- StripPrefix \u00b6 Removing Prefixes From the Path Before Forwarding the Request OldContent \u00b6 Use a *Strip matcher if your backend listens on the root path ( / ) but should be routeable on a specific prefix. For instance, PathPrefixStrip: /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header (available since Traefik 1.3) can be queried to build such URLs dynamically.","title":"StripPrefix"},{"location":"middlewares/stripprefix/#todo-stripprefix","text":"Removing Prefixes From the Path Before Forwarding the Request","title":"TODO -- StripPrefix"},{"location":"middlewares/stripprefix/#oldcontent","text":"Use a *Strip matcher if your backend listens on the root path ( / ) but should be routeable on a specific prefix. For instance, PathPrefixStrip: /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header (available since Traefik 1.3) can be queried to build such URLs dynamically.","title":"OldContent"},{"location":"middlewares/stripprefixregex/","text":"TODO -- StripPrefix \u00b6 Removing Prefixes From the Path Before Forwarding the Request (Using a Regex) OldContent \u00b6 Use a *Strip matcher if your backend listens on the root path ( / ) but should be routeable on a specific prefix. For instance, PathPrefixStrip: /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header (available since Traefik 1.3) can be queried to build such URLs dynamically.","title":"StripPrefixRegex"},{"location":"middlewares/stripprefixregex/#todo-stripprefix","text":"Removing Prefixes From the Path Before Forwarding the Request (Using a Regex)","title":"TODO -- StripPrefix"},{"location":"middlewares/stripprefixregex/#oldcontent","text":"Use a *Strip matcher if your backend listens on the root path ( / ) but should be routeable on a specific prefix. For instance, PathPrefixStrip: /products would match /products but also /products/shoes and /products/shirts . Since the path is stripped prior to forwarding, your backend is expected to listen on / . If your backend is serving assets (e.g., images or Javascript files), chances are it must return properly constructed relative URLs. Continuing on the example, the backend should return /products/shoes/image.png (and not /images.png which Traefik would likely not be able to associate with the same backend). The X-Forwarded-Prefix header (available since Traefik 1.3) can be queried to build such URLs dynamically.","title":"OldContent"},{"location":"observability/access-logs/","text":"Access Logs \u00b6 Who Calls Whom? By default, logs are written to stdout, in text format. Configuration Examples \u00b6 Enabling Access Logs [accessLog] Configuration Options \u00b6 filePath \u00b6 By default access logs are written to the standard output. To write the logs into a log file, use the filePath option. in the Common Log Format (CLF), extended with additional fields. format \u00b6 By default, logs are written using the Common Log Format (CLF). To write logs in JSON, use json in the format option. Common Log Format CLF - Common Log Format \u00b6 ```html <remote_IP_address> - <client_user_name_if_available> [<timestamp>] \"<request_method> <request_path> <request_protocol>\" <origin_server_HTTP_status> <origin_server_content_size> \"<request_referrer>\" \"<request_user_agent>\" <number_of_requests_received_since_Traefik_started> \"<Traefik_frontend_name>\" \"<Traefik_backend_URL>\" <request_duration_in_ms>ms ``` bufferingSize \u00b6 To write the logs in an asynchronous fashion, specify a bufferingSize option. This option represents the number of log lines Traefik will keep in memory before writing them to the selected output. In some cases, this option can greatly help performances. Configuring a buffer of 100 lines [accessLog] filePath = \"/path/to/access.log\" bufferingSize = 100 Filtering \u00b6 To filter logs, you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one. The available filters are: statusCodes , to limit the access logs to requests with a status codes in the specified range retryAttempts , to keep the access logs when at least one retry has happened minDuration , to keep access logs when requests take longer than the specified duration Configuring Multiple Filters [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\" Limiting the Fields \u00b6 You can decide to limit the logged fields/headers to a given list with the fields.names and fields.header options Each field can be set to: keep to keep the value drop to drop the value redact to replace the value with \"redacted\" Limiting the Logs to Specific Fields [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" Available Fields StartUTC StartLocal Duration FrontendName BackendName BackendURL BackendAddr ClientAddr ClientHost ClientPort ClientUsername RequestAddr RequestHost RequestPort RequestMethod RequestPath RequestProtocol RequestLine RequestContentSize OriginDuration OriginContentSize OriginStatus OriginStatusLine DownstreamStatus DownstreamStatusLine DownstreamContentSize RequestCount GzipRatio Overhead RetryAttempts Log Rotation \u00b6 Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Note This does not work on Windows due to the lack of USR signals.","title":"Access Logs"},{"location":"observability/access-logs/#access-logs","text":"Who Calls Whom? By default, logs are written to stdout, in text format.","title":"Access Logs"},{"location":"observability/access-logs/#configuration-examples","text":"Enabling Access Logs [accessLog]","title":"Configuration Examples"},{"location":"observability/access-logs/#configuration-options","text":"","title":"Configuration Options"},{"location":"observability/access-logs/#filepath","text":"By default access logs are written to the standard output. To write the logs into a log file, use the filePath option. in the Common Log Format (CLF), extended with additional fields.","title":"filePath"},{"location":"observability/access-logs/#format","text":"By default, logs are written using the Common Log Format (CLF). To write logs in JSON, use json in the format option. Common Log Format","title":"format"},{"location":"observability/access-logs/#clf-common-log-format","text":"```html <remote_IP_address> - <client_user_name_if_available> [<timestamp>] \"<request_method> <request_path> <request_protocol>\" <origin_server_HTTP_status> <origin_server_content_size> \"<request_referrer>\" \"<request_user_agent>\" <number_of_requests_received_since_Traefik_started> \"<Traefik_frontend_name>\" \"<Traefik_backend_URL>\" <request_duration_in_ms>ms ```","title":"CLF - Common Log Format"},{"location":"observability/access-logs/#bufferingsize","text":"To write the logs in an asynchronous fashion, specify a bufferingSize option. This option represents the number of log lines Traefik will keep in memory before writing them to the selected output. In some cases, this option can greatly help performances. Configuring a buffer of 100 lines [accessLog] filePath = \"/path/to/access.log\" bufferingSize = 100","title":"bufferingSize"},{"location":"observability/access-logs/#filtering","text":"To filter logs, you can specify a set of filters which are logically \"OR-connected\". Thus, specifying multiple filters will keep more access logs than specifying only one. The available filters are: statusCodes , to limit the access logs to requests with a status codes in the specified range retryAttempts , to keep the access logs when at least one retry has happened minDuration , to keep access logs when requests take longer than the specified duration Configuring Multiple Filters [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\"","title":"Filtering"},{"location":"observability/access-logs/#limiting-the-fields","text":"You can decide to limit the logged fields/headers to a given list with the fields.names and fields.header options Each field can be set to: keep to keep the value drop to drop the value redact to replace the value with \"redacted\" Limiting the Logs to Specific Fields [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" Available Fields StartUTC StartLocal Duration FrontendName BackendName BackendURL BackendAddr ClientAddr ClientHost ClientPort ClientUsername RequestAddr RequestHost RequestPort RequestMethod RequestPath RequestProtocol RequestLine RequestContentSize OriginDuration OriginContentSize OriginStatus OriginStatusLine DownstreamStatus DownstreamStatusLine DownstreamContentSize RequestCount GzipRatio Overhead RetryAttempts","title":"Limiting the Fields"},{"location":"observability/access-logs/#log-rotation","text":"Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Note This does not work on Windows due to the lack of USR signals.","title":"Log Rotation"},{"location":"observability/logs/","text":"Logs \u00b6 Reading What's Happening By default, logs are written to stdout, in text format. Configuration Example \u00b6 Writing Logs in a File [log] filePath = \"/path/to/traefik.log\" Writing Logs in a File, in JSON [log] filePath = \"/path/to/log-file.log\" format = \"json\" Configuration Options \u00b6 General \u00b6 Traefik logs concern everything that happens to Traefik itself (startup, configuration, events, shutdown, and so on). filePath \u00b6 By default, the logs are written to the standard output. You can configure a file path instead using the filePath option. format \u00b6 By default, the logs use a text format ( common ), but you can also ask for the json format in the format option. logLevel \u00b6 By default, the logLevel is set to error , but you can choose amongst debug , panic , fatal , error , warn , and info . Log Rotation \u00b6 Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Note This does not work on Windows due to the lack of USR signals.","title":"Logs"},{"location":"observability/logs/#logs","text":"Reading What's Happening By default, logs are written to stdout, in text format.","title":"Logs"},{"location":"observability/logs/#configuration-example","text":"Writing Logs in a File [log] filePath = \"/path/to/traefik.log\" Writing Logs in a File, in JSON [log] filePath = \"/path/to/log-file.log\" format = \"json\"","title":"Configuration Example"},{"location":"observability/logs/#configuration-options","text":"","title":"Configuration Options"},{"location":"observability/logs/#general","text":"Traefik logs concern everything that happens to Traefik itself (startup, configuration, events, shutdown, and so on).","title":"General"},{"location":"observability/logs/#filepath","text":"By default, the logs are written to the standard output. You can configure a file path instead using the filePath option.","title":"filePath"},{"location":"observability/logs/#format","text":"By default, the logs use a text format ( common ), but you can also ask for the json format in the format option.","title":"format"},{"location":"observability/logs/#loglevel","text":"By default, the logLevel is set to error , but you can choose amongst debug , panic , fatal , error , warn , and info .","title":"logLevel"},{"location":"observability/logs/#log-rotation","text":"Traefik will close and reopen its log files, assuming they're configured, on receipt of a USR1 signal. This allows the logs to be rotated and processed by an external program, such as logrotate . Note This does not work on Windows due to the lack of USR signals.","title":"Log Rotation"},{"location":"observability/tracing/","text":"Tracing \u00b6 Visualize the Requests Flow The tracing system allows developers to visualize call flows in their infrastructure. Traefik uses OpenTracing, an open standard designed for distributed tracing. Traefik supports three tracing backends: Jaeger, Zipkin, DataDog, and Instana. Configuration Reference \u00b6 With Jaeger # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"jaeger\" # Service name used in Jaeger backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 0 [tracing.jaeger] # Sampling Server URL is the address of jaeger-agent's HTTP sampling server # # Default: \"http://localhost:5778/sampling\" # samplingServerURL = \"http://localhost:5778/sampling\" # Sampling Type specifies the type of the sampler: const, probabilistic, rateLimiting # # Default: \"const\" # samplingType = \"const\" # Sampling Param is a value passed to the sampler. # Valid values for Param field are: # - for \"const\" sampler, 0 or 1 for always false/true respectively # - for \"probabilistic\" sampler, a probability between 0 and 1 # - for \"rateLimiting\" sampler, the number of spans per second # # Default: 1.0 # samplingParam = 1.0 # Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address # # Default: \"127.0.0.1:6831\" # localAgentHostPort = \"127.0.0.1:6831\" # Generate 128-bit trace IDs, compatible with OpenCensus # # Default: false gen128Bit = true # Set the propagation header type. This can be either: # - \"jaeger\", jaeger's default trace header. # - \"b3\", compatible with OpenZipkin # # Default: \"jaeger\" propagation = \"jaeger\" # Trace Context Header Name is the http header name used to propagate tracing context. # This must be in lower-case to avoid mismatches when decoding incoming headers. # # Default: \"uber-trace-id\" # traceContextHeaderName = \"uber-trace-id\" Warning Traefik is only able to send data over the compact thrift protocol to the Jaeger agent . With Zipkin # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"zipkin\" # Service name used in Zipkin backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 150 [tracing.zipkin] # Zipkin HTTP endpoint used to send data # # Default: \"http://localhost:9411/api/v1/spans\" # httpEndpoint = \"http://localhost:9411/api/v1/spans\" # Enable Zipkin debug # # Default: false # debug = false # Use Zipkin SameSpan RPC style traces # # Default: false # sameSpan = false # Use Zipkin 128 bit root span IDs # # Default: true # id128Bit = true # The rate between 0.0 and 1.0 of requests to trace. # # Default: 1.0 # sampleRate = 0.2 With DataDog # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"datadog\" # Service name used in DataDog backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 100 [tracing.datadog] # Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address # # Default: \"127.0.0.1:8126\" # localAgentHostPort = \"127.0.0.1:8126\" # Enable DataDog debug # # Default: false # debug = false # Apply shared tag in a form of Key:Value to all the traces # # Default: \"\" # globalTag = \"\" # Enable priority sampling. When using distributed tracing, this option must be enabled in order # to get all the parts of a distributed trace sampled. # # Default: false # prioritySampling = false With Instana # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"instana\" # Service name used in Instana backend # # Default: \"traefik\" # serviceName = \"traefik\" [tracing.instana] # Local Agent Host instructs reporter to send spans to instana-agent at this address # # Default: \"127.0.0.1\" # localAgentHost = \"127.0.0.1\" # Local Agent port instructs reporter to send spans to the instana-agent at this port # # Default: 42699 # localAgentPort = 42699 # Set Instana tracer log level # # Default: info # Valid values for logLevel field are: # - error # - warn # - debug # - info # logLevel = \"info\"","title":"Tracing"},{"location":"observability/tracing/#tracing","text":"Visualize the Requests Flow The tracing system allows developers to visualize call flows in their infrastructure. Traefik uses OpenTracing, an open standard designed for distributed tracing. Traefik supports three tracing backends: Jaeger, Zipkin, DataDog, and Instana.","title":"Tracing"},{"location":"observability/tracing/#configuration-reference","text":"With Jaeger # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"jaeger\" # Service name used in Jaeger backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 0 [tracing.jaeger] # Sampling Server URL is the address of jaeger-agent's HTTP sampling server # # Default: \"http://localhost:5778/sampling\" # samplingServerURL = \"http://localhost:5778/sampling\" # Sampling Type specifies the type of the sampler: const, probabilistic, rateLimiting # # Default: \"const\" # samplingType = \"const\" # Sampling Param is a value passed to the sampler. # Valid values for Param field are: # - for \"const\" sampler, 0 or 1 for always false/true respectively # - for \"probabilistic\" sampler, a probability between 0 and 1 # - for \"rateLimiting\" sampler, the number of spans per second # # Default: 1.0 # samplingParam = 1.0 # Local Agent Host Port instructs reporter to send spans to jaeger-agent at this address # # Default: \"127.0.0.1:6831\" # localAgentHostPort = \"127.0.0.1:6831\" # Generate 128-bit trace IDs, compatible with OpenCensus # # Default: false gen128Bit = true # Set the propagation header type. This can be either: # - \"jaeger\", jaeger's default trace header. # - \"b3\", compatible with OpenZipkin # # Default: \"jaeger\" propagation = \"jaeger\" # Trace Context Header Name is the http header name used to propagate tracing context. # This must be in lower-case to avoid mismatches when decoding incoming headers. # # Default: \"uber-trace-id\" # traceContextHeaderName = \"uber-trace-id\" Warning Traefik is only able to send data over the compact thrift protocol to the Jaeger agent . With Zipkin # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"zipkin\" # Service name used in Zipkin backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 150 [tracing.zipkin] # Zipkin HTTP endpoint used to send data # # Default: \"http://localhost:9411/api/v1/spans\" # httpEndpoint = \"http://localhost:9411/api/v1/spans\" # Enable Zipkin debug # # Default: false # debug = false # Use Zipkin SameSpan RPC style traces # # Default: false # sameSpan = false # Use Zipkin 128 bit root span IDs # # Default: true # id128Bit = true # The rate between 0.0 and 1.0 of requests to trace. # # Default: 1.0 # sampleRate = 0.2 With DataDog # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"datadog\" # Service name used in DataDog backend # # Default: \"traefik\" # serviceName = \"traefik\" # Span name limit allows for name truncation in case of very long Frontend/Backend names # This can prevent certain tracing providers to drop traces that exceed their length limits # # Default: 0 - no truncation will occur # spanNameLimit = 100 [tracing.datadog] # Local Agent Host Port instructs reporter to send spans to datadog-tracing-agent at this address # # Default: \"127.0.0.1:8126\" # localAgentHostPort = \"127.0.0.1:8126\" # Enable DataDog debug # # Default: false # debug = false # Apply shared tag in a form of Key:Value to all the traces # # Default: \"\" # globalTag = \"\" # Enable priority sampling. When using distributed tracing, this option must be enabled in order # to get all the parts of a distributed trace sampled. # # Default: false # prioritySampling = false With Instana # Tracing definition [tracing] # Backend name used to send tracing data # # Default: \"jaeger\" # backend = \"instana\" # Service name used in Instana backend # # Default: \"traefik\" # serviceName = \"traefik\" [tracing.instana] # Local Agent Host instructs reporter to send spans to instana-agent at this address # # Default: \"127.0.0.1\" # localAgentHost = \"127.0.0.1\" # Local Agent port instructs reporter to send spans to the instana-agent at this port # # Default: 42699 # localAgentPort = 42699 # Set Instana tracer log level # # Default: info # Valid values for logLevel field are: # - error # - warn # - debug # - info # logLevel = \"info\"","title":"Configuration Reference"},{"location":"operations/cli/","text":"CLI \u00b6 The Traefik Command Line General \u00b6 traefik [command] [--flag=flag_argument] Available commands: version : Print version storeconfig : Store the static Traefik configuration into a Key-value stores. Please refer to the Store Traefik configuration (TODO: add doc and link) section to get documentation on it. healthcheck : Calls Traefik /ping to check health. Each command can have additional flags. All those flags will be displayed with: traefik [command] --help Each command is described at the beginning of the help section: traefik --help # or docker run traefik[:version] --help # ex: docker run traefik:1.5 --help Command: healthcheck \u00b6 Checks the health of Traefik. Its exit status is 0 if Traefik is healthy and 1 if it is unhealthy. This can be used with Docker HEALTHCHECK instruction or any other health check orchestration mechanism. Note The ping endpoint must be enabled to allow the healthcheck command to call /ping . traefik healthcheck OK: http://:8082/ping","title":"CLI"},{"location":"operations/cli/#cli","text":"The Traefik Command Line","title":"CLI"},{"location":"operations/cli/#general","text":"traefik [command] [--flag=flag_argument] Available commands: version : Print version storeconfig : Store the static Traefik configuration into a Key-value stores. Please refer to the Store Traefik configuration (TODO: add doc and link) section to get documentation on it. healthcheck : Calls Traefik /ping to check health. Each command can have additional flags. All those flags will be displayed with: traefik [command] --help Each command is described at the beginning of the help section: traefik --help # or docker run traefik[:version] --help # ex: docker run traefik:1.5 --help","title":"General"},{"location":"operations/cli/#command-healthcheck","text":"Checks the health of Traefik. Its exit status is 0 if Traefik is healthy and 1 if it is unhealthy. This can be used with Docker HEALTHCHECK instruction or any other health check orchestration mechanism. Note The ping endpoint must be enabled to allow the healthcheck command to call /ping . traefik healthcheck OK: http://:8082/ping","title":"Command: healthcheck"},{"location":"operations/dashboard/","text":"The Dashboard \u00b6 See What's Going On The dashboard is the central place that shows you the current active routes handled by Traefik. Dashboard WIP Currently, the dashboard is in a Work In Progress State while being reconstructed for v2. Therefore, the dashboard is currently not working. The dashboard in action with Traefik listening to 3 different providers The dashboard shows the health of the system. By default, the dashboard is available on / on port :8080 . Did You Know? It is possible to customize the dashboard endpoint. To learn how, refer to the Traefik's API documentation (TODO: add doc and link). Enabling the Dashboard \u00b6 To enable the dashboard, you need to enable Traefik's API. Using the Command Line Option Values Default Value --api [true|false] false --api.dashboard [true|false] true when api is true To learn more about configuration options in the command line, refer to the configuration overview Using the Configuration File [api] # Dashboard # # Optional # Default: true # dashboard = true To learn more about the configuration file, refer to configuration overview Using a Key/Value Store Key Values Default Value api [true|false] false api.dashboard [true|false] true when api is true To learn more about configuration in key-value stores, refer to the configuration overview Did You Know? The API provides more features than the Dashboard. To learn more about it, refer to the Traefik's API documentation (TODO: add doc and link).","title":"Dashboard"},{"location":"operations/dashboard/#the-dashboard","text":"See What's Going On The dashboard is the central place that shows you the current active routes handled by Traefik. Dashboard WIP Currently, the dashboard is in a Work In Progress State while being reconstructed for v2. Therefore, the dashboard is currently not working. The dashboard in action with Traefik listening to 3 different providers The dashboard shows the health of the system. By default, the dashboard is available on / on port :8080 . Did You Know? It is possible to customize the dashboard endpoint. To learn how, refer to the Traefik's API documentation (TODO: add doc and link).","title":"The Dashboard"},{"location":"operations/dashboard/#enabling-the-dashboard","text":"To enable the dashboard, you need to enable Traefik's API. Using the Command Line Option Values Default Value --api [true|false] false --api.dashboard [true|false] true when api is true To learn more about configuration options in the command line, refer to the configuration overview Using the Configuration File [api] # Dashboard # # Optional # Default: true # dashboard = true To learn more about the configuration file, refer to configuration overview Using a Key/Value Store Key Values Default Value api [true|false] false api.dashboard [true|false] true when api is true To learn more about configuration in key-value stores, refer to the configuration overview Did You Know? The API provides more features than the Dashboard. To learn more about it, refer to the Traefik's API documentation (TODO: add doc and link).","title":"Enabling the Dashboard"},{"location":"operations/debug-mode/","text":"The Debug Mode \u00b6 Getting More Information (Not For Production) The debug mode will make Traefik be extremely verbose in its logs, and is NOT intended for production purposes. Configuration Example \u00b6 TOML -- Enabling the Debug Mode [Global] debug = true","title":"Debug Mode"},{"location":"operations/debug-mode/#the-debug-mode","text":"Getting More Information (Not For Production) The debug mode will make Traefik be extremely verbose in its logs, and is NOT intended for production purposes.","title":"The Debug Mode"},{"location":"operations/debug-mode/#configuration-example","text":"TOML -- Enabling the Debug Mode [Global] debug = true","title":"Configuration Example"},{"location":"operations/ping/","text":"Ping \u00b6 Checking the Health of Your Traefik Instances Configuration Examples \u00b6 Enabling /ping [ping] Enabling /ping on a dedicated EntryPoint [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.ping] address = \":8082\" [ping] entryPoint = \"ping\" Path Method Description /ping GET , HEAD A simple endpoint to check for Traefik process liveness. Return a code 200 with the content: OK Configuration Options \u00b6 The /ping health-check URL is enabled with the command-line --ping or config file option [ping] . You can customize the entryPoint where the /ping is active with the entryPoint option (default value: traefik )","title":"Ping"},{"location":"operations/ping/#ping","text":"Checking the Health of Your Traefik Instances","title":"Ping"},{"location":"operations/ping/#configuration-examples","text":"Enabling /ping [ping] Enabling /ping on a dedicated EntryPoint [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.ping] address = \":8082\" [ping] entryPoint = \"ping\" Path Method Description /ping GET , HEAD A simple endpoint to check for Traefik process liveness. Return a code 200 with the content: OK","title":"Configuration Examples"},{"location":"operations/ping/#configuration-options","text":"The /ping health-check URL is enabled with the command-line --ping or config file option [ping] . You can customize the entryPoint where the /ping is active with the entryPoint option (default value: traefik )","title":"Configuration Options"},{"location":"providers/docker/","text":"Traefik & Docker \u00b6 A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest! The Quick Start Uses Docker If you haven't already, maybe you'd like to go through the quick start that uses the docker provider! Configuration Examples \u00b6 Configuring Docker & Deploying / Exposing Services Enabling the docker provider [providers.docker] endpoint = \"unix:///var/run/docker.sock\" Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`my-domain`) Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) [docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`my-domain`) Labels in Docker Swarm Mode If you use a compose file with the Swarm mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ). Provider Configuration Options \u00b6 Browse the Reference If you're in a hurry, maybe you'd rather go through the Docker Reference . endpoint \u00b6 Traefik requires access to the docker socket to get its dynamic configuration. Security Notes Depending on your context, accessing the Docker API without any restriction can be a security concern: If Traefik is attacked, then the attacker might get access to the Docker (or Swarm Mode) backend. As explained in the Docker documentation: ( Docker Daemon Attack Surface page ): [...] only **trusted** users should be allowed to control your Docker daemon [...] Improved Security TraefikEE solves this problem by separating the control plane (connected to Docker) and the data plane (handling the requests). Resources about Docker's Security KubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice Don't expose the Docker socket (not even to a container) A thread on Stack Overflow about sharing the /var/run/docker.sock file To Dind or not to DinD Security Compensation Expose the Docker socket over TCP, instead of the default Unix socket file. It allows different implementation levels of the AAA (Authentication, Authorization, Accounting) concepts , depending on your security assessment: Authentication with Client Certificates as described in \"Protect the Docker daemon socket.\" Authorization with the Docker Authorization Plugin Mechanism Accounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik. Accounting at container level, by exposing the socket on a another container than Traefik's. With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes. Accounting at kernel level, by enforcing kernel calls with mechanisms like SELinux , to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process). Additional Resources Traefik issue GH-4174 about security with Docker socket Inspecting Docker Activity with Socat Letting Traefik run on Worker Nodes Docker Socket Proxy from Tecnativa Traefik & Swarm Mode To let Traefik access the Docker Socket of the Swarm manager, it is mandatory to schedule Traefik on the Swarm manager nodes. Using the docker.sock The docker-compose file shares the docker sock with the Traefik container version: '3' services: traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image ports: - \"80:80\" volumes: - /var/run/docker.sock:/var/run/docker.sock We specify the docker.sock in traefik's configuration file. # ... [providers] [providers.docker] endpoint = \"unix:///var/run/docker.sock\" usebindportip ( Optional , Default=false ) \u00b6 Traefik routes requests to the IP/Port of the matching container. When setting usebindportip=true , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port. When used in conjunction with the traefik.port label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port traefik.port . If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the traefik.port that is set in the label. Examples of usebindportip in different situations. traefik.port label Container's binding Routes to - - IntIP:IntPort - ExtPort:IntPort IntIP:IntPort - ExtIp:ExtPort:IntPort ExtIp:ExtPort LblPort - IntIp:LblPort LblPort ExtIp:ExtPort:LblPort ExtIp:ExtPort LblPort ExtIp:ExtPort:OtherPort IntIp:LblPort LblPort ExtIp1:ExtPort1:IntPort1 & ExtIp2:LblPort:IntPort2 ExtIp2:LblPort Note In the above table, ExtIp stands for \"external IP found in the binding\", IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\", and IntPort stands for \"internal network container's port.\" exposedByDefault ( Optional , Default=true ) \u00b6 Expose containers by default through Traefik. If set to false, containers that don't have a traefik.enable=true label will be ignored from the resulting routing configuration. network ( Optional ) \u00b6 Defines a default docker network to use for connections to all containers. This option can be overridden on a container basis with the traefik.docker.network label. domain ( Optional , Default=docker.localhost ) \u00b6 This is the default base domain used for the router rules. This option can be overridden on a container basis with the traefik.domain label. swarmMode ( Optional , Default=false ) \u00b6 Activates the Swarm Mode. swarmModeRefreshSeconds ( Optional , Default=15 ) \u00b6 Defines the polling interval (in seconds) in Swarm Mode. Routing Configuration Options \u00b6 General \u00b6 Traefik creates, for each container, a corresponding service and router . The Service automatically gets a server per instance of the container, and the router gets a default rule attached to it, based on the container name. Routers \u00b6 To update the configuration of the Router automatically attached to the container, add labels starting with traefik.routers.{name-of-your-choice}. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(my-domain) . Every Router parameter can be updated this way. Services \u00b6 To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{name-of-your-choice}. , followed by the option you want to change. For example, to change the load balancer method, you'd add the label traefik.http.services.{name-of-your-choice}.loadbalancer.method=drr . Every Service parameter can be updated this way. Middleware \u00b6 You can declare pieces of middleware using labels starting with traefik.http.middlewares.{name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware schemeredirect named my-redirect , you'd write traefik.http.middlewares.my-redirect.schemeredirect.scheme: https . Declaring and Referencing a Middleware services: my-container: # ... labels: - traefik.http.middlewares.my-redirect.schemeredirect.scheme=https - traefik.http.routers.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared. TCP \u00b6 You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - traefik.tcp.routers.my-router.rule=\"HostSNI(`my-host.com`)\" - traefik.tcp.routers.my-router.rule.tls=\"true\" - traefik.tcp.services.my-service.loadbalancer.server.port=\"4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically create an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually). Specific Options \u00b6 traefik.enable \u00b6 You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault . traefik.tags \u00b6 Sets the tags for constraints filtering . traefik.docker.network \u00b6 Overrides the default docker network to use for connections to the container. If a container is linked to several networks, be sure to set the proper network name (you can check this with docker inspect <container_id> ), otherwise it will randomly pick one (depending on how docker is returning them). Warning When deploying a stack from a compose file stack , the networks defined are prefixed with stack .","title":"Docker"},{"location":"providers/docker/#traefik-docker","text":"A Story of Labels & Containers Attach labels to your containers and let Traefik do the rest! The Quick Start Uses Docker If you haven't already, maybe you'd like to go through the quick start that uses the docker provider!","title":"Traefik &amp; Docker"},{"location":"providers/docker/#configuration-examples","text":"Configuring Docker & Deploying / Exposing Services Enabling the docker provider [providers.docker] endpoint = \"unix:///var/run/docker.sock\" Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: # ... labels: - traefik.http.routers.my-container.rule=Host(`my-domain`) Configuring Docker Swarm & Deploying / Exposing Services Enabling the docker provider (Swarm Mode) [docker] # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" swarmMode = true Attaching labels to containers (in your docker compose file) version: \"3\" services: my-container: deploy: labels: - traefik.http.routers.my-container.rule=Host(`my-domain`) Labels in Docker Swarm Mode If you use a compose file with the Swarm mode, labels should be defined in the deploy part of your service. This behavior is only enabled for docker-compose version 3+ ( Compose file reference ).","title":"Configuration Examples"},{"location":"providers/docker/#provider-configuration-options","text":"Browse the Reference If you're in a hurry, maybe you'd rather go through the Docker Reference .","title":"Provider Configuration Options"},{"location":"providers/docker/#endpoint","text":"Traefik requires access to the docker socket to get its dynamic configuration. Security Notes Depending on your context, accessing the Docker API without any restriction can be a security concern: If Traefik is attacked, then the attacker might get access to the Docker (or Swarm Mode) backend. As explained in the Docker documentation: ( Docker Daemon Attack Surface page ): [...] only **trusted** users should be allowed to control your Docker daemon [...] Improved Security TraefikEE solves this problem by separating the control plane (connected to Docker) and the data plane (handling the requests). Resources about Docker's Security KubeCon EU 2018 Keynote, Running with Scissors, from Liz Rice Don't expose the Docker socket (not even to a container) A thread on Stack Overflow about sharing the /var/run/docker.sock file To Dind or not to DinD Security Compensation Expose the Docker socket over TCP, instead of the default Unix socket file. It allows different implementation levels of the AAA (Authentication, Authorization, Accounting) concepts , depending on your security assessment: Authentication with Client Certificates as described in \"Protect the Docker daemon socket.\" Authorization with the Docker Authorization Plugin Mechanism Accounting at networking level, by exposing the socket only inside a Docker private network, only available for Traefik. Accounting at container level, by exposing the socket on a another container than Traefik's. With Swarm mode, it allows scheduling of Traefik on worker nodes, with only the \"socket exposer\" container on the manager nodes. Accounting at kernel level, by enforcing kernel calls with mechanisms like SELinux , to only allows an identified set of actions for Traefik's process (or the \"socket exposer\" process). Additional Resources Traefik issue GH-4174 about security with Docker socket Inspecting Docker Activity with Socat Letting Traefik run on Worker Nodes Docker Socket Proxy from Tecnativa Traefik & Swarm Mode To let Traefik access the Docker Socket of the Swarm manager, it is mandatory to schedule Traefik on the Swarm manager nodes. Using the docker.sock The docker-compose file shares the docker sock with the Traefik container version: '3' services: traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image ports: - \"80:80\" volumes: - /var/run/docker.sock:/var/run/docker.sock We specify the docker.sock in traefik's configuration file. # ... [providers] [providers.docker] endpoint = \"unix:///var/run/docker.sock\"","title":"endpoint"},{"location":"providers/docker/#usebindportip-optional-defaultfalse","text":"Traefik routes requests to the IP/Port of the matching container. When setting usebindportip=true , you tell Traefik to use the IP/Port attached to the container's binding instead of its inner network IP/Port. When used in conjunction with the traefik.port label (that tells Traefik to route requests to a specific port), Traefik tries to find a binding on port traefik.port . If it can't find such a binding, Traefik falls back on the internal network IP of the container, but still uses the traefik.port that is set in the label. Examples of usebindportip in different situations. traefik.port label Container's binding Routes to - - IntIP:IntPort - ExtPort:IntPort IntIP:IntPort - ExtIp:ExtPort:IntPort ExtIp:ExtPort LblPort - IntIp:LblPort LblPort ExtIp:ExtPort:LblPort ExtIp:ExtPort LblPort ExtIp:ExtPort:OtherPort IntIp:LblPort LblPort ExtIp1:ExtPort1:IntPort1 & ExtIp2:LblPort:IntPort2 ExtIp2:LblPort Note In the above table, ExtIp stands for \"external IP found in the binding\", IntIp stands for \"internal network container's IP\", ExtPort stands for \"external Port found in the binding\", and IntPort stands for \"internal network container's port.\"","title":"usebindportip (Optional, Default=false)"},{"location":"providers/docker/#exposedbydefault-optional-defaulttrue","text":"Expose containers by default through Traefik. If set to false, containers that don't have a traefik.enable=true label will be ignored from the resulting routing configuration.","title":"exposedByDefault (Optional, Default=true)"},{"location":"providers/docker/#network-optional","text":"Defines a default docker network to use for connections to all containers. This option can be overridden on a container basis with the traefik.docker.network label.","title":"network (Optional)"},{"location":"providers/docker/#domain-optional-defaultdockerlocalhost","text":"This is the default base domain used for the router rules. This option can be overridden on a container basis with the traefik.domain label.","title":"domain (Optional, Default=docker.localhost)"},{"location":"providers/docker/#swarmmode-optional-defaultfalse","text":"Activates the Swarm Mode.","title":"swarmMode (Optional, Default=false)"},{"location":"providers/docker/#swarmmoderefreshseconds-optional-default15","text":"Defines the polling interval (in seconds) in Swarm Mode.","title":"swarmModeRefreshSeconds (Optional, Default=15)"},{"location":"providers/docker/#routing-configuration-options","text":"","title":"Routing Configuration Options"},{"location":"providers/docker/#general","text":"Traefik creates, for each container, a corresponding service and router . The Service automatically gets a server per instance of the container, and the router gets a default rule attached to it, based on the container name.","title":"General"},{"location":"providers/docker/#routers","text":"To update the configuration of the Router automatically attached to the container, add labels starting with traefik.routers.{name-of-your-choice}. and followed by the option you want to change. For example, to change the rule, you could add the label traefik.http.routers.my-container.rule=Host(my-domain) . Every Router parameter can be updated this way.","title":"Routers"},{"location":"providers/docker/#services","text":"To update the configuration of the Service automatically attached to the container, add labels starting with traefik.http.services.{name-of-your-choice}. , followed by the option you want to change. For example, to change the load balancer method, you'd add the label traefik.http.services.{name-of-your-choice}.loadbalancer.method=drr . Every Service parameter can be updated this way.","title":"Services"},{"location":"providers/docker/#middleware","text":"You can declare pieces of middleware using labels starting with traefik.http.middlewares.{name-of-your-choice}. , followed by the middleware type/options. For example, to declare a middleware schemeredirect named my-redirect , you'd write traefik.http.middlewares.my-redirect.schemeredirect.scheme: https . Declaring and Referencing a Middleware services: my-container: # ... labels: - traefik.http.middlewares.my-redirect.schemeredirect.scheme=https - traefik.http.routers.middlewares=my-redirect Conflicts in Declaration If you declare multiple middleware with the same name but with different parameters, the middleware fails to be declared.","title":"Middleware"},{"location":"providers/docker/#tcp","text":"You can declare TCP Routers and/or Services using labels. Declaring TCP Routers and Services services: my-container: # ... labels: - traefik.tcp.routers.my-router.rule=\"HostSNI(`my-host.com`)\" - traefik.tcp.routers.my-router.rule.tls=\"true\" - traefik.tcp.services.my-service.loadbalancer.server.port=\"4123\" TCP and HTTP If you declare a TCP Router/Service, it will prevent Traefik from automatically create an HTTP Router/Service (like it does by default if no TCP Router/Service is defined). You can declare both a TCP Router/Service and an HTTP Router/Service for the same container (but you have to do so manually).","title":"TCP"},{"location":"providers/docker/#specific-options","text":"","title":"Specific Options"},{"location":"providers/docker/#traefikenable","text":"You can tell Traefik to consider (or not) the container by setting traefik.enable to true or false. This option overrides the value of exposedByDefault .","title":"traefik.enable"},{"location":"providers/docker/#traefiktags","text":"Sets the tags for constraints filtering .","title":"traefik.tags"},{"location":"providers/docker/#traefikdockernetwork","text":"Overrides the default docker network to use for connections to the container. If a container is linked to several networks, be sure to set the proper network name (you can check this with docker inspect <container_id> ), otherwise it will randomly pick one (depending on how docker is returning them). Warning When deploying a stack from a compose file stack , the networks defined are prefixed with stack .","title":"traefik.docker.network"},{"location":"providers/file/","text":"Traefik & File \u00b6 Good Old Configuration File The file provider lets you define the dynamic configuration in a toml file. You can write these configuration elements: At the end of the main Traefik configuration file (by default: traefik.toml ). In a dedicated file In several dedicated files Note The file provider is the default format used throughout the documentation to show samples of the configuration for many features. Tip The file provider can be a good location for common elements you'd like to re-use from other providers; e.g. declaring whitelist middlewares, basic authentication, ... Configuration Examples \u00b6 Declaring Routers, Middlewares & Services # Enabling the file provider [providers.file] [http] # Add the router [http.routers] [http.routers.router0] entrypoints = [\"web\"] middlewares = [\"my-basic-auth\"] service = \"service-foo\" rule = \"Path(`foo`)\" # Add the middleware [http.middlewares] [http.middlewares.my-basic-auth.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" # Add the service [http.services] [http.services.service-foo] [http.services.service-foo.LoadBalancer] method = \"wrr\" [[http.services.service-foo.LoadBalancer.Servers]] url = \"http://foo/\" weight = 30 [[http.services.service-foo.LoadBalancer.Servers]] url = \"http://bar/\" weight = 70 Provider Configuration Options \u00b6 Browse the Reference If you're in a hurry, maybe you'd rather go through the File Reference . filename ( Optional ) \u00b6 Defines the path of the configuration file. [providers] [providers.file] filename = \"rules.toml\" directory ( Optional ) \u00b6 Defines the directory that contains the configuration files. [providers] [providers.file] directory = \"/path/to/config\" watch ( Optional ) \u00b6 Set the watch option to true to allow Traefik to automatically watch for file changes. It works with both the filename and the directory options. [providers] [providers.file] filename = \"rules.toml\" watch = true TOML Templating \u00b6 Warning TOML templating only works along with dedicated configuration files. Templating does not work in the Traefik main configuration file. Traefik allows using TOML templating. Thus, it's possible to define easily lot of routers, services and TLS certificates as described in the file template-rules.toml : Configuring Using Templating # template-rules.toml [http] [http.routers] {{ range $i, $e := until 100 }} [http.routers.router{{ $e }}] # ... {{ end }} [http.Services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} [tcp] [tcp.routers] {{ range $i, $e := until 100 }} [tcp.routers.router{{ $e }}] # ... {{ end }} [tcp.Services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} {{ range $i, $e := until 10 }} [[TLS]] Store = [\"my-store-foo-{{ $e }}\", \"my-store-bar-{{ $e }}\"] [TLS.Certificate] CertFile = \"/etc/traefik/cert-{{ $e }}.pem\" KeyFile = \"/etc/traefik/cert-{{ $e }}.key\" {{ end }} [TLSConfig] {{ range $i, $e := until 10 }} [TLSConfig.TLS{{ $e }}] # ... {{ end }}","title":"File"},{"location":"providers/file/#traefik-file","text":"Good Old Configuration File The file provider lets you define the dynamic configuration in a toml file. You can write these configuration elements: At the end of the main Traefik configuration file (by default: traefik.toml ). In a dedicated file In several dedicated files Note The file provider is the default format used throughout the documentation to show samples of the configuration for many features. Tip The file provider can be a good location for common elements you'd like to re-use from other providers; e.g. declaring whitelist middlewares, basic authentication, ...","title":"Traefik &amp; File"},{"location":"providers/file/#configuration-examples","text":"Declaring Routers, Middlewares & Services # Enabling the file provider [providers.file] [http] # Add the router [http.routers] [http.routers.router0] entrypoints = [\"web\"] middlewares = [\"my-basic-auth\"] service = \"service-foo\" rule = \"Path(`foo`)\" # Add the middleware [http.middlewares] [http.middlewares.my-basic-auth.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" # Add the service [http.services] [http.services.service-foo] [http.services.service-foo.LoadBalancer] method = \"wrr\" [[http.services.service-foo.LoadBalancer.Servers]] url = \"http://foo/\" weight = 30 [[http.services.service-foo.LoadBalancer.Servers]] url = \"http://bar/\" weight = 70","title":"Configuration Examples"},{"location":"providers/file/#provider-configuration-options","text":"Browse the Reference If you're in a hurry, maybe you'd rather go through the File Reference .","title":"Provider Configuration Options"},{"location":"providers/file/#filename-optional","text":"Defines the path of the configuration file. [providers] [providers.file] filename = \"rules.toml\"","title":"filename (Optional)"},{"location":"providers/file/#directory-optional","text":"Defines the directory that contains the configuration files. [providers] [providers.file] directory = \"/path/to/config\"","title":"directory (Optional)"},{"location":"providers/file/#watch-optional","text":"Set the watch option to true to allow Traefik to automatically watch for file changes. It works with both the filename and the directory options. [providers] [providers.file] filename = \"rules.toml\" watch = true","title":"watch (Optional)"},{"location":"providers/file/#toml-templating","text":"Warning TOML templating only works along with dedicated configuration files. Templating does not work in the Traefik main configuration file. Traefik allows using TOML templating. Thus, it's possible to define easily lot of routers, services and TLS certificates as described in the file template-rules.toml : Configuring Using Templating # template-rules.toml [http] [http.routers] {{ range $i, $e := until 100 }} [http.routers.router{{ $e }}] # ... {{ end }} [http.Services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} [tcp] [tcp.routers] {{ range $i, $e := until 100 }} [tcp.routers.router{{ $e }}] # ... {{ end }} [tcp.Services] {{ range $i, $e := until 100 }} [http.services.service{{ $e }}] # ... {{ end }} {{ range $i, $e := until 10 }} [[TLS]] Store = [\"my-store-foo-{{ $e }}\", \"my-store-bar-{{ $e }}\"] [TLS.Certificate] CertFile = \"/etc/traefik/cert-{{ $e }}.pem\" KeyFile = \"/etc/traefik/cert-{{ $e }}.key\" {{ end }} [TLSConfig] {{ range $i, $e := until 10 }} [TLSConfig.TLS{{ $e }}] # ... {{ end }}","title":"TOML Templating"},{"location":"providers/kubernetes-crd/","text":"Traefik & Kubernetes \u00b6 The Kubernetes Ingress Controller, The Custom Resource Way. The Traefik Kubernetes provider used to be a Kubernetes Ingress controller in the strict sense of the term; that is to say, it would manage access to a cluster services by supporting the Ingress specification. However, as the community expressed the need to benefit from Traefik features without resorting to (lots of) annotations, we ended up writing a Custom Resource Definition (alias CRD in the following) for an IngressRoute type, defined below, in order to provide a better way to configure access to a Kubernetes cluster. Traefik IngressRoute definition \u00b6 apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced That IngressRoute kind can then be used to define an IngressRoute object, such as: apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutefoo.crd spec: entrypoints: - web routes: # Match is the rule corresponding to an underlying router. # Later on, match could be the simple form of a path prefix, e.g. just \"/bar\", # but for now we only support a traefik style matching rule. - match: Host(`foo.com`) && PathPrefix(`/bar`) # kind could eventually be one of \"Rule\", \"Path\", \"Host\", \"Method\", \"Header\", # \"Parameter\", etc, to support simpler forms of rule matching, but for now we # only support \"Rule\". kind: Rule # Priority disambiguates rules of the same length, for route matching. priority: 12 services: - name: whoami port: 80 Middleware \u00b6 Additionally, to allow for the use of middlewares in an IngressRoute , we defined the CRD below for the Middleware kind. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced Once the Middleware kind has been registered with the Kubernetes cluster, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripprefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar.crd spec: entrypoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 middlewares: - name: stripprefix TLS \u00b6 To allow for TLS, we made use of the Secret kind, as it was already defined, and it can be directly used in an IngressRoute : apiVersion: v1 kind: Secret metadata: name: supersecret data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls.crd spec: entryPoints: - web routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule services: - name: whoami port: 443 tls: secretName: supersecret Full reference example \u00b6 Traefik IngressRoute Reference . Further \u00b6 Also see the full example with Let's Encrypt.","title":"Kubernetes IngressRoute"},{"location":"providers/kubernetes-crd/#traefik-kubernetes","text":"The Kubernetes Ingress Controller, The Custom Resource Way. The Traefik Kubernetes provider used to be a Kubernetes Ingress controller in the strict sense of the term; that is to say, it would manage access to a cluster services by supporting the Ingress specification. However, as the community expressed the need to benefit from Traefik features without resorting to (lots of) annotations, we ended up writing a Custom Resource Definition (alias CRD in the following) for an IngressRoute type, defined below, in order to provide a better way to configure access to a Kubernetes cluster.","title":"Traefik &amp; Kubernetes"},{"location":"providers/kubernetes-crd/#traefik-ingressroute-definition","text":"apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced That IngressRoute kind can then be used to define an IngressRoute object, such as: apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutefoo.crd spec: entrypoints: - web routes: # Match is the rule corresponding to an underlying router. # Later on, match could be the simple form of a path prefix, e.g. just \"/bar\", # but for now we only support a traefik style matching rule. - match: Host(`foo.com`) && PathPrefix(`/bar`) # kind could eventually be one of \"Rule\", \"Path\", \"Host\", \"Method\", \"Header\", # \"Parameter\", etc, to support simpler forms of rule matching, but for now we # only support \"Rule\". kind: Rule # Priority disambiguates rules of the same length, for route matching. priority: 12 services: - name: whoami port: 80","title":"Traefik IngressRoute definition"},{"location":"providers/kubernetes-crd/#middleware","text":"Additionally, to allow for the use of middlewares in an IngressRoute , we defined the CRD below for the Middleware kind. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced Once the Middleware kind has been registered with the Kubernetes cluster, it can then be used in IngressRoute definitions, such as: apiVersion: traefik.containo.us/v1alpha1 kind: Middleware metadata: name: stripprefix spec: stripprefix: prefixes: - /stripit --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutebar.crd spec: entrypoints: - web routes: - match: Host(`bar.com`) && PathPrefix(`/stripit`) kind: Rule services: - name: whoami port: 80 middlewares: - name: stripprefix","title":"Middleware"},{"location":"providers/kubernetes-crd/#tls","text":"To allow for TLS, we made use of the Secret kind, as it was already defined, and it can be directly used in an IngressRoute : apiVersion: v1 kind: Secret metadata: name: supersecret data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0= tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0= --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls.crd spec: entryPoints: - web routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule services: - name: whoami port: 443 tls: secretName: supersecret","title":"TLS"},{"location":"providers/kubernetes-crd/#full-reference-example","text":"Traefik IngressRoute Reference .","title":"Full reference example"},{"location":"providers/kubernetes-crd/#further","text":"Also see the full example with Let's Encrypt.","title":"Further"},{"location":"providers/kubernetes-ingress/","text":"Traefik & Kubernetes \u00b6 Kubernetes Ingress. TODO","title":""},{"location":"providers/kubernetes-ingress/#traefik-kubernetes","text":"Kubernetes Ingress. TODO","title":"Traefik &amp; Kubernetes"},{"location":"providers/overview/","text":"Overview \u00b6 Traefik's Many Friends Configuration discovery in Traefik is achieved through Providers . The providers are existing infrastructure components, whether orchestrators, container engines, cloud providers, or key-value stores. The idea is that Traefik will query the providers' API in order to find relevant information about routing, and each time Traefik detects a change, it dynamically updates the routes. Deploy and forget is Traefik's credo. Orchestrators \u00b6 Even if each provider is different, we can categorize them in four groups: Label based (each deployed container has a set of labels attached to it) Key-Value based (each deployed container updates a key-value store with relevant information) Annotation based (a separate object, with annotations, defines the characteristics of the container) File based (the good old configuration file) Supported Providers \u00b6 Below is the list of the currently supported providers in Traefik. Provider Type Configuration Type Docker Orchestrator Label File Orchestrator Custom Annotation Kubernetes Orchestrator Custom Resource Marathon (not yet documented) Orchestrator Label More Providers The current version of Traefik is in development and doesn't support (yet) every provider. See the previous version (1.7) for more providers. Constraints Configuration \u00b6 If you want to limit the scope of Traefik service discovery, you can set constraints. Doing so, Traefik will create routes for containers that match these constraints only. Containers with the api Tag constraints = [\"tag==api\"] Containers without the api Tag constraints = [\"tag!=api\"] Containers with tags starting with 'us-' constraints = [\"tag==us-*\"] Multiple constraints # Multiple constraints # - \"tag==\" must match with at least one tag # - \"tag!=\" must match with none of tags constraints = [\"tag!=us-*\", \"tag!=asia-*\"] List of Providers that Support Constraints Docker Consul K/V BoltDB Zookeeper ECS Etcd Consul Catalog Rancher Marathon Kubernetes (using a provider-specific mechanism based on label selectors) Note The constraint option belongs to the provider configuration itself. Setting the Constraint Options for Docker [providers] [providers.docker] constraints = [\"tag==api\"]","title":"Overview"},{"location":"providers/overview/#overview","text":"Traefik's Many Friends Configuration discovery in Traefik is achieved through Providers . The providers are existing infrastructure components, whether orchestrators, container engines, cloud providers, or key-value stores. The idea is that Traefik will query the providers' API in order to find relevant information about routing, and each time Traefik detects a change, it dynamically updates the routes. Deploy and forget is Traefik's credo.","title":"Overview"},{"location":"providers/overview/#orchestrators","text":"Even if each provider is different, we can categorize them in four groups: Label based (each deployed container has a set of labels attached to it) Key-Value based (each deployed container updates a key-value store with relevant information) Annotation based (a separate object, with annotations, defines the characteristics of the container) File based (the good old configuration file)","title":"Orchestrators"},{"location":"providers/overview/#supported-providers","text":"Below is the list of the currently supported providers in Traefik. Provider Type Configuration Type Docker Orchestrator Label File Orchestrator Custom Annotation Kubernetes Orchestrator Custom Resource Marathon (not yet documented) Orchestrator Label More Providers The current version of Traefik is in development and doesn't support (yet) every provider. See the previous version (1.7) for more providers.","title":"Supported Providers"},{"location":"providers/overview/#constraints-configuration","text":"If you want to limit the scope of Traefik service discovery, you can set constraints. Doing so, Traefik will create routes for containers that match these constraints only. Containers with the api Tag constraints = [\"tag==api\"] Containers without the api Tag constraints = [\"tag!=api\"] Containers with tags starting with 'us-' constraints = [\"tag==us-*\"] Multiple constraints # Multiple constraints # - \"tag==\" must match with at least one tag # - \"tag!=\" must match with none of tags constraints = [\"tag!=us-*\", \"tag!=asia-*\"] List of Providers that Support Constraints Docker Consul K/V BoltDB Zookeeper ECS Etcd Consul Catalog Rancher Marathon Kubernetes (using a provider-specific mechanism based on label selectors) Note The constraint option belongs to the provider configuration itself. Setting the Constraint Options for Docker [providers] [providers.docker] constraints = [\"tag==api\"]","title":"Constraints Configuration"},{"location":"reference/acme/","text":"ACME - Reference \u00b6 Every Options for ACME TOML \u00b6 # Sample entrypoint configuration when using ACME. [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web-secure] address = \":443\" # Enable ACME (Let's Encrypt): automatic SSL. [acme] # Email address used for registration. # # Required # email = \"test@traefik.io\" # File used for certificates storage. # # Optional (Deprecated) # #storageFile = \"acme.json\" # File or key used for certificates storage. # # Required # storage = \"acme.json\" # or `storage = \"traefik/acme/account\"` if using KV store. # Deprecated, replaced by [acme.dnsChallenge]. # # Optional. # # dnsProvider = \"digitalocean\" # Deprecated, replaced by [acme.dnsChallenge.delayBeforeCheck]. # # Optional # Default: 0 # # delayDontCheckDNS = 0 # If true, display debug log messages from the acme client library. # # Optional # Default: false # # acmeLogging = true # If true, override certificates in key-value store when using storeconfig. # # Optional # Default: false # # overrideCertificates = true # Deprecated. Enable on demand certificate generation. # # Optional # Default: false # # onDemand = true # Enable certificate generation on frontends host rules. # # Optional # Default: false # # onHostRule = true # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # KeyType = \"RSA4096\" # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # [acme.tlsChallenge] # Use a HTTP-01 ACME challenge. # # Optional # # [acme.httpChallenge] # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint = \"http\" # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # [acme.dnsChallenge] # DNS provider used. # # Required # # provider = \"digitalocean\" # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck = 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck = true # Domains list. # Only domains defined here can generate wildcard certificates. # The certificates for these domains are negotiated at traefik startup only. # # [[acme.domains]] # main = \"local1.com\" # sans = [\"test1.local1.com\", \"test2.local1.com\"] # [[acme.domains]] # main = \"local2.com\" # [[acme.domains]] # main = \"*.local3.com\" # sans = [\"local3.com\", \"test1.test1.local3.com\"]","title":""},{"location":"reference/acme/#acme-reference","text":"Every Options for ACME","title":"ACME - Reference"},{"location":"reference/acme/#toml","text":"# Sample entrypoint configuration when using ACME. [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web-secure] address = \":443\" # Enable ACME (Let's Encrypt): automatic SSL. [acme] # Email address used for registration. # # Required # email = \"test@traefik.io\" # File used for certificates storage. # # Optional (Deprecated) # #storageFile = \"acme.json\" # File or key used for certificates storage. # # Required # storage = \"acme.json\" # or `storage = \"traefik/acme/account\"` if using KV store. # Deprecated, replaced by [acme.dnsChallenge]. # # Optional. # # dnsProvider = \"digitalocean\" # Deprecated, replaced by [acme.dnsChallenge.delayBeforeCheck]. # # Optional # Default: 0 # # delayDontCheckDNS = 0 # If true, display debug log messages from the acme client library. # # Optional # Default: false # # acmeLogging = true # If true, override certificates in key-value store when using storeconfig. # # Optional # Default: false # # overrideCertificates = true # Deprecated. Enable on demand certificate generation. # # Optional # Default: false # # onDemand = true # Enable certificate generation on frontends host rules. # # Optional # Default: false # # onHostRule = true # CA server to use. # Uncomment the line to use Let's Encrypt's staging server, # leave commented to go to prod. # # Optional # Default: \"https://acme-v02.api.letsencrypt.org/directory\" # # caServer = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # KeyType to use. # # Optional # Default: \"RSA4096\" # # Available values : \"EC256\", \"EC384\", \"RSA2048\", \"RSA4096\", \"RSA8192\" # # KeyType = \"RSA4096\" # Use a TLS-ALPN-01 ACME challenge. # # Optional (but recommended) # [acme.tlsChallenge] # Use a HTTP-01 ACME challenge. # # Optional # # [acme.httpChallenge] # EntryPoint to use for the HTTP-01 challenges. # # Required # # entryPoint = \"http\" # Use a DNS-01 ACME challenge rather than HTTP-01 challenge. # Note: mandatory for wildcard certificate generation. # # Optional # # [acme.dnsChallenge] # DNS provider used. # # Required # # provider = \"digitalocean\" # By default, the provider will verify the TXT DNS challenge record before letting ACME verify. # If delayBeforeCheck is greater than zero, this check is delayed for the configured duration in seconds. # Useful if internal networks block external DNS queries. # # Optional # Default: 0 # # delayBeforeCheck = 0 # Use following DNS servers to resolve the FQDN authority. # # Optional # Default: empty # # resolvers = [\"1.1.1.1:53\", \"8.8.8.8:53\"] # Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. # # NOT RECOMMENDED: # Increase the risk of reaching Let's Encrypt's rate limits. # # Optional # Default: false # # disablePropagationCheck = true # Domains list. # Only domains defined here can generate wildcard certificates. # The certificates for these domains are negotiated at traefik startup only. # # [[acme.domains]] # main = \"local1.com\" # sans = [\"test1.local1.com\", \"test2.local1.com\"] # [[acme.domains]] # main = \"local2.com\" # [[acme.domains]] # main = \"*.local3.com\" # sans = [\"local3.com\", \"test1.test1.local3.com\"]","title":"TOML"},{"location":"reference/entrypoints/","text":"EntryPoints - Reference \u00b6 Every Options for EntryPoints TOML \u00b6 # ... [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] insecure = true trustedIPs = [\"10.10.10.1\", \"10.10.10.2\"] [entrypoints.web.forwardedHeaders] trustedIPs = [\"10.10.10.1\", \"10.10.10.2\"] insecure = false [entrypoints.web-secure] # ... CLI \u00b6 Name:foo Address::80 ProxyProtocol.TrustedIPs:192.168.0.1 ProxyProtocol.Insecure:true ForwardedHeaders.TrustedIPs:10.0.0.3/24,20.0.0.3/24","title":""},{"location":"reference/entrypoints/#entrypoints-reference","text":"Every Options for EntryPoints","title":"EntryPoints - Reference"},{"location":"reference/entrypoints/#toml","text":"# ... [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] insecure = true trustedIPs = [\"10.10.10.1\", \"10.10.10.2\"] [entrypoints.web.forwardedHeaders] trustedIPs = [\"10.10.10.1\", \"10.10.10.2\"] insecure = false [entrypoints.web-secure] # ...","title":"TOML"},{"location":"reference/entrypoints/#cli","text":"Name:foo Address::80 ProxyProtocol.TrustedIPs:192.168.0.1 ProxyProtocol.Insecure:true ForwardedHeaders.TrustedIPs:10.0.0.3/24,20.0.0.3/24","title":"CLI"},{"location":"reference/logs/","text":"Logs - Reference \u00b6 TOML \u00b6 logLevel = \"INFO\" [traefikLog] filePath = \"/path/to/traefik.log\" format = \"json\" [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\" [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" # ... [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" # ... CLI \u00b6 For more information about the CLI, see the documentation about Traefik command . --logLevel=\"DEBUG\" --traefikLog.filePath=\"/path/to/traefik.log\" --traefikLog.format=\"json\" --accessLog.filePath=\"/path/to/access.log\" --accessLog.format=\"json\" --accessLog.filters.statusCodes=\"200,300-302\" --accessLog.filters.retryAttempts=\"true\" --accessLog.filters.minDuration=\"10ms\" --accessLog.fields.defaultMode=\"keep\" --accessLog.fields.names=\"Username=drop Hostname=drop\" --accessLog.fields.headers.defaultMode=\"keep\" --accessLog.fields.headers.names=\"User-Agent=redact Authorization=drop Content-Type=keep\"","title":"Logs - Reference"},{"location":"reference/logs/#logs-reference","text":"","title":"Logs - Reference"},{"location":"reference/logs/#toml","text":"logLevel = \"INFO\" [traefikLog] filePath = \"/path/to/traefik.log\" format = \"json\" [accessLog] filePath = \"/path/to/access.log\" format = \"json\" [accessLog.filters] statusCodes = [\"200\", \"300-302\"] retryAttempts = true minDuration = \"10ms\" [accessLog.fields] defaultMode = \"keep\" [accessLog.fields.names] \"ClientUsername\" = \"drop\" # ... [accessLog.fields.headers] defaultMode = \"keep\" [accessLog.fields.headers.names] \"User-Agent\" = \"redact\" \"Authorization\" = \"drop\" \"Content-Type\" = \"keep\" # ...","title":"TOML"},{"location":"reference/logs/#cli","text":"For more information about the CLI, see the documentation about Traefik command . --logLevel=\"DEBUG\" --traefikLog.filePath=\"/path/to/traefik.log\" --traefikLog.format=\"json\" --accessLog.filePath=\"/path/to/access.log\" --accessLog.format=\"json\" --accessLog.filters.statusCodes=\"200,300-302\" --accessLog.filters.retryAttempts=\"true\" --accessLog.filters.minDuration=\"10ms\" --accessLog.fields.defaultMode=\"keep\" --accessLog.fields.names=\"Username=drop Hostname=drop\" --accessLog.fields.headers.defaultMode=\"keep\" --accessLog.fields.headers.names=\"User-Agent=redact Authorization=drop Content-Type=keep\"","title":"CLI"},{"location":"reference/providers/docker/","text":"Docker -- Reference \u00b6 Docker \u00b6 ################################################################ # Docker Provider ################################################################ # Enable Docker Provider. [docker] # Docker server endpoint. Can be a tcp or a unix socket endpoint. # # Required # endpoint = \"unix:///var/run/docker.sock\" # Default base domain used for the frontend rules. # Can be overridden by setting the \"traefik.domain\" label on a container. # # Optional # domain = \"docker.localhost\" # Enable watch docker changes. # # Optional # watch = true # Override default configuration template. # For advanced users :) # # Optional # # filename = \"docker.tmpl\" # Override template version # For advanced users :) # # Optional # - \"1\": previous template version (must be used only with older custom templates, see \"filename\") # - \"2\": current template version (must be used to force template version when \"filename\" is used) # # templateVersion = 2 # Expose containers by default in Traefik. # If set to false, containers that don't have `traefik.enable=true` will be ignored. # # Optional # Default: true # exposedByDefault = true # Use the IP address from the binded port instead of the inner network one. # # In case no IP address is attached to the binded port (or in case # there is no bind), the inner network one will be used as a fallback. # # Optional # Default: false # usebindportip = true # Use Swarm Mode services as data provider. # # Optional # Default: false # swarmMode = false # Polling interval (in seconds) for Swarm Mode. # # Optional # Default: 15 # swarmModeRefreshSeconds = 15 # Define a default docker network to use for connections to all containers. # Can be overridden by the traefik.docker.network label. # # Optional # network = \"web\" # Enable docker TLS connection. # # Optional # # [docker.tls] # ca = \"/etc/ssl/ca.crt\" # cert = \"/etc/ssl/docker.crt\" # key = \"/etc/ssl/docker.key\" # insecureSkipVerify = true Docker Swarm Mode \u00b6 ################################################################ # Docker Swarm Mode Provider ################################################################ # Enable Docker Provider. [docker] # Docker server endpoint. # Can be a tcp or a unix socket endpoint. # # Required # Default: \"unix:///var/run/docker.sock\" # # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" # Default base domain used for the frontend rules. # Can be overridden by setting the \"traefik.domain\" label on a services. # # Optional # Default: \"\" # domain = \"docker.localhost\" # Enable watch docker changes. # # Optional # Default: true # watch = true # Use Docker Swarm Mode as data provider. # # Optional # Default: false # swarmMode = true # Define a default docker network to use for connections to all containers. # Can be overridden by the traefik.docker.network label. # # Optional # network = \"web\" # Override default configuration template. # For advanced users :) # # Optional # # filename = \"docker.tmpl\" # Override template version # For advanced users :) # # Optional # - \"1\": previous template version (must be used only with older custom templates, see \"filename\") # - \"2\": current template version (must be used to force template version when \"filename\" is used) # # templateVersion = 2 # Expose services by default in Traefik. # # Optional # Default: true # exposedByDefault = false # Enable docker TLS connection. # # Optional # # [docker.tls] # ca = \"/etc/ssl/ca.crt\" # cert = \"/etc/ssl/docker.crt\" # key = \"/etc/ssl/docker.key\" # insecureSkipVerify = true","title":""},{"location":"reference/providers/docker/#docker-reference","text":"","title":"Docker -- Reference"},{"location":"reference/providers/docker/#docker","text":"################################################################ # Docker Provider ################################################################ # Enable Docker Provider. [docker] # Docker server endpoint. Can be a tcp or a unix socket endpoint. # # Required # endpoint = \"unix:///var/run/docker.sock\" # Default base domain used for the frontend rules. # Can be overridden by setting the \"traefik.domain\" label on a container. # # Optional # domain = \"docker.localhost\" # Enable watch docker changes. # # Optional # watch = true # Override default configuration template. # For advanced users :) # # Optional # # filename = \"docker.tmpl\" # Override template version # For advanced users :) # # Optional # - \"1\": previous template version (must be used only with older custom templates, see \"filename\") # - \"2\": current template version (must be used to force template version when \"filename\" is used) # # templateVersion = 2 # Expose containers by default in Traefik. # If set to false, containers that don't have `traefik.enable=true` will be ignored. # # Optional # Default: true # exposedByDefault = true # Use the IP address from the binded port instead of the inner network one. # # In case no IP address is attached to the binded port (or in case # there is no bind), the inner network one will be used as a fallback. # # Optional # Default: false # usebindportip = true # Use Swarm Mode services as data provider. # # Optional # Default: false # swarmMode = false # Polling interval (in seconds) for Swarm Mode. # # Optional # Default: 15 # swarmModeRefreshSeconds = 15 # Define a default docker network to use for connections to all containers. # Can be overridden by the traefik.docker.network label. # # Optional # network = \"web\" # Enable docker TLS connection. # # Optional # # [docker.tls] # ca = \"/etc/ssl/ca.crt\" # cert = \"/etc/ssl/docker.crt\" # key = \"/etc/ssl/docker.key\" # insecureSkipVerify = true","title":"Docker"},{"location":"reference/providers/docker/#docker-swarm-mode","text":"################################################################ # Docker Swarm Mode Provider ################################################################ # Enable Docker Provider. [docker] # Docker server endpoint. # Can be a tcp or a unix socket endpoint. # # Required # Default: \"unix:///var/run/docker.sock\" # # swarm classic (1.12-) # endpoint = \"tcp://127.0.0.1:2375\" # docker swarm mode (1.12+) endpoint = \"tcp://127.0.0.1:2377\" # Default base domain used for the frontend rules. # Can be overridden by setting the \"traefik.domain\" label on a services. # # Optional # Default: \"\" # domain = \"docker.localhost\" # Enable watch docker changes. # # Optional # Default: true # watch = true # Use Docker Swarm Mode as data provider. # # Optional # Default: false # swarmMode = true # Define a default docker network to use for connections to all containers. # Can be overridden by the traefik.docker.network label. # # Optional # network = \"web\" # Override default configuration template. # For advanced users :) # # Optional # # filename = \"docker.tmpl\" # Override template version # For advanced users :) # # Optional # - \"1\": previous template version (must be used only with older custom templates, see \"filename\") # - \"2\": current template version (must be used to force template version when \"filename\" is used) # # templateVersion = 2 # Expose services by default in Traefik. # # Optional # Default: true # exposedByDefault = false # Enable docker TLS connection. # # Optional # # [docker.tls] # ca = \"/etc/ssl/ca.crt\" # cert = \"/etc/ssl/docker.crt\" # key = \"/etc/ssl/docker.key\" # insecureSkipVerify = true","title":"Docker Swarm Mode"},{"location":"reference/providers/file/","text":"File -- Reference \u00b6 File \u00b6 ################################################################ # File Provider ################################################################ [providers] # Enable File Provider. [providers.file] # Define one separated configuration file. # # Optional # filename = \"my-conf.toml\" # Define directory that contains a set of configuration files. # # Optional # directory = \"/path/to/config\" # Enable watch file changes. # # Optional # watch = true [http] [http.routers] [http.routers.router0] entrypoints = [\"foo\", \"bar\"] middlewares = [\"foo\", \"bar\"] service = \"service-foo\" rule = \"Path(`foo`)\" priority = 42 [http.routers.router0.tls] [http.middlewares] [http.middlewares.my-add-prefix.AddPrefix] prefix = \"/foo\" [http.middlewares.my-strip-prefix.StripPrefix] prefixes = [\"/foo\", \"/bar\"] [http.middlewares.my-strip-prefix-regex.StripPrefixRegex] regex = [\"/foo/api/\", \"/bar/{category}/{id:[0-9]+}/\"] [http.middlewares.my-replace-path.ReplacePath] path = \"/foo\" [http.middlewares.my-replace-path-regex.ReplacePathRegex] regex = \"foo/(.*)\" replacement = \"/foobar/$1\" [http.middlewares.my-chain.Chain] middlewares = [\"my-add-prefix\", \"my-basic-auth\"] [http.middlewares.Middleware0.IPWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.Middleware0.IPWhiteList.IPStrategy] depth = 2 excludedIPs = [\"127.0.0.1/16\", \"192.168.1.7\"] [http.middlewares.my-headers.Headers] allowedHosts = [\"foobar\", \"foobar\"] hostsProxyHeaders = [\"foobar\", \"foobar\"] sslRedirect = true sslTemporaryRedirect = true sslHost = \"foobar\" sslForceHost = true stsSeconds = 42 stsIncludeSubdomains = true stsPreload = true forceSTSHeader = true frameDeny = true customFrameOptionsValue = \"foobar\" contentTypeNosniff = true browserXSSFilter = true customBrowserXSSValue = \"foobar\" contentSecurityPolicy = \"foobar\" publicKey = \"foobar\" referrerPolicy = \"foobar\" isDevelopment = true [http.middlewares.my-headers.Headers.CustomRequestHeaders] X-Script-Name = \"foo\" [http.middlewares.my-headers.Headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\" [http.middlewares.my-headers.Headers.SSLProxyHeaders] X-Forwarded-Proto = \"https\" [http.middlewares.my-errors.Errors] status = [\"400-404\", \"500-599\"] service = \"foo-errors-service\" query = \"/error.html\" [http.middlewares.my-rate-limit.RateLimit] extractorFunc = \"client.ip\" [http.middlewares.Middleware0.RateLimit.RateSet] [http.middlewares.Middleware0.RateLimit.RateSet.Rate0] period = 10 average = 100 burst = 200 [http.middlewares.my-redirect-regex.RedirectRegex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/$1\" permanent = true [http.middlewares.my-redirect-scheme.RedirectScheme] scheme = \"https\" port = \"8443\" permanent = true [http.middlewares.my-basic-auth.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" realm = \"myRealm\" removeHeader = true headerField = \"X-WebAuth-User\" [http.middlewares.my-digest-auth.DigestAuth] users = [\"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"] usersFile = \"etc/traefik/.htdigest\" removeHeader = true realm = \"traefik\" headerField = \"X-WebAuth-User\" [http.middlewares.my-forward-auth.ForwardAuth] address = \"https://myauth.server:443\" trustForwardHeader = true authResponseHeaders = [\"X-Forwarded-Foo\", \"X-Forwarded-Bar\"] [http.middlewares.my-forward-auth.ForwardAuth.TLS] ca = \"/etc/traefik/crt/ca.pem\" caOptional = true cert = \"/etc/traefik/crt/cert.pem\" key = \"/etc/traefik/crt/cert.key\" insecureSkipVerify = true [http.middlewares.my-maxconn.MaxConn] amount = 10 extractorFunc = \"request.host\" [http.middlewares.my-buffering.Buffering] maxRequestBodyBytes = 25000 memRequestBodyBytes = 25000 maxResponseBodyBytes = 25000 memResponseBodyBytes = 25000 retryExpression = \"foobar\" [http.middlewares.my-circuit-breaker.CircuitBreaker] Expression = \"LatencyAtQuantileMS(50.0) > 100\" [http.middlewares.my-compress.Compress] [http.middlewares.my-pass-tls-client-cert.PassTLSClientCert] pem = true [http.middlewares.Middleware0.PassTLSClientCert.Info] notAfter = true notBefore = true sans = true [http.middlewares.Middleware0.PassTLSClientCert.Info.Subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware0.PassTLSClientCert.Info.Issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.my-retry.Retry] attempts = 4 [http.services] [http.services.service0] [http.services.service0.LoadBalancer] method = \"wrr\" passHostHeader = true [http.services.service0.LoadBalancer.Stickiness] cookieName = \"my-stickiness-cookie-name\" [[http.services.service0.LoadBalancer.Servers]] url = \"http://foo/\" weight = 30 [[http.services.service0.LoadBalancer.Servers]] url = \"http://bar/\" weight = 70 [http.services.service0.LoadBalancer.HealthCheck] scheme = \"https\" path = \"/health\" port = 9443 interval = \"10s\" timeout = \"30s\" hostname = \"foobar\" [http.services.service0.LoadBalancer.HealthCheck.Headers] My-Custom-Header = \"foobar\" [http.services.service0.LoadBalancer.ResponseForwarding] flushInterval = \"4s\" [tcp] [tcp.routers] [tcp.routers.tcpRouter0] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.tcpRouter0.tlst] passthrough = true [tcp.services] [tcp.services.tcpService0] [tcp.services.tcpService0.tcpLoadBalancer] method = \"foobar\" [[tcp.services.tcpService0.tcpLoadBalancer.Servers]] address = \"foobar\" weight = 42 [[tcp.services.tcpService0.tcpLoadBalancer.Servers]] address = \"foobar\" weight = 42 [[tls]] Store = [\"my-store-foo\", \"my-store-bar\"] [tls.Certificate] certFile = \"/etc/traefik/cert.pem\" keyFile = \"/etc/traefik/cert.key\" [tlsconfig] [tlsconfig.TLS0] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\"] [tlsconfig.TLS0.ClientCA] files = [\"/etc/traefik/ca-foo.pem\", \"/etc/traefik/ca-bar.pem\"] optional = true [tlsstore] [tlsstore.my-store-foo] sniStrict = true [tlsstore.my-store-foo.DefaultCertificate] certFile = \"/etc/traefik/cert.pem\" keyFile = \"/etc/traefik/cert.key\"","title":""},{"location":"reference/providers/file/#file-reference","text":"","title":"File -- Reference"},{"location":"reference/providers/file/#file","text":"################################################################ # File Provider ################################################################ [providers] # Enable File Provider. [providers.file] # Define one separated configuration file. # # Optional # filename = \"my-conf.toml\" # Define directory that contains a set of configuration files. # # Optional # directory = \"/path/to/config\" # Enable watch file changes. # # Optional # watch = true [http] [http.routers] [http.routers.router0] entrypoints = [\"foo\", \"bar\"] middlewares = [\"foo\", \"bar\"] service = \"service-foo\" rule = \"Path(`foo`)\" priority = 42 [http.routers.router0.tls] [http.middlewares] [http.middlewares.my-add-prefix.AddPrefix] prefix = \"/foo\" [http.middlewares.my-strip-prefix.StripPrefix] prefixes = [\"/foo\", \"/bar\"] [http.middlewares.my-strip-prefix-regex.StripPrefixRegex] regex = [\"/foo/api/\", \"/bar/{category}/{id:[0-9]+}/\"] [http.middlewares.my-replace-path.ReplacePath] path = \"/foo\" [http.middlewares.my-replace-path-regex.ReplacePathRegex] regex = \"foo/(.*)\" replacement = \"/foobar/$1\" [http.middlewares.my-chain.Chain] middlewares = [\"my-add-prefix\", \"my-basic-auth\"] [http.middlewares.Middleware0.IPWhiteList] sourceRange = [\"127.0.0.1/32\", \"192.168.1.7\"] [http.middlewares.Middleware0.IPWhiteList.IPStrategy] depth = 2 excludedIPs = [\"127.0.0.1/16\", \"192.168.1.7\"] [http.middlewares.my-headers.Headers] allowedHosts = [\"foobar\", \"foobar\"] hostsProxyHeaders = [\"foobar\", \"foobar\"] sslRedirect = true sslTemporaryRedirect = true sslHost = \"foobar\" sslForceHost = true stsSeconds = 42 stsIncludeSubdomains = true stsPreload = true forceSTSHeader = true frameDeny = true customFrameOptionsValue = \"foobar\" contentTypeNosniff = true browserXSSFilter = true customBrowserXSSValue = \"foobar\" contentSecurityPolicy = \"foobar\" publicKey = \"foobar\" referrerPolicy = \"foobar\" isDevelopment = true [http.middlewares.my-headers.Headers.CustomRequestHeaders] X-Script-Name = \"foo\" [http.middlewares.my-headers.Headers.CustomResponseHeaders] X-Custom-Response-Header = \"True\" [http.middlewares.my-headers.Headers.SSLProxyHeaders] X-Forwarded-Proto = \"https\" [http.middlewares.my-errors.Errors] status = [\"400-404\", \"500-599\"] service = \"foo-errors-service\" query = \"/error.html\" [http.middlewares.my-rate-limit.RateLimit] extractorFunc = \"client.ip\" [http.middlewares.Middleware0.RateLimit.RateSet] [http.middlewares.Middleware0.RateLimit.RateSet.Rate0] period = 10 average = 100 burst = 200 [http.middlewares.my-redirect-regex.RedirectRegex] regex = \"^http://localhost/(.*)\" replacement = \"http://mydomain/$1\" permanent = true [http.middlewares.my-redirect-scheme.RedirectScheme] scheme = \"https\" port = \"8443\" permanent = true [http.middlewares.my-basic-auth.BasicAuth] users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\", \"test2:$apr1$d9hr9HBB$4HxwgUir3HP4EsggP/QNo0\"] usersFile = \"etc/traefik/.htpasswd\" realm = \"myRealm\" removeHeader = true headerField = \"X-WebAuth-User\" [http.middlewares.my-digest-auth.DigestAuth] users = [\"test:traefik:a2688e031edb4be6a3797f3882655c05\", \"test2:traefik:518845800f9e2bfb1f1f740ec24f074e\"] usersFile = \"etc/traefik/.htdigest\" removeHeader = true realm = \"traefik\" headerField = \"X-WebAuth-User\" [http.middlewares.my-forward-auth.ForwardAuth] address = \"https://myauth.server:443\" trustForwardHeader = true authResponseHeaders = [\"X-Forwarded-Foo\", \"X-Forwarded-Bar\"] [http.middlewares.my-forward-auth.ForwardAuth.TLS] ca = \"/etc/traefik/crt/ca.pem\" caOptional = true cert = \"/etc/traefik/crt/cert.pem\" key = \"/etc/traefik/crt/cert.key\" insecureSkipVerify = true [http.middlewares.my-maxconn.MaxConn] amount = 10 extractorFunc = \"request.host\" [http.middlewares.my-buffering.Buffering] maxRequestBodyBytes = 25000 memRequestBodyBytes = 25000 maxResponseBodyBytes = 25000 memResponseBodyBytes = 25000 retryExpression = \"foobar\" [http.middlewares.my-circuit-breaker.CircuitBreaker] Expression = \"LatencyAtQuantileMS(50.0) > 100\" [http.middlewares.my-compress.Compress] [http.middlewares.my-pass-tls-client-cert.PassTLSClientCert] pem = true [http.middlewares.Middleware0.PassTLSClientCert.Info] notAfter = true notBefore = true sans = true [http.middlewares.Middleware0.PassTLSClientCert.Info.Subject] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.Middleware0.PassTLSClientCert.Info.Issuer] country = true province = true locality = true organization = true commonName = true serialNumber = true domainComponent = true [http.middlewares.my-retry.Retry] attempts = 4 [http.services] [http.services.service0] [http.services.service0.LoadBalancer] method = \"wrr\" passHostHeader = true [http.services.service0.LoadBalancer.Stickiness] cookieName = \"my-stickiness-cookie-name\" [[http.services.service0.LoadBalancer.Servers]] url = \"http://foo/\" weight = 30 [[http.services.service0.LoadBalancer.Servers]] url = \"http://bar/\" weight = 70 [http.services.service0.LoadBalancer.HealthCheck] scheme = \"https\" path = \"/health\" port = 9443 interval = \"10s\" timeout = \"30s\" hostname = \"foobar\" [http.services.service0.LoadBalancer.HealthCheck.Headers] My-Custom-Header = \"foobar\" [http.services.service0.LoadBalancer.ResponseForwarding] flushInterval = \"4s\" [tcp] [tcp.routers] [tcp.routers.tcpRouter0] entryPoints = [\"foobar\", \"foobar\"] service = \"foobar\" rule = \"foobar\" [tcp.routers.tcpRouter0.tlst] passthrough = true [tcp.services] [tcp.services.tcpService0] [tcp.services.tcpService0.tcpLoadBalancer] method = \"foobar\" [[tcp.services.tcpService0.tcpLoadBalancer.Servers]] address = \"foobar\" weight = 42 [[tcp.services.tcpService0.tcpLoadBalancer.Servers]] address = \"foobar\" weight = 42 [[tls]] Store = [\"my-store-foo\", \"my-store-bar\"] [tls.Certificate] certFile = \"/etc/traefik/cert.pem\" keyFile = \"/etc/traefik/cert.key\" [tlsconfig] [tlsconfig.TLS0] minVersion = \"VersionTLS12\" cipherSuites = [ \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\"] [tlsconfig.TLS0.ClientCA] files = [\"/etc/traefik/ca-foo.pem\", \"/etc/traefik/ca-bar.pem\"] optional = true [tlsstore] [tlsstore.my-store-foo] sniStrict = true [tlsstore.my-store-foo.DefaultCertificate] certFile = \"/etc/traefik/cert.pem\" keyFile = \"/etc/traefik/cert.key\"","title":"File"},{"location":"reference/providers/kubernetescrd/","text":"Kubernetes -- Reference \u00b6 Kubernetes \u00b6 ################################################################ # Kubernetes Provider ################################################################ apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute.crd spec: entrypoints: - web - web-secure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule priority: 12 # defining several services is possible and allowed, but for now the servers of # all the services (for a given route) get merged altogether under the same # load-balancing strategy. services: - name: s1 port: 80 healthcheck: path: /health host: baz.com intervalseconds: 7 timeoutseconds: 60 # strategy defines the load balancing strategy between the servers. It defaults # to Round Robin, and for now only Round Robin is supported anyway. strategy: RoundRobin - name: s2 port: 433 healthcheck: path: /health host: baz.com intervalseconds: 7 timeoutseconds: 60 - match: PathPrefix(`/misc`) services: - name: s3 port: 80 middleware: - name: stripprefix - name: addprefix tls: secretName: supersecret","title":""},{"location":"reference/providers/kubernetescrd/#kubernetes-reference","text":"","title":"Kubernetes -- Reference"},{"location":"reference/providers/kubernetescrd/#kubernetes","text":"################################################################ # Kubernetes Provider ################################################################ apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroute.crd spec: entrypoints: - web - web-secure routes: - match: Host(`foo.com`) && PathPrefix(`/bar`) kind: Rule priority: 12 # defining several services is possible and allowed, but for now the servers of # all the services (for a given route) get merged altogether under the same # load-balancing strategy. services: - name: s1 port: 80 healthcheck: path: /health host: baz.com intervalseconds: 7 timeoutseconds: 60 # strategy defines the load balancing strategy between the servers. It defaults # to Round Robin, and for now only Round Robin is supported anyway. strategy: RoundRobin - name: s2 port: 433 healthcheck: path: /health host: baz.com intervalseconds: 7 timeoutseconds: 60 - match: PathPrefix(`/misc`) services: - name: s3 port: 80 middleware: - name: stripprefix - name: addprefix tls: secretName: supersecret","title":"Kubernetes"},{"location":"routing/entrypoints/","text":"EntryPoints \u00b6 Opening Connections for Incoming Requests Entrypoints are the network entry points into Traefik. They define the port which will receive the requests (whether HTTP or TCP). Configuration Examples \u00b6 Port 80 only [entrypoints] [entrypoints.web] address = \":80\" We define an entrypoint called web that will listen on port 80 . Port 80 & 443 [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web-secure] address = \":443\" Two entrypoints are defined: one called web , and the other called web-secure . web listens on port 80 , and web-secure on port 443 . Configuration \u00b6 General \u00b6 Entrypoints are part of the static configuration . You can define them using a toml file, CLI arguments, or a key-value store. See the complete reference for the list of available options. Using the CLI Here is an example of using the CLI to define entrypoints : --entryPoints='Name:http Address::80' --entryPoints='Name:https Address::443' Note The whitespace character ( ) is the option separator, and the comma ( , ) is the value separator for lists. The option names are case-insensitive. Using Docker Compose Files The syntax for passing arguments inside a docker compose file is a little different. Here are two examples. traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image command: - --defaultentrypoints=powpow - \"--entryPoints=Name:powpow Address::42 Compress:true\" or traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image command: --defaultentrypoints=powpow --entryPoints='Name:powpow Address::42 Compress:true' ProxyProtocol \u00b6 Traefik supports ProxyProtocol . Enabling Proxy Protocol with Trusted IPs [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] IPs in trustedIPs only will lead to remote client address replacement: Declare load-balancer IPs or CIDR range here. Insecure Mode -- Testing Environnement Only In a test environments, you can configure Traefik to trust every incoming connection. Doing so, every remote client address will be replaced ( trustedIPs won't have any effect) [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] insecure = true Queuing Traefik behind Another Load Balancer When queuing Traefik behind another load-balancer, make sure to configure Proxy Protocol on both sides. Not doing so could introduce a security risk in your system (enabling request forgery). Forwarded Header \u00b6 You can configure Traefik to trust the forwarded headers information ( X-Forwarded-* ) Trusting Forwarded Headers from specific IPs [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.forwardedHeaders] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] Insecure Mode -- Always Trusting Forwarded Headers [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.forwardedHeaders] insecure = true","title":"Entrypoints"},{"location":"routing/entrypoints/#entrypoints","text":"Opening Connections for Incoming Requests Entrypoints are the network entry points into Traefik. They define the port which will receive the requests (whether HTTP or TCP).","title":"EntryPoints"},{"location":"routing/entrypoints/#configuration-examples","text":"Port 80 only [entrypoints] [entrypoints.web] address = \":80\" We define an entrypoint called web that will listen on port 80 . Port 80 & 443 [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web-secure] address = \":443\" Two entrypoints are defined: one called web , and the other called web-secure . web listens on port 80 , and web-secure on port 443 .","title":"Configuration Examples"},{"location":"routing/entrypoints/#configuration","text":"","title":"Configuration"},{"location":"routing/entrypoints/#general","text":"Entrypoints are part of the static configuration . You can define them using a toml file, CLI arguments, or a key-value store. See the complete reference for the list of available options. Using the CLI Here is an example of using the CLI to define entrypoints : --entryPoints='Name:http Address::80' --entryPoints='Name:https Address::443' Note The whitespace character ( ) is the option separator, and the comma ( , ) is the value separator for lists. The option names are case-insensitive. Using Docker Compose Files The syntax for passing arguments inside a docker compose file is a little different. Here are two examples. traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image command: - --defaultentrypoints=powpow - \"--entryPoints=Name:powpow Address::42 Compress:true\" or traefik: image: traefik:v2.0 # The official v2.0 Traefik docker image command: --defaultentrypoints=powpow --entryPoints='Name:powpow Address::42 Compress:true'","title":"General"},{"location":"routing/entrypoints/#proxyprotocol","text":"Traefik supports ProxyProtocol . Enabling Proxy Protocol with Trusted IPs [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] IPs in trustedIPs only will lead to remote client address replacement: Declare load-balancer IPs or CIDR range here. Insecure Mode -- Testing Environnement Only In a test environments, you can configure Traefik to trust every incoming connection. Doing so, every remote client address will be replaced ( trustedIPs won't have any effect) [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.proxyProtocol] insecure = true Queuing Traefik behind Another Load Balancer When queuing Traefik behind another load-balancer, make sure to configure Proxy Protocol on both sides. Not doing so could introduce a security risk in your system (enabling request forgery).","title":"ProxyProtocol"},{"location":"routing/entrypoints/#forwarded-header","text":"You can configure Traefik to trust the forwarded headers information ( X-Forwarded-* ) Trusting Forwarded Headers from specific IPs [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.forwardedHeaders] trustedIPs = [\"127.0.0.1/32\", \"192.168.1.7\"] Insecure Mode -- Always Trusting Forwarded Headers [entrypoints] [entrypoints.web] address = \":80\" [entrypoints.web.forwardedHeaders] insecure = true","title":"Forwarded Header"},{"location":"routing/overview/","text":"Overview \u00b6 What's Happening to the Requests? Let's zoom on Traefik's architecture and talk about the components that enable the routes to be created. First, when you start Traefik, you define entrypoints (in their most basic forms, they are port numbers). Then, connected to these entrypoints, routers analyze the incoming requests to see if they match a set of rules . If they do, the router might transform the request using pieces of middleware before forwarding them to your services . Clear Responsibilities \u00b6 Providers discover the services that live on your infrastructure (their IP, health, ...) Entrypoints listen for incomming traffic (ports, ...) Routers analyse the requests (host, path, headers, SSL, ...) Services forward the request to your services (load balancing, ...) Middlewares may update the request or make decisions based on the request (authentication, rate limiting, headers, ...) Example with a File Provider \u00b6 Below is an example of a full configuration file for the file provider that forwards http://domain/whoami/ requests to a service reachable on http://private/whoami-service/ . In the process, Traefik will make sure that the user is authenticated (using the BasicAuth middleware ). [entrypoints] [entrypoints.web] address = \":8081\" # Listen on port 8081 for incoming requests [providers] [providers.file] # Enable the file provider to define routers / middlewares / services in a file [http] # http routing section [http.routers] [http.routers.to-whoami] # Define a connection between requests and services rule = \"Host(domain) && PathPrefix(/whoami/)\" middlewares = [\"test-user\"] # If the rule matches, applies the middleware service = \"whoami\" # If the rule matches, forward to the whoami service (declared below) [http.middlewares] [http.middlewares.test-user.basicauth] # Define an authentication mechanism users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] [http.services.whoami.loadbalancer] # Define how to reach an existing service on our infrastructure [[http.services.whoami.loadbalancer.servers]] url = \"http://private/whoami-service\" The File Provider In this example, we use the file provider . Even if it is one of the least magical way of configuring Traefik, it explicitly describes every available notion. HTTP / TCP In this example, we've defined routing rules for http requests only. Traefik also supports TCP requests. To add TCP routers and TCP services , declare them in a TCP section like in the following. Adding a TCP route for TLS requests on whoami.traefik.io [entrypoints] [entrypoints.web] address = \":8081\" # Listen on port 8081 for incoming requests [providers] [providers.file] # Enable the file provider to define routers / middlewares / services in a file [http] # http routing section [http.routers] [http.routers.to-whoami] # Define a connection between requests and services rule = \"Host(`domain`) && PathPrefix(/whoami/)\" middlewares = [\"test-user\"] # If the rule matches, applies the middleware service = \"whoami\" # If the rule matches, forward to the whoami service (declared below) [http.middlewares] [http.middlewares.test-user.basicauth] # Define an authentication mechanism users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] [http.services.whoami.loadbalancer] # Define how to reach an existing service on our infrastructure [[http.services.whoami.loadbalancer.servers]] url = \"http://private/whoami-service\" [tcp] [tcp.routers] [tcp.routers.to-whoami-tcp] rule = \"HostSNI(`whoami-tcp.traefik.io`)\" service = \"whoami-tcp\" [tcp.routers.to-whoami-tcp.tls] [tcp.services] [tcp.services.whoami-tcp.loadbalancer] [[tcp.services.whoami-tcp.loadbalancer.servers]] address = \"xx.xx.xx.xx:xx\"","title":"Overview"},{"location":"routing/overview/#overview","text":"What's Happening to the Requests? Let's zoom on Traefik's architecture and talk about the components that enable the routes to be created. First, when you start Traefik, you define entrypoints (in their most basic forms, they are port numbers). Then, connected to these entrypoints, routers analyze the incoming requests to see if they match a set of rules . If they do, the router might transform the request using pieces of middleware before forwarding them to your services .","title":"Overview"},{"location":"routing/overview/#clear-responsibilities","text":"Providers discover the services that live on your infrastructure (their IP, health, ...) Entrypoints listen for incomming traffic (ports, ...) Routers analyse the requests (host, path, headers, SSL, ...) Services forward the request to your services (load balancing, ...) Middlewares may update the request or make decisions based on the request (authentication, rate limiting, headers, ...)","title":"Clear Responsibilities"},{"location":"routing/overview/#example-with-a-file-provider","text":"Below is an example of a full configuration file for the file provider that forwards http://domain/whoami/ requests to a service reachable on http://private/whoami-service/ . In the process, Traefik will make sure that the user is authenticated (using the BasicAuth middleware ). [entrypoints] [entrypoints.web] address = \":8081\" # Listen on port 8081 for incoming requests [providers] [providers.file] # Enable the file provider to define routers / middlewares / services in a file [http] # http routing section [http.routers] [http.routers.to-whoami] # Define a connection between requests and services rule = \"Host(domain) && PathPrefix(/whoami/)\" middlewares = [\"test-user\"] # If the rule matches, applies the middleware service = \"whoami\" # If the rule matches, forward to the whoami service (declared below) [http.middlewares] [http.middlewares.test-user.basicauth] # Define an authentication mechanism users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] [http.services.whoami.loadbalancer] # Define how to reach an existing service on our infrastructure [[http.services.whoami.loadbalancer.servers]] url = \"http://private/whoami-service\" The File Provider In this example, we use the file provider . Even if it is one of the least magical way of configuring Traefik, it explicitly describes every available notion. HTTP / TCP In this example, we've defined routing rules for http requests only. Traefik also supports TCP requests. To add TCP routers and TCP services , declare them in a TCP section like in the following. Adding a TCP route for TLS requests on whoami.traefik.io [entrypoints] [entrypoints.web] address = \":8081\" # Listen on port 8081 for incoming requests [providers] [providers.file] # Enable the file provider to define routers / middlewares / services in a file [http] # http routing section [http.routers] [http.routers.to-whoami] # Define a connection between requests and services rule = \"Host(`domain`) && PathPrefix(/whoami/)\" middlewares = [\"test-user\"] # If the rule matches, applies the middleware service = \"whoami\" # If the rule matches, forward to the whoami service (declared below) [http.middlewares] [http.middlewares.test-user.basicauth] # Define an authentication mechanism users = [\"test:$apr1$H6uskkkW$IgXLP6ewTrSuBkTrqE8wj/\"] [http.services] [http.services.whoami.loadbalancer] # Define how to reach an existing service on our infrastructure [[http.services.whoami.loadbalancer.servers]] url = \"http://private/whoami-service\" [tcp] [tcp.routers] [tcp.routers.to-whoami-tcp] rule = \"HostSNI(`whoami-tcp.traefik.io`)\" service = \"whoami-tcp\" [tcp.routers.to-whoami-tcp.tls] [tcp.services] [tcp.services.whoami-tcp.loadbalancer] [[tcp.services.whoami-tcp.loadbalancer.servers]] address = \"xx.xx.xx.xx:xx\"","title":"Example with a File Provider"},{"location":"routing/routers/","text":"Routers \u00b6 Connecting Requests to Services A router is in charge of connecting incoming requests to the services that can handle them. In the process, routers may use pieces of middleware to update the request, or act before forwarding the request to the service. Configuration Example \u00b6 Requests /foo are Handled by service-foo -- Using the File Provider [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" service = \"service-foo\" With a middleware -- using the File Provider [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" middlewares = [\"authentication\"] # declared elsewhere service = \"service-foo\" Forwarding all (non-tls) requests on port 3306 to a database service [entrypoints] [entrypoints.mysql-default] address = \":80\" [entrypoints.mysql-default] address = \":3306\" [tcp] [tcp.routers] [tcp.routers.to-database] entrypoints = [\"mysql-default\"] rule = \"HostSNI(`*`)\" # Catch every request (only available rule for non-tls routers. See below.) service = \"database\" Configuring HTTP Routers \u00b6 EntryPoints \u00b6 If not specified, HTTP routers will accept requests from all defined entrypoints. If you want to limit the router scope to a set of entrypoint, set the entrypoints option. Listens to Every EntryPoint [entrypoints] [entrypoints.web] # ... [entrypoints.web-secure] # ... [entrypoints.other] # ... [http.routers] [http.routers.Router-1] # By default, routers listen to every entrypoints rule = \"Host(`traefik.io`)\" service = \"service-1\" Listens to Specific EntryPoints [entrypoints] [entrypoints.web] # ... [entrypoint.web-secure] # ... [entrypoint.other] # ... [http.routers] [http.routers.Router-1] entryPoints = [\"web-secure\", \"other\"] # won't listen to entrypoint web rule = \"Host(`traefik.io`)\" service = \"service-1\" Rule \u00b6 Rules are a set of matchers that determine if a particular request matches specific criteria. If the rule is verified, then the router becomes active and calls middlewares, then forward the request to the service. Host is traefik.io rule = \"Host(`traefik.io`)\" Host is traefik.io OR Host is containo.us AND path is /traefik rule = \"Host(`traefik.io`) || (Host(`containo.us`) && Path(`/traefik`))\" The table below lists all the available matchers: Rule Description Headers(`key`, `value`) Check if there is a key key defined in the headers, with the value value HeadersRegexp(`key`, `regexp`) Check if there is a key key defined in the headers, with a value that matches the regular expression regexp Host(`domain-1`, ...) Check if the request domain targets one of the given domains . HostRegexp(`traefik.io`, `{subdomain:[a-z]+}.traefik.io`, ...) Check if the request domain matches the given regexp . Method(methods, ...) Check if the request method is one of the given methods ( GET , POST , PUT , DELETE , PATCH ) Path(`path`, `/articles/{category}/{id:[0-9]+}`, ...) Match exact request path. It accepts a sequence of literal and regular expression paths. PathPrefix(`/products/`, `/articles/{category}/{id:[0-9]+}`) Match request prefix path. It accepts a sequence of literal and regular expression prefix paths. Query(`foo=bar`, `bar=baz`) Match` Query String parameters. It accepts a sequence of key=value pairs. Regexp Syntax In order to use regular expressions with Host and Path expressions, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by Go's regexp package may be used (example: /posts/{id:[0-9]+} ). Combining Matchers Using Operators and Parenthesis You can combine multiple matchers using the AND ( && ) and OR (`||) operators. You can also use parenthesis. Rule, Middleware, and Services The rule is evaluated \"before\" any middleware has the opportunity to work, and \"before\" the request is forwarded to the service. Path Vs PathPrefix Use Path if your service listens on the exact path only. For instance, Path: /products would match /products but not /products/shoes . Use a *Prefix* matcher if your service listens on a particular base path but also serves requests on sub-paths. For instance, PathPrefix: /products would match /products but also /products/shoes and /products/shirts . Since the path is forwarded as-is, your service is expected to listen on /products . Middlewares \u00b6 You can attach a list of middlewares to each HTTP router. The middlewares will take effect only if the rule matches, and before forwarding the request to the service. Service \u00b6 You must attach a service per router. Services are the target for the router. HTTP Only HTTP routers can only target HTTP services (not TCP services). TLS \u00b6 When specifying a TLS section, you tell Traefik that the current router is dedicated to HTTPS requests only (and that the router should ignore HTTP (non tls) requests). Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services). Configuring the router to accept HTTPS requests only [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" [http.routers.Router-1.tls] # will terminate the TLS request HTTPS & ACME In the current version, with ACME enabled, automatic certificate generation will apply to every router declaring a TLS section. In the near future, options will be available to enable fine-grain control of the TLS parameters. Passthrough On TCP routers, you can configure a passthrough option so that Traefik doesn't terminate the TLS connection. Routers for HTTP & HTTPS If you need to define the same route for both HTTP and HTTPS requests, you will need to define two different routers: one with the tls section, one without. HTTP & HTTPS routes [http.routers] [http.routers.Router-1-https] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" [http.routers.Router-1.tls] # will terminate the TLS request [http.routers.Router-1-http] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" Configuring TCP Routers \u00b6 General \u00b6 If both HTTP routers and TCP routers listen to the same entrypoints, the TCP routers will apply before the HTTP routers. If no matching route is found for the TCP routers, then the HTTP routers will take over. EntryPoints \u00b6 If not specified, TCP routers will accept requests from all defined entrypoints. If you want to limit the router scope to a set of entrypoints, set the entrypoints option. Listens to Every EntryPoint [entrypoints] [entrypoints.web] # ... [entrypoints.web-secure] # ... [entrypoints.other] # ... [tcp.routers] [tcp.routers.Router-1] # By default, routers listen to every entrypoints rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" [tcp.routers.Router-1.tls] # will route TLS requests (and ignore non tls requests) Listens to Specific EntryPoints [entrypoints] [entrypoints.web] # ... [entrypoint.web-secure] # ... [entrypoint.other] # ... [tcp.routers] [tcp.routers.Router-1] entryPoints = [\"web-secure\", \"other\"] # won't listen to entrypoint web rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" [tcp.routers.Router-1.tls] # will route TLS requests (and ignore non tls requests) Rule \u00b6 Rule Description HostSNI(`domain-1`, ...) Check if the Server Name Indication corresponds to the given domains . HostSNI & TLS It is important to note that the Server Name Indication is an extension of the TLS protocol. Hence, only TLS routers will be able to specify a domain name with that rule. However, non-TLS routers will have to explicitly use that rule with * (every domain) to state that every non-TLS request will be handled by the router. Services \u00b6 You must attach a TCP service per TCP router. Services are the target for the router. TCP Only TCP routers can only target TCP services (not HTTP services). TLS \u00b6 When specifying a TLS section, you tell Traefik that the current router is dedicated to TLS requests only (and that the router should ignore non-tls requests). By default, Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services), but you can tell Traefik that the request should pass through (keeping the encrypted data) and be forwarded to the service \"as is\". Configuring TLS Termination [tcp.routers] [tcp.routers.Router-1] rule = \"Host(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] # will terminate the TLS request by default Configuring passthrough [tcp.routers] [tcp.routers.Router-1] rule = \"Host(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] passthrough=true TLS & ACME In the current version, with ACME enabled, automatic certificate generation will apply to every router declaring a TLS section. In the near future, options will be available to enable fine-grain control of the TLS parameters.","title":"Routers"},{"location":"routing/routers/#routers","text":"Connecting Requests to Services A router is in charge of connecting incoming requests to the services that can handle them. In the process, routers may use pieces of middleware to update the request, or act before forwarding the request to the service.","title":"Routers"},{"location":"routing/routers/#configuration-example","text":"Requests /foo are Handled by service-foo -- Using the File Provider [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" service = \"service-foo\" With a middleware -- using the File Provider [http.routers] [http.routers.my-router] rule = \"Path(`/foo`)\" middlewares = [\"authentication\"] # declared elsewhere service = \"service-foo\" Forwarding all (non-tls) requests on port 3306 to a database service [entrypoints] [entrypoints.mysql-default] address = \":80\" [entrypoints.mysql-default] address = \":3306\" [tcp] [tcp.routers] [tcp.routers.to-database] entrypoints = [\"mysql-default\"] rule = \"HostSNI(`*`)\" # Catch every request (only available rule for non-tls routers. See below.) service = \"database\"","title":"Configuration Example"},{"location":"routing/routers/#configuring-http-routers","text":"","title":"Configuring HTTP Routers"},{"location":"routing/routers/#entrypoints","text":"If not specified, HTTP routers will accept requests from all defined entrypoints. If you want to limit the router scope to a set of entrypoint, set the entrypoints option. Listens to Every EntryPoint [entrypoints] [entrypoints.web] # ... [entrypoints.web-secure] # ... [entrypoints.other] # ... [http.routers] [http.routers.Router-1] # By default, routers listen to every entrypoints rule = \"Host(`traefik.io`)\" service = \"service-1\" Listens to Specific EntryPoints [entrypoints] [entrypoints.web] # ... [entrypoint.web-secure] # ... [entrypoint.other] # ... [http.routers] [http.routers.Router-1] entryPoints = [\"web-secure\", \"other\"] # won't listen to entrypoint web rule = \"Host(`traefik.io`)\" service = \"service-1\"","title":"EntryPoints"},{"location":"routing/routers/#rule","text":"Rules are a set of matchers that determine if a particular request matches specific criteria. If the rule is verified, then the router becomes active and calls middlewares, then forward the request to the service. Host is traefik.io rule = \"Host(`traefik.io`)\" Host is traefik.io OR Host is containo.us AND path is /traefik rule = \"Host(`traefik.io`) || (Host(`containo.us`) && Path(`/traefik`))\" The table below lists all the available matchers: Rule Description Headers(`key`, `value`) Check if there is a key key defined in the headers, with the value value HeadersRegexp(`key`, `regexp`) Check if there is a key key defined in the headers, with a value that matches the regular expression regexp Host(`domain-1`, ...) Check if the request domain targets one of the given domains . HostRegexp(`traefik.io`, `{subdomain:[a-z]+}.traefik.io`, ...) Check if the request domain matches the given regexp . Method(methods, ...) Check if the request method is one of the given methods ( GET , POST , PUT , DELETE , PATCH ) Path(`path`, `/articles/{category}/{id:[0-9]+}`, ...) Match exact request path. It accepts a sequence of literal and regular expression paths. PathPrefix(`/products/`, `/articles/{category}/{id:[0-9]+}`) Match request prefix path. It accepts a sequence of literal and regular expression prefix paths. Query(`foo=bar`, `bar=baz`) Match` Query String parameters. It accepts a sequence of key=value pairs. Regexp Syntax In order to use regular expressions with Host and Path expressions, you must declare an arbitrarily named variable followed by the colon-separated regular expression, all enclosed in curly braces. Any pattern supported by Go's regexp package may be used (example: /posts/{id:[0-9]+} ). Combining Matchers Using Operators and Parenthesis You can combine multiple matchers using the AND ( && ) and OR (`||) operators. You can also use parenthesis. Rule, Middleware, and Services The rule is evaluated \"before\" any middleware has the opportunity to work, and \"before\" the request is forwarded to the service. Path Vs PathPrefix Use Path if your service listens on the exact path only. For instance, Path: /products would match /products but not /products/shoes . Use a *Prefix* matcher if your service listens on a particular base path but also serves requests on sub-paths. For instance, PathPrefix: /products would match /products but also /products/shoes and /products/shirts . Since the path is forwarded as-is, your service is expected to listen on /products .","title":"Rule"},{"location":"routing/routers/#middlewares","text":"You can attach a list of middlewares to each HTTP router. The middlewares will take effect only if the rule matches, and before forwarding the request to the service.","title":"Middlewares"},{"location":"routing/routers/#service","text":"You must attach a service per router. Services are the target for the router. HTTP Only HTTP routers can only target HTTP services (not TCP services).","title":"Service"},{"location":"routing/routers/#tls","text":"When specifying a TLS section, you tell Traefik that the current router is dedicated to HTTPS requests only (and that the router should ignore HTTP (non tls) requests). Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services). Configuring the router to accept HTTPS requests only [http.routers] [http.routers.Router-1] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" [http.routers.Router-1.tls] # will terminate the TLS request HTTPS & ACME In the current version, with ACME enabled, automatic certificate generation will apply to every router declaring a TLS section. In the near future, options will be available to enable fine-grain control of the TLS parameters. Passthrough On TCP routers, you can configure a passthrough option so that Traefik doesn't terminate the TLS connection. Routers for HTTP & HTTPS If you need to define the same route for both HTTP and HTTPS requests, you will need to define two different routers: one with the tls section, one without. HTTP & HTTPS routes [http.routers] [http.routers.Router-1-https] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\" [http.routers.Router-1.tls] # will terminate the TLS request [http.routers.Router-1-http] rule = \"Host(`foo-domain`) && Path(`/foo-path/`)\" service = \"service-id\"","title":"TLS"},{"location":"routing/routers/#configuring-tcp-routers","text":"","title":"Configuring TCP Routers"},{"location":"routing/routers/#general","text":"If both HTTP routers and TCP routers listen to the same entrypoints, the TCP routers will apply before the HTTP routers. If no matching route is found for the TCP routers, then the HTTP routers will take over.","title":"General"},{"location":"routing/routers/#entrypoints_1","text":"If not specified, TCP routers will accept requests from all defined entrypoints. If you want to limit the router scope to a set of entrypoints, set the entrypoints option. Listens to Every EntryPoint [entrypoints] [entrypoints.web] # ... [entrypoints.web-secure] # ... [entrypoints.other] # ... [tcp.routers] [tcp.routers.Router-1] # By default, routers listen to every entrypoints rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" [tcp.routers.Router-1.tls] # will route TLS requests (and ignore non tls requests) Listens to Specific EntryPoints [entrypoints] [entrypoints.web] # ... [entrypoint.web-secure] # ... [entrypoint.other] # ... [tcp.routers] [tcp.routers.Router-1] entryPoints = [\"web-secure\", \"other\"] # won't listen to entrypoint web rule = \"HostSNI(`traefik.io`)\" service = \"service-1\" [tcp.routers.Router-1.tls] # will route TLS requests (and ignore non tls requests)","title":"EntryPoints"},{"location":"routing/routers/#rule_1","text":"Rule Description HostSNI(`domain-1`, ...) Check if the Server Name Indication corresponds to the given domains . HostSNI & TLS It is important to note that the Server Name Indication is an extension of the TLS protocol. Hence, only TLS routers will be able to specify a domain name with that rule. However, non-TLS routers will have to explicitly use that rule with * (every domain) to state that every non-TLS request will be handled by the router.","title":"Rule"},{"location":"routing/routers/#services","text":"You must attach a TCP service per TCP router. Services are the target for the router. TCP Only TCP routers can only target TCP services (not HTTP services).","title":"Services"},{"location":"routing/routers/#tls_1","text":"When specifying a TLS section, you tell Traefik that the current router is dedicated to TLS requests only (and that the router should ignore non-tls requests). By default, Traefik will terminate the SSL connections (meaning that it will send decrypted data to the services), but you can tell Traefik that the request should pass through (keeping the encrypted data) and be forwarded to the service \"as is\". Configuring TLS Termination [tcp.routers] [tcp.routers.Router-1] rule = \"Host(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] # will terminate the TLS request by default Configuring passthrough [tcp.routers] [tcp.routers.Router-1] rule = \"Host(`foo-domain`)\" service = \"service-id\" [tcp.routers.Router-1.tls] passthrough=true TLS & ACME In the current version, with ACME enabled, automatic certificate generation will apply to every router declaring a TLS section. In the near future, options will be available to enable fine-grain control of the TLS parameters.","title":"TLS"},{"location":"routing/services/","text":"Services \u00b6 Configuring How to Reach the Services The Services are responsible for configuring how to reach the actual services that will eventually handle the incoming requests. Configuration Example \u00b6 Declaring an HTTP Service with Two Servers -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"wrr\" # Load Balancing based on weights [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 30 # 30% of the requests will go to that instance [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-2/\" weight = 70 # 70% of the requests will go to that instance Declaring a TCP Service with Two Servers -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" Configuring HTTP Services \u00b6 General \u00b6 Currently, LoadBalancer is the only supported kind of HTTP Service (see below). However, since Traefik is an ever evolving project, other kind of HTTP Services will be available in the future, reason why you have to specify it. Load Balancer \u00b6 The load balancers are able to load balance the requests between multiple instances of your programs. Declaring a Service with Two Servers (with Load Balancing) -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"wrr\" # Load Balancing based on weights [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 50 # 50% of the requests will go to that instance [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-2/\" weight = 50 # 50% of the requests will go to that instance Servers \u00b6 Servers declare a single instance of your program. The url option point to a specific instance. The weight option defines the weight of the server for the load balancing algorithm. Note Paths in the servers' url have no effet. If you want the requests to be sent to a specific path on your servers, configure your routers to use a corresponding middleware (e.g. the AddPrefix or ReplacePath ) middlewares. A Service with One Server -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1 Load-balancing \u00b6 Various methods of load balancing are supported: wrr : Weighted Round Robin. drr : Dynamic Round Robin: increases weights on servers that perform better than others (rolls back to original weights when the server list is updated) Load Balancing Using DRR -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"drr\" [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1 [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1 Sticky sessions \u00b6 When sticky sessions are enabled, a cookie is set on the initial request to track which server handles the first response. On subsequent requests, the client is forwarded to the same server. Stickiness & Unhealthy Servers If the server specified in the cookie becomes unhealthy, the request will be forwarded to a new server (and the cookie will keep track of the new server). Cookie Name The default cookie name is an abbreviation of a sha1 (ex: _1d52e ). Adding Stickiness [http.services] [http.services.my-service] [http.services.my-service.LoadBalancer.stickiness] Adding Stickiness with a Custom Cookie Name [http.services] [http.services.my-service] [http.services.my-service.LoadBalancer.stickiness] cookieName = \"my_stickiness_cookie_name\" Health Check \u00b6 Configure healthcheck to remove unhealthy servers from the load balancing rotation. Traefik will consider your servers healthy as long as they return status codes between 2XX and 3XX to the health check requests (carried out every interval ). Below are the available options for the health check mechanism: path is appended to the server URL to set the healcheck endpoint. scheme , if defined, will replace the server URL scheme for the healthcheck endpoint hostname , if defined, will replace the server URL hostname for the healthcheck endpoint. port , if defined, will replace the server URL port for the healthcheck endpoint. interval defines the frequency of the healthcheck calls. timeout defines the maximum duration Traefik will wait for a healthcheck request before considering the server failed (unhealthy). headers defines custom headers to be sent to the healthcheck endpoint. Interval & Timeout Format Interval and timeout are to be given in a format understood by time.ParseDuration . The interval must be greater than the timeout. If configuration doesn't reflect this, the interval will be set to timeout + 1 second. Recovering Servers Traefik keeps monitoring the health of unhealthy servers. If a server has recovered (returning 2xx -> 3xx responses again), it will be added back to the load balacer rotation pool. Custom Interval & Timeout -- Using the File Provider [http.services] [http.servicess.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" interval = \"10s\" timeout = \"3s\" Custom Port -- Using the File Provider [http.services] [http.services.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" port = 8080 Custom Scheme -- Using the File Provider [http.services] [http.services.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" scheme = \"http\" Additional HTTP Headers -- Using the File Provider [http.services] [http.services.Service-1] [http.servicess.Service-1.healthcheck] path = \"/health\" [Service.Service-1.healthcheck.headers] My-Custom-Header = \"foo\" My-Header = \"bar\" Configuring TCP Services \u00b6 General \u00b6 Currently, LoadBalancer is the only supported kind of TCP Service . However, since Traefik is an ever evolving project, other kind of TCP Services will be available in the future, reason why you have to specify it. Load Balancer \u00b6 The load balancers are able to load balance the requests between multiple instances of your programs. Declaring a Service with Two Servers -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" Servers \u00b6 Servers declare a single instance of your program. The address option (IP:Port) point to a specific instance. A Service with One Server -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" Weight The TCP LoadBalancer is currently a round robin only implementation and doesn't yet support weights.","title":"Services"},{"location":"routing/services/#services","text":"Configuring How to Reach the Services The Services are responsible for configuring how to reach the actual services that will eventually handle the incoming requests.","title":"Services"},{"location":"routing/services/#configuration-example","text":"Declaring an HTTP Service with Two Servers -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"wrr\" # Load Balancing based on weights [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 30 # 30% of the requests will go to that instance [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-2/\" weight = 70 # 70% of the requests will go to that instance Declaring a TCP Service with Two Servers -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\"","title":"Configuration Example"},{"location":"routing/services/#configuring-http-services","text":"","title":"Configuring HTTP Services"},{"location":"routing/services/#general","text":"Currently, LoadBalancer is the only supported kind of HTTP Service (see below). However, since Traefik is an ever evolving project, other kind of HTTP Services will be available in the future, reason why you have to specify it.","title":"General"},{"location":"routing/services/#load-balancer","text":"The load balancers are able to load balance the requests between multiple instances of your programs. Declaring a Service with Two Servers (with Load Balancing) -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"wrr\" # Load Balancing based on weights [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 50 # 50% of the requests will go to that instance [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-2/\" weight = 50 # 50% of the requests will go to that instance","title":"Load Balancer"},{"location":"routing/services/#servers","text":"Servers declare a single instance of your program. The url option point to a specific instance. The weight option defines the weight of the server for the load balancing algorithm. Note Paths in the servers' url have no effet. If you want the requests to be sent to a specific path on your servers, configure your routers to use a corresponding middleware (e.g. the AddPrefix or ReplacePath ) middlewares. A Service with One Server -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1","title":"Servers"},{"location":"routing/services/#load-balancing","text":"Various methods of load balancing are supported: wrr : Weighted Round Robin. drr : Dynamic Round Robin: increases weights on servers that perform better than others (rolls back to original weights when the server list is updated) Load Balancing Using DRR -- Using the File Provider [http.services] [http.services.my-service.LoadBalancer] method = \"drr\" [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1 [[http.services.my-service.LoadBalancer.servers]] url = \"http://private-ip-server-1/\" weight = 1","title":"Load-balancing"},{"location":"routing/services/#sticky-sessions","text":"When sticky sessions are enabled, a cookie is set on the initial request to track which server handles the first response. On subsequent requests, the client is forwarded to the same server. Stickiness & Unhealthy Servers If the server specified in the cookie becomes unhealthy, the request will be forwarded to a new server (and the cookie will keep track of the new server). Cookie Name The default cookie name is an abbreviation of a sha1 (ex: _1d52e ). Adding Stickiness [http.services] [http.services.my-service] [http.services.my-service.LoadBalancer.stickiness] Adding Stickiness with a Custom Cookie Name [http.services] [http.services.my-service] [http.services.my-service.LoadBalancer.stickiness] cookieName = \"my_stickiness_cookie_name\"","title":"Sticky sessions"},{"location":"routing/services/#health-check","text":"Configure healthcheck to remove unhealthy servers from the load balancing rotation. Traefik will consider your servers healthy as long as they return status codes between 2XX and 3XX to the health check requests (carried out every interval ). Below are the available options for the health check mechanism: path is appended to the server URL to set the healcheck endpoint. scheme , if defined, will replace the server URL scheme for the healthcheck endpoint hostname , if defined, will replace the server URL hostname for the healthcheck endpoint. port , if defined, will replace the server URL port for the healthcheck endpoint. interval defines the frequency of the healthcheck calls. timeout defines the maximum duration Traefik will wait for a healthcheck request before considering the server failed (unhealthy). headers defines custom headers to be sent to the healthcheck endpoint. Interval & Timeout Format Interval and timeout are to be given in a format understood by time.ParseDuration . The interval must be greater than the timeout. If configuration doesn't reflect this, the interval will be set to timeout + 1 second. Recovering Servers Traefik keeps monitoring the health of unhealthy servers. If a server has recovered (returning 2xx -> 3xx responses again), it will be added back to the load balacer rotation pool. Custom Interval & Timeout -- Using the File Provider [http.services] [http.servicess.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" interval = \"10s\" timeout = \"3s\" Custom Port -- Using the File Provider [http.services] [http.services.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" port = 8080 Custom Scheme -- Using the File Provider [http.services] [http.services.Service-1] [http.services.Service-1.healthcheck] path = \"/health\" scheme = \"http\" Additional HTTP Headers -- Using the File Provider [http.services] [http.services.Service-1] [http.servicess.Service-1.healthcheck] path = \"/health\" [Service.Service-1.healthcheck.headers] My-Custom-Header = \"foo\" My-Header = \"bar\"","title":"Health Check"},{"location":"routing/services/#configuring-tcp-services","text":"","title":"Configuring TCP Services"},{"location":"routing/services/#general_1","text":"Currently, LoadBalancer is the only supported kind of TCP Service . However, since Traefik is an ever evolving project, other kind of TCP Services will be available in the future, reason why you have to specify it.","title":"General"},{"location":"routing/services/#load-balancer_1","text":"The load balancers are able to load balance the requests between multiple instances of your programs. Declaring a Service with Two Servers -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\"","title":"Load Balancer"},{"location":"routing/services/#servers_1","text":"Servers declare a single instance of your program. The address option (IP:Port) point to a specific instance. A Service with One Server -- Using the File Provider [tcp.services] [tcp.services.my-service.LoadBalancer] [[tcp.services.my-service.LoadBalancer.servers]] address = \"xx.xx.xx.xx:xx\" Weight The TCP LoadBalancer is currently a round robin only implementation and doesn't yet support weights.","title":"Servers"},{"location":"user-guides/crd-acme/","text":"Traefik & CRD & Let's Encrypt \u00b6 Traefik with an IngressRoute Custom Resource Definition for Kubernetes, and TLS Through Let's Encrypt. This document is intended to be a fully working example demonstrating how to set up Traefik in Kubernetes , with the dynamic configuration coming from the IngressRoute Custom Resource , and TLS setup with Let's Encrypt . However, for the sake of simplicity, we're using k3s docker image for the Kubernetes cluster setup. Please note that for this setup, given that we're going to use ACME's TLS-ALPN-01 challenge, the host you'll be running it on must be able to receive connections from the outside on port 443. And of course its internet facing IP address must match the domain name you intend to use. In the following, the Kubernetes resources defined in YAML configuration files can be applied to the setup in two different ways: the first, and usual way, is simply with the kubectl apply command. the second, which can be used for this tutorial, is to directly place the files in the directory used by the k3s docker image for such inputs ( /var/lib/rancher/k3s/server/manifests ). k3s Docker-compose Configuration \u00b6 Our starting point is the docker-compose configuration file, to start the k3s cluster. You can start it with: docker-compose -f k3s.yml up server: image: rancher/k3s:v0.2.0 command: server --disable-agent --no-deploy traefik environment: - K3S_CLUSTER_SECRET=somethingtotallyrandom - K3S_KUBECONFIG_OUTPUT=/output/kubeconfig.yaml - K3S_KUBECONFIG_MODE=666 volumes: # k3s will generate a kubeconfig.yaml in this directory. This volume is mounted # on your host, so you can then 'export KUBECONFIG=/somewhere/on/your/host/out/kubeconfig.yaml', # in order for your kubectl commands to work. - /somewhere/on/your/host/out:/output # This directory is where you put all the (yaml) configuration files of # the Kubernetes resources. - /somewhere/on/your/host/in:/var/lib/rancher/k3s/server/manifests ports: - 6443:6443 node: image: rancher/k3s:v0.2.0 privileged: true links: - server environment: - K3S_URL=https://server:6443 - K3S_CLUSTER_SECRET=somethingtotallyrandom volumes: # this is where you would place a alternative traefik image (saved as a .tar file with # 'docker save'), if you want to use it, instead of the traefik:v2.0 image. - /sowewhere/on/your/host/custom-image:/var/lib/rancher/k3s/agent/images Cluster Resources \u00b6 Let's now have a look (in the order they should be applied, if using kubectl apply ) at all the required resources for the full setup. IngressRoute Definition \u00b6 First, the definition of the IngressRoute and the Middleware kinds. Also note the RBAC authorization resources; they'll be referenced through the serviceAccountName of the deployment, later on. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller rules: - apiGroups: - \"\" resources: - services - endpoints - secrets verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses/status verbs: - update - apiGroups: - traefik.containo.us resources: - middlewares verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutes verbs: - get - list - watch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: traefik-ingress-controller subjects: - kind: ServiceAccount name: traefik-ingress-controller namespace: default Services \u00b6 Then, the services. One for Traefik itself, and one for the app it routes for, i.e. in this case our demo HTTP server: whoami . apiVersion: v1 kind: Service metadata: name: traefik spec: ports: - protocol: TCP name: web port: 8000 - protocol: TCP name: admin port: 8080 - protocol: TCP name: websecure port: 4443 selector: app: traefik --- apiVersion: v1 kind: Service metadata: name: whoami spec: ports: - protocol: TCP name: web port: 80 selector: app: whoami Deployments \u00b6 Next, the deployments, i.e. the actual pods behind the services. Again, one pod for Traefik, and one for the whoami app. apiVersion: v1 kind: ServiceAccount metadata: namespace: default name: traefik-ingress-controller --- kind: Deployment apiVersion: extensions/v1beta1 metadata: namespace: default name: traefik labels: app: traefik spec: replicas: 1 selector: matchLabels: app: traefik template: metadata: labels: app: traefik spec: serviceAccountName: traefik-ingress-controller containers: - name: traefik image: traefik:v2.0 args: - --api - --accesslog - --entrypoints=Name:web Address::8000 - --entrypoints=Name:websecure Address::4443 - --providers.kubernetescrd - --providers.kubernetescrd.trace - --acme - --acme.acmelogging - --acme.tlschallenge - --acme.onhostrule - --acme.email=foo@you.com - --acme.entrypoint=websecure - --acme.storage=acme.json # Please note that this is the staging Let's Encrypt server. # Once you get things working, you should remove that whole line altogether. - --acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory ports: - name: web containerPort: 8000 - name: websecure containerPort: 4443 - name: admin containerPort: 8080 --- kind: Deployment apiVersion: extensions/v1beta1 metadata: namespace: default name: whoami labels: app: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: containers: - name: whoami image: containous/whoami ports: - name: web containerPort: 80 Port Forwarding \u00b6 Now, as an exception to what we said above, please note that you should not let the ingressRoute resources below be applied automatically to your cluster. The reason is, as soon as the ACME provider of Traefik detects we have TLS routers, it will try to generate the certificates for the corresponding domains. And this will not work, because as it is, our Traefik pod is not reachable from the outside, which will make the ACME TLS challenge fail. Therefore, for the whole thing to work, we must delay applying the ingressRoute resources until we have port-forwarding set up properly, which is the next step. kubectl port-forward --address 0.0.0.0 service/traefik 8000:8000 8080:8080 443:4443 -n default Also, and this is out of the scope if this guide, please note that because of the privileged ports limitation on Linux, the above command might fail to listen on port 443. In which case you can use tricks such as elevating caps of kubectl with setcaps , or using authbind , or setting up a NAT between your host and the WAN. Look it up. Traefik Routers \u00b6 We can now finally apply the actual ingressRoutes, with: kubectl apply -f 04-ingressroutes.yml apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: simpleingressroute spec: entrypoints: - web routes: - match: Host(`your.domain.com`) && PathPrefix(`/notls`) kind: Rule services: - name: whoami port: 80 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls spec: entrypoints: - websecure routes: - match: Host(`your.domain.com`) && PathPrefix(`/tls`) kind: Rule services: - name: whoami port: 80 tls: secretName: \"\" Give it a few seconds for the ACME TLS challenge to complete, and you should then be able to access your whoami pod (routed through Traefik), from the outside. Both with or (just for fun, do not do that in production) without TLS: curl [-k] https://your.domain.com/tls curl [-k] http://your.domain.com:8000/notls Note that you'll have to use -k as long as you're using the staging server of Let's Encrypt, since it is not in the root DNS servers.","title":"Kubernetes and Let's Encrypt"},{"location":"user-guides/crd-acme/#traefik-crd-lets-encrypt","text":"Traefik with an IngressRoute Custom Resource Definition for Kubernetes, and TLS Through Let's Encrypt. This document is intended to be a fully working example demonstrating how to set up Traefik in Kubernetes , with the dynamic configuration coming from the IngressRoute Custom Resource , and TLS setup with Let's Encrypt . However, for the sake of simplicity, we're using k3s docker image for the Kubernetes cluster setup. Please note that for this setup, given that we're going to use ACME's TLS-ALPN-01 challenge, the host you'll be running it on must be able to receive connections from the outside on port 443. And of course its internet facing IP address must match the domain name you intend to use. In the following, the Kubernetes resources defined in YAML configuration files can be applied to the setup in two different ways: the first, and usual way, is simply with the kubectl apply command. the second, which can be used for this tutorial, is to directly place the files in the directory used by the k3s docker image for such inputs ( /var/lib/rancher/k3s/server/manifests ).","title":"Traefik &amp; CRD &amp; Let's Encrypt"},{"location":"user-guides/crd-acme/#k3s-docker-compose-configuration","text":"Our starting point is the docker-compose configuration file, to start the k3s cluster. You can start it with: docker-compose -f k3s.yml up server: image: rancher/k3s:v0.2.0 command: server --disable-agent --no-deploy traefik environment: - K3S_CLUSTER_SECRET=somethingtotallyrandom - K3S_KUBECONFIG_OUTPUT=/output/kubeconfig.yaml - K3S_KUBECONFIG_MODE=666 volumes: # k3s will generate a kubeconfig.yaml in this directory. This volume is mounted # on your host, so you can then 'export KUBECONFIG=/somewhere/on/your/host/out/kubeconfig.yaml', # in order for your kubectl commands to work. - /somewhere/on/your/host/out:/output # This directory is where you put all the (yaml) configuration files of # the Kubernetes resources. - /somewhere/on/your/host/in:/var/lib/rancher/k3s/server/manifests ports: - 6443:6443 node: image: rancher/k3s:v0.2.0 privileged: true links: - server environment: - K3S_URL=https://server:6443 - K3S_CLUSTER_SECRET=somethingtotallyrandom volumes: # this is where you would place a alternative traefik image (saved as a .tar file with # 'docker save'), if you want to use it, instead of the traefik:v2.0 image. - /sowewhere/on/your/host/custom-image:/var/lib/rancher/k3s/agent/images","title":"k3s Docker-compose Configuration"},{"location":"user-guides/crd-acme/#cluster-resources","text":"Let's now have a look (in the order they should be applied, if using kubectl apply ) at all the required resources for the full setup.","title":"Cluster Resources"},{"location":"user-guides/crd-acme/#ingressroute-definition","text":"First, the definition of the IngressRoute and the Middleware kinds. Also note the RBAC authorization resources; they'll be referenced through the serviceAccountName of the deployment, later on. apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: ingressroutes.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: IngressRoute plural: ingressroutes singular: ingressroute scope: Namespaced --- apiVersion: apiextensions.k8s.io/v1beta1 kind: CustomResourceDefinition metadata: name: middlewares.traefik.containo.us spec: group: traefik.containo.us version: v1alpha1 names: kind: Middleware plural: middlewares singular: middleware scope: Namespaced --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller rules: - apiGroups: - \"\" resources: - services - endpoints - secrets verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses verbs: - get - list - watch - apiGroups: - extensions resources: - ingresses/status verbs: - update - apiGroups: - traefik.containo.us resources: - middlewares verbs: - get - list - watch - apiGroups: - traefik.containo.us resources: - ingressroutes verbs: - get - list - watch --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: traefik-ingress-controller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: traefik-ingress-controller subjects: - kind: ServiceAccount name: traefik-ingress-controller namespace: default","title":"IngressRoute Definition"},{"location":"user-guides/crd-acme/#services","text":"Then, the services. One for Traefik itself, and one for the app it routes for, i.e. in this case our demo HTTP server: whoami . apiVersion: v1 kind: Service metadata: name: traefik spec: ports: - protocol: TCP name: web port: 8000 - protocol: TCP name: admin port: 8080 - protocol: TCP name: websecure port: 4443 selector: app: traefik --- apiVersion: v1 kind: Service metadata: name: whoami spec: ports: - protocol: TCP name: web port: 80 selector: app: whoami","title":"Services"},{"location":"user-guides/crd-acme/#deployments","text":"Next, the deployments, i.e. the actual pods behind the services. Again, one pod for Traefik, and one for the whoami app. apiVersion: v1 kind: ServiceAccount metadata: namespace: default name: traefik-ingress-controller --- kind: Deployment apiVersion: extensions/v1beta1 metadata: namespace: default name: traefik labels: app: traefik spec: replicas: 1 selector: matchLabels: app: traefik template: metadata: labels: app: traefik spec: serviceAccountName: traefik-ingress-controller containers: - name: traefik image: traefik:v2.0 args: - --api - --accesslog - --entrypoints=Name:web Address::8000 - --entrypoints=Name:websecure Address::4443 - --providers.kubernetescrd - --providers.kubernetescrd.trace - --acme - --acme.acmelogging - --acme.tlschallenge - --acme.onhostrule - --acme.email=foo@you.com - --acme.entrypoint=websecure - --acme.storage=acme.json # Please note that this is the staging Let's Encrypt server. # Once you get things working, you should remove that whole line altogether. - --acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory ports: - name: web containerPort: 8000 - name: websecure containerPort: 4443 - name: admin containerPort: 8080 --- kind: Deployment apiVersion: extensions/v1beta1 metadata: namespace: default name: whoami labels: app: whoami spec: replicas: 2 selector: matchLabels: app: whoami template: metadata: labels: app: whoami spec: containers: - name: whoami image: containous/whoami ports: - name: web containerPort: 80","title":"Deployments"},{"location":"user-guides/crd-acme/#port-forwarding","text":"Now, as an exception to what we said above, please note that you should not let the ingressRoute resources below be applied automatically to your cluster. The reason is, as soon as the ACME provider of Traefik detects we have TLS routers, it will try to generate the certificates for the corresponding domains. And this will not work, because as it is, our Traefik pod is not reachable from the outside, which will make the ACME TLS challenge fail. Therefore, for the whole thing to work, we must delay applying the ingressRoute resources until we have port-forwarding set up properly, which is the next step. kubectl port-forward --address 0.0.0.0 service/traefik 8000:8000 8080:8080 443:4443 -n default Also, and this is out of the scope if this guide, please note that because of the privileged ports limitation on Linux, the above command might fail to listen on port 443. In which case you can use tricks such as elevating caps of kubectl with setcaps , or using authbind , or setting up a NAT between your host and the WAN. Look it up.","title":"Port Forwarding"},{"location":"user-guides/crd-acme/#traefik-routers","text":"We can now finally apply the actual ingressRoutes, with: kubectl apply -f 04-ingressroutes.yml apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: simpleingressroute spec: entrypoints: - web routes: - match: Host(`your.domain.com`) && PathPrefix(`/notls`) kind: Rule services: - name: whoami port: 80 --- apiVersion: traefik.containo.us/v1alpha1 kind: IngressRoute metadata: name: ingressroutetls spec: entrypoints: - websecure routes: - match: Host(`your.domain.com`) && PathPrefix(`/tls`) kind: Rule services: - name: whoami port: 80 tls: secretName: \"\" Give it a few seconds for the ACME TLS challenge to complete, and you should then be able to access your whoami pod (routed through Traefik), from the outside. Both with or (just for fun, do not do that in production) without TLS: curl [-k] https://your.domain.com/tls curl [-k] http://your.domain.com:8000/notls Note that you'll have to use -k as long as you're using the staging server of Let's Encrypt, since it is not in the root DNS servers.","title":"Traefik Routers"}]}